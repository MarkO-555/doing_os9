\ Y: Instruction Pointer
\ X: temporary W register
\ U: Param Stack
\ S: Return Stack

2 allot here
2 allot latest
2 allot inlen
2 allot inptr
81 allot inbuf
2 allot wordlen
32 allot wordbuf
81 allot tmpbuf

: wordinit
  inlen 0 !
  inptr 0 !
  wordlen 0 !
  ;

\ sets inlen, inptr, & inbuf
: getline ( -- ) 
    0 i$readln inlen !
    0 inptr !
  ;

\ sets wordlen & wordbuf
: getword ( -- )
    begin  inbuf inptr @ + c@ 32 <=   inptr @ inlen @ <  and  while $1100 . inptr @ 1 + inptr ! repeat

    inptr @ inlen @ >=  if
      $1101 . getline getword $1102 .
    else
      $1103 .
      0 wordlen !
      begin  inbuf inptr @ + c@ 32 >  inptr @ inlen @ <  and  while $1105 .
        inbuf inptr @ + c@  wordbuf wordlen @ +  c!
        inptr @ 1 + inptr !
        wordlen @ 1 + wordlen !
      repeat
      $1109 .
    then
;


: i$readln ( pathNum -- bytesRead )
    >r                             \ save pathNum
    81 0 do inbuf i + 0 c! loop    \ clear buffer
    0 80 inbuf r> $8B os9 dup      \ os9 I$ReadLn
      if . $9999 . bye else drop   \ if error
        drop drop swap drop then ; \ return bytesRead from Y

: show5stack
  dup . >r
  dup . >r
  dup . >r
  dup . >r
  dup .
  r> r> r> r>
  ;

\ Stacking Order: PC U Y X D CC
: os9      ( U Y X D syscallNum -- U Y X D zeroOrError )
  $9001 . show5stack cr
  swibuf os9' dup drop
  $9002 . show5stack cr
  ;

4 allot swibuf  \ Will compose 4 bytes  of machine code here.

code os9'  ( U Y X D syscallNum swibufLoc -- U Y X D zeroOrError )
  pshs Y,U    ; save Forth state

  * leax c_swibuf,pcr  ; Gonna call word swibuf, to get buffer address.
  * pshu x             ; param to execute
  * jsr Execute,pcr
  pulu y   ; Y := swibuf location.


  * Push syscall in registers onto S.
  leax rts_os9,pcr  # Where the swibuf rts will return to.
  pshs x   ; PC: swibuf location, to be jumped to by "puls ...PC...".

  pshs y   ; will pull PC to jump into swibuf.
  ldx 8,u  ; users's U param
  pshs x   ; will pull U
  ldx 6,u  ; users's Y param
  pshs x   ; will pull Y
  ldx 4,u  ; users's X param
  pshs x   ; will pull X
  ldx 2,u  ; users's D param
  pshs x   ; will pull D

  * Fill in the swibuf.
  ldd 0,u  ; users's syscallNum param
  stb 2,y  ; opcode will follow 2-byte SWI2
  ldd #$103F ; opcode for swi2
  std 0,y
  ldb #$39  ; opcode for rts
  stb 3,y

  * Make the call.
  puls D,X,Y,U,PC

  * Pulling PC executes SWI2 and RTS to next label.
rts_os9
  * Save all the results.
  pshs U,Y,X,B,A  ; note saving 8 bytes.
  bcc good_os9
  * If Carry bit says Error
  clra
  ldb 1,s
  bra z_os9
good_os9
  clra
  clrb
z_os9
  ldu 10,s  ; we need our forth U now.

  std 0,u  ; Return error num or zero.

  lda 0,s  ; grab A from the stack.
  clrb     ; supress B now.
  std 2,u  ; Return D with error still in B.

  ldd 2,s
  std 4,u  ; return X

  ldd 4,s
  std 6,u  ; return Y

  ldd 6,s
  std 8,u  ; return U

  leas 8,s  ; Remove all that returned stuff from S stack.

  puls Y,U  ; Recover forth state (even though we already got U).
  ;

code execute
  pulU x       ; arg -> W
  ldd 0,x      ; goto W+[W]
  jmp D,X
  ;

code swap
  ldx 2,u
  ldd 0,u
  stx 0,u
  std 2,u
  ;

code rot
  ldx 4,u
  ldd 2,u
  std 4,u
  ldd 0,u
  std 2,u
  stx 0,u
  ;

code dup
  ldd 0,u
  std ,--u
  ;

code drop
  leau 2,u
  ;

code c*     ; only multiplies two bytes.
  ldd ,u++  ; really we want b.
  lda 1,u   ; low byte into a.
  mul       ; D := A * B
  std 0,u
  ;
code +
  ldd ,u++
  addd 0,u
  std 0,u
  ;
code -
  ldd ,u++
  subd 0,u
  std 0,u
  ;
code 1+
  ldd ,u
  addd #1
  std ,u
  ;
code 1-
  ldd ,u
  subd #1
  std ,u
  ;
code and
  ldd ,u++
  anda 0,u
  andb 1,u
  std 0,u
  ;
code or
  ldd ,u++
  ora 0,u
  orb 1,u
  std 0,u
  ;
code xor
  ldd ,u++
  eora 0,u
  eorb 1,u
  std 0,u
  ;
code sex
  ldd ,u
  sex
  std ,u
  ;

code .
*** Currently prints only in HEX.
  ldd ,u++
  jsr PrintD,pcr
  ldb #32
  jsr putchar,pcr
  ;

code putchar
  ldd ,u++
  jsr putchar,pcr
  ;

code cr
  ldb #13  ; CR
  jsr putchar,pcr
  ;

code lit
  ldd ,Y++  ; get next cell from IP
  std ,--u  ; and stack it.
  ;

code branch
  ldd ,Y++  ; get next cell from IP
  leay d,y  ; add that offset to the IP.
  jmp Next,pcr
  ;

code 0branch
  ldd ,Y++  ; get next cell from IP
  ldx ,u++  ; pop a cell from the param stack
  bne b0001 ; only change IP if that was zero.
  leay d,y  ; add that offset to the IP.
b0001
  jmp Next,pcr
  ;

code not0branch
  ldd ,u++  ; pop a cell from the param stack
  beq b0002 ; only change IP if that was not zero.
  ldd ,Y++  ; get next cell from IP
  leay d,y  ; add that offset to the IP.
b0002
  jmp Next,pcr
  ;

code =
  ldd ,u++
  cmpd ,u
  beq SetTrue
  bra SetFalse
  ;
code <>
  ldd ,u++
  cmpd ,u
  bne SetTrue
  bra SetFalse
  ;
code <
  ldd ,u++
  cmpd ,u
  bgt SetTrue
  bra SetFalse
  ;
code <=
  ldd ,u++
  cmpd ,u
  bge SetTrue
  bra SetFalse
  ;
code >
  ldd ,u++
  cmpd ,u
  blt SetTrue
  bra SetFalse
  ;
code >=
  ldd ,u++
  cmpd ,u
  ble SetTrue
  bra SetFalse
SetTrue
  clra  ; replace TOS with 1.
  clrb
  incb
  std ,u
  jmp Next,pcr
SetFalse
  clra  ; replace TOS with 0.
  clrb
  std ,u
  jmp Next,pcr
  ;

code r0
  ldd ,s
  std ,--u
  jmp Next,pcr
  ;
code r1
  ldd 2,s
  std ,--u
  jmp Next,pcr
  ;
code i
  ldd 2,s
  std ,--u
  jmp Next,pcr
  ;
code r1!
  ldd ,u++
  std 2,s
  jmp Next,pcr
  ;
code i!
  ldd 2,s
  std ,--u
  jmp Next,pcr
  ;

code >r
  ldd ,u++    ; pop from u, push to s.
  std ,--s
  jmp Next,pcr
  ;

code r>
  ldd ,s++    ; pop from s, push to u.
  std ,--u
  jmp Next,pcr
  ;

code rdrop
  leas 2,s    ; pop from s and discard.
  jmp Next,pcr
  ;

code !
  ldx ,u++    ; pop address
  ldd ,u++    ; pop value
  std ,x      ; poke
  jmp Next,pcr
  ;

code @
  ldx ,u      ; the address from the stack
  ldd ,x      ; what was at the address
  std ,u      ; value onto stack
  jmp Next,pcr
  ;

code c!
  ldx ,u++    ; pop address
  ldd ,u++    ; pop value
  stb ,x      ; poke just the low byte.
  jmp Next,pcr
  ;

code c@
  ldx ,u      ; the address from the stack
  ldb ,x      ; what byte was at the address
  clra
  std ,u      ; value onto stack
  jmp Next,pcr
  ;

code exit
  pulS y       ; pop previous IP.
  jmp Next,pcr ; and keep going.
  ;

code bye
OsExit
  ldb #13  ; CR
  jsr putchar,pcr
  clrb
  os9 F$Exit
  ;

code must
  ldx ,u++      tag
  ldd ,u++      value
  bne ret_must
  ldb #$3F  '?'
  jsr putchar,pcr
  tfr x,d
  jsr PrintD,pcr
  ldb #$3F  '?'
  jsr putchar,pcr
  ldb #$0D  CR
  jsr putchar,pcr
  ldb #255
  os9 F$Exit
ret_must
  jmp Next,pcr
  ;

: bl 32 ;

: words
  latest @
  begin
    dup
  while
    dup
    2 + c@  0  do
      dup 3 + i + c@ putchar
      loop
    bl putchar
    dup @  dup if  +  else  drop 0  then \ add offset to base, unless offset is 0.
  repeat
  ;



: double
    dup + ;
: main1
    $D putchar $2 dup . double dup . double dup . double .
    here . here @ .
    latest . latest @ .
    inbuf . tmpbuf .
    cr getline cr . cr
    ;

: main_getline  getline . . cr cr ;
\ : main_getchar  getchar . getchar . getchar . getchar . cr cr ;

2 allot tmp

: main
    1 $888 must
    \ 0 $666 must
    cr
    64 putchar
    0 if 33 putchar then
    5 if 53 putchar then
    cr
    0 if 33 else 126 then putchar
    5 if 53 else 126 then putchar
    cr
    1 tmp !
    begin
      99 putchar
      tmp @
    while
      100 putchar
      0 tmp !
    repeat cr

    10 0 do i . loop  cr

    words cr cr
    wordinit
    0 0 0 0 12 os9 . . . . . cr

    $8000 . 0 i$readln dup .
      dup 0 do inbuf i + c@ . loop
      dup 0 do inbuf i + c@ putchar loop cr
      drop cr

    $8001 . getword wordlen @ . $8002 . getword wordlen @ .

    $8888 . bye
  ;
