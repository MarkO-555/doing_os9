\ Y: Instruction Pointer
\ X: temporary W register
\ U: Param Stack
\ S: Return Stack

2 allot return0
2 allot param0
2 allot octothorpe
2 allot here
2 allot latest
2 allot inlen
2 allot inptr
2 allot wordlen

2 allot traceEnable

33 allot wordbuf
81 allot inbuf
81 allot tmpbuf

: sp bl putchar ;

: interpret \ REPL loop
  begin 1 while
    sp ." ok " cr \ Prompt.

    getword find
    dup if
      ." >>>>> " dup putstr ." >>> " sp >cfa execute
    then
    
  repeat
  ;

: show-buf \ ( ptr len -- )
  91 putchar
  0 do
    dup i + c@ putchar
  loop
  93 putchar
  ;

: emit_litstr  \ Internal word for `."`, followed by nul-terminated string data.
  r>  \ take what would be the return IP, but is the addr of the string.
  begin
    dup c@  \ until EOS
  while
    dup c@ putchar
    1 +     \ advance ptr
  repeat
  1 +  \ advance pointer past EOS
  >r  \ and that's where we execute next.
  ;
: addr_litstr  \ Internal word for `"`, followed by nul-terminated string data.
  r>  \ take what would be the return IP, but is the addr of the string.
  dup  \ save a copy to return.
  begin
    dup c@  \ until EOS
  while
    1 +     \ advance ptr
  repeat
  1 +  \ advance pointer past EOS
  >r  \ and that's where we execute next.
  \ return addr of string.
  ;
: putstr \ ( addr -- )
  begin
    dup c@  \ until EOS
  while
    dup c@ putchar
    1 +     \ advance ptr
  repeat
  drop
  ;
  

: wordinit
  inlen 0 !
  inptr 0 !
  wordlen 0 !
  ;

\ sets inlen, inptr, & inbuf
: getline ( -- ) 
    0 i$readln inlen !
    0 inptr !
  ;

\ sets wordlen & wordbuf
: getword ( -- )
    33 0 do   0  wordbuf i +  c!   loop    \ clear buffer
    begin  inbuf inptr @ + c@ 32 <=   inptr @ inlen @ <  and  while inptr @ 1 + inptr ! repeat

    inptr @ inlen @ >=  if
      getline getword 
    else
      
      0 wordlen !
      begin  inbuf inptr @ + c@ 32 >  inptr @ inlen @ <  and  while 
        inbuf inptr @ + c@  wordbuf wordlen @ +  c!
        inptr @ 1 + inptr !
        wordlen @ 1 + wordlen !
      repeat
      
    then
;


: i$readln ( pathNum -- bytesRead )
    >r                             \ save pathNum
    81 0 do 0 inbuf i + c! loop    \ clear buffer
    0 80 inbuf r> $8B os9 dup      \ os9 I$ReadLn
      if . $9999 . bye else drop   \ if error
        drop drop swap drop then ; \ return bytesRead from Y

: show5stack
  dup . >r
  dup . >r
  dup . >r
  dup . >r
  dup .
  r> r> r> r>
  ;

\ Stacking Order: PC U Y X D CC
: os9      ( U Y X D syscallNum -- U Y X D zeroOrError )
  $9001 . show5stack cr
  swibuf os9' dup drop
  $9002 . show5stack cr
  ;

4 allot swibuf  \ Will compose 4 bytes  of machine code here.

code os9'  ( U Y X D syscallNum swibufLoc -- U Y X D zeroOrError )
  pshs Y,U    ; save Forth state

  * leax c_swibuf,pcr  ; Gonna call word swibuf, to get buffer address.
  * pshu x             ; param to execute
  * jsr Execute,pcr
  pulu y   ; Y := swibuf location.


  * Push syscall in registers onto S.
  leax rts_os9,pcr  # Where the swibuf rts will return to.
  pshs x   ; PC: swibuf location, to be jumped to by "puls ...PC...".

  pshs y   ; will pull PC to jump into swibuf.
  ldx 8,u  ; users's U param
  pshs x   ; will pull U
  ldx 6,u  ; users's Y param
  pshs x   ; will pull Y
  ldx 4,u  ; users's X param
  pshs x   ; will pull X
  ldx 2,u  ; users's D param
  pshs x   ; will pull D

  * Fill in the swibuf.
  ldd 0,u  ; users's syscallNum param
  stb 2,y  ; opcode will follow 2-byte SWI2
  ldd #$103F ; opcode for swi2
  std 0,y
  ldb #$39  ; opcode for rts
  stb 3,y

  * Make the call.
  puls D,X,Y,U,PC

  * Pulling PC executes SWI2 and RTS to next label.
rts_os9
  * Save all the results.
  pshs U,Y,X,B,A  ; note saving 8 bytes.
  bcc good_os9
  * If Carry bit says Error
  clra
  ldb 1,s
  bra z_os9
good_os9
  clra
  clrb
z_os9
  ldu 10,s  ; we need our forth U now.

  std 0,u  ; Return error num or zero.

  lda 0,s  ; grab A from the stack.
  clrb     ; supress B now.
  std 2,u  ; Return D with error still in B.

  ldd 2,s
  std 4,u  ; return X

  ldd 4,s
  std 6,u  ; return Y

  ldd 6,s
  std 8,u  ; return U

  leas 8,s  ; Remove all that returned stuff from S stack.

  puls Y,U  ; Recover forth state (even though we already got U).
  ;

: double
  <#
      0 #  dup  1 #  +  0 #
   #>
  ;

code <#
octomagic equ $7FED
  ldx <u_octothorpe
  sts <u_octothorpe
  ldd #octomagic
  pshs u,x,d
  ; 

code #>
  ldd #octomagic
  cmpd ,s++  ; check magic
  beq L_7fed
  fcb 1        ; illegal opcode halts emulator.

L_7fed
  ldx ,s++
  stx <u_octothorpe   ; unlink the frame.

  leas 2,s  ; drop stored U
  nop
  ;

code #
  ldd ,u++
  negb           ; assume range -127..127
  lslb           ; times 2
  sex

  ldx <u_octothorpe
  ldx -2,x        ; original U PSP
  leax d,x       ; add D to it.
  pshs x         ; stack it.
  cmpu 0,s       ; compare current U to stack.
  puls x
  beq L_1fed
  fcb 1        ; illegal opcode halts emulator.

L_1fed
  ldx <u_octothorpe
  ldd #octomagic
  cmpd -6,x
  beq L_2fed
  fcb 1

L_2fed
  nop            ; ok good.
  ;

code ###
  ldd #octomagic
  cmpd 0,s       ; check magic
  beq L_9fed
  fcb 1
L_9fed
  ldd ,u++
  negb           ; assume range -127..127
  lslb           ; times 2
  sex
  ldx 4,s        ; original U PSP
  leax d,x       ; add D to it.
  pshs x         ; stack it.
  cmpu 0,s       ; compare current U to stack.
  beq L_3fed
  puls x
  fcb 1        ; illegal opcode halts emulator.
L_3fed
  puls x
  nop            ; ok good.
  ;



code execute
  pulU x       ; arg -> W
  ldd 0,x      ; goto W+[W]
  jmp D,X
  ;

code rsp
  pshu s
  ;
code psp
  tfr u,d
  pshu d
  ;

code swap
  ldx 2,u
  ldd 0,u
  stx 0,u
  std 2,u
  ;

code rot
  ldx 4,u
  ldd 2,u
  std 4,u
  ldd 0,u
  std 2,u
  stx 0,u
  ;

code over
  ldd 2,u
  std ,--u
  ;

code dup
  ldd 0,u
  std ,--u
  ;

code drop
  leau 2,u
  ;

code c*     ; only multiplies two bytes.
  ldd ,u++  ; really we want b.
  lda 1,u   ; low byte into a.
  mul       ; D := A * B
  std 0,u
  ;
code +
  ldd ,u++
  addd 0,u
  std 0,u
  ;
code -
  ldd #0
  subd ,u++
  addd 0,u
  std 0,u
  ;
code 1+
  ldd ,u
  addd #1
  std ,u
  ;
code 1-
  ldd ,u
  subd #1
  std ,u
  ;
code and
  ldd ,u++
  anda 0,u
  andb 1,u
  std 0,u
  ;
code or
  ldd ,u++
  ora 0,u
  orb 1,u
  std 0,u
  ;
code xor
  ldd ,u++
  eora 0,u
  eorb 1,u
  std 0,u
  ;
code sex
  ldd ,u
  sex
  std ,u
  ;
code lsr
  ldd ,u
  lsra
  rorb
  std ,u
  ;

code .
*** Currently prints only in HEX.
  ldd ,u++
  jsr PrintD,pcr
  ldb #32
  jsr putchar,pcr
  ;

code putchar
  ldd ,u++
  jsr putchar,pcr
  ;

code cr
  ldb #13  ; CR
  jsr putchar,pcr
  ;

code lit
  ldd ,Y++  ; get next cell from IP
  std ,--u  ; and stack it.
  ;

code branch
  ldd ,Y++  ; get next cell from IP
  leay d,y  ; add that offset to the IP.
  jmp Next,pcr
  ;

code 0branch
  ldd ,Y++  ; get next cell from IP
  ldx ,u++  ; pop a cell from the param stack
  bne b0001 ; only change IP if that was zero.
  leay d,y  ; add that offset to the IP.
b0001
  jmp Next,pcr
  ;

code not0branch
  ldd ,u++  ; pop a cell from the param stack
  beq b0002 ; only change IP if that was not zero.
  ldd ,Y++  ; get next cell from IP
  leay d,y  ; add that offset to the IP.
b0002
  jmp Next,pcr
  ;

code =
  ldd ,u++
  cmpd ,u
  beq SetTrue
  bra SetFalse
  ;
code <>
  ldd ,u++
  cmpd ,u
  bne SetTrue
  bra SetFalse
  ;
code <
  ldd ,u++
  cmpd ,u
  bgt SetTrue
  bra SetFalse
  ;
code <=
  ldd ,u++
  cmpd ,u
  bge SetTrue
  bra SetFalse
  ;
code >
  ldd ,u++
  cmpd ,u
  blt SetTrue
  bra SetFalse
  ;
code >=
  ldd ,u++
  cmpd ,u
  ble SetTrue
  bra SetFalse
SetTrue
  clra  ; replace TOS with 1.
  clrb
  incb
  std ,u
  jmp Next,pcr
SetFalse
  clra  ; replace TOS with 0.
  clrb
  std ,u
  jmp Next,pcr
  ;

code r0
  ldd ,s
  std ,--u
  jmp Next,pcr
  ;
code r1
  ldd 2,s
  std ,--u
  jmp Next,pcr
  ;
code i
  ldd 2,s
  std ,--u
  jmp Next,pcr
  ;
code r1!
  ldd ,u++
  std 2,s
  jmp Next,pcr
  ;
code i!
  ldd 2,s
  std ,--u
  jmp Next,pcr
  ;

code >r
  ldd ,u++    ; pop from u, push to s.
  std ,--s
  jmp Next,pcr
  ;

code r>
  ldd ,s++    ; pop from s, push to u.
  std ,--u
  jmp Next,pcr
  ;

code rdrop
  leas 2,s    ; pop from s and discard.
  jmp Next,pcr
  ;

code !
  ldx ,u++    ; pop address
  ldd ,u++    ; pop value
  std ,x      ; poke
  jmp Next,pcr
  ;

code @
  ldx ,u      ; the address from the stack
  ldd ,x      ; what was at the address
  std ,u      ; value onto stack
  jmp Next,pcr
  ;

code c!
  ldx ,u++    ; pop address
  ldd ,u++    ; pop value
  stb ,x      ; poke just the low byte.
  jmp Next,pcr
  ;

code c@
  ldx ,u      ; the address from the stack
  ldb ,x      ; what byte was at the address
  clra
  std ,u      ; value onto stack
  jmp Next,pcr
  ;

code exit
  pulS y       ; pop previous IP.
  jmp Next,pcr ; and keep going.
  ;

code bye
OsExit
  ldb #13  ; CR
  jsr putchar,pcr
  clrb
  os9 F$Exit
  ;

: .s \ print stack
  ." [=[ "
  psp param0 @ swap - lsr dup .
  ." # "
  0 do
    param0 @  i i + 2 +  -  @ .
  loop
  ." ]=] "
  ;

code must
  ldx ,u++      tag
  ldd ,u++      value
  bne ret_must
  ldb #$3F  '?'
  jsr putchar,pcr
  tfr x,d
  jsr PrintD,pcr
  ldb #$3F  '?'
  jsr putchar,pcr
  ldb #$0D  CR
  jsr putchar,pcr
  ldb #255
  os9 F$Exit
ret_must
  jmp Next,pcr
  ;

: bl 32 ;

: strlen \ ( ptr -- len )
  <#
  0 swap
  1 #
  begin
    dup c@    2 #
  while       1 #
    1 + \ on the pointer
    swap 1 + \ on the counter
    swap
  repeat
  1 #
  drop    \ return just the count.
  #>
  ;

: streq \ ( ptr1 ptr2 -- bool )
<#
  begin
    $4441 .   0 #
    dup c@   dup putchar 0 <> >r  over c@  dup putchar 0 <>   r> or  \ break when either terminates.
  while
    $4442 .
    \ if not the same, then exit false.
    dup c@  >r  over c@  r>  <> if  drop drop 0     -1 # #> exit  then
    1 + swap 1 + swap  \ advance both pointers
    0 #
  repeat
  $4443 .
    0 #

  c@ 0 =  swap c@ 0 =  and  \ true of both terminate here.
  $4444 . dup .
  -1 #
#>
  ;
    
: find
<#  
  >r    \ save sought word in R
  latest @  \ traverse dictionary
  0 #
  begin      0 #
    $5550 .
    dup
  while      0 #
    dup      1 #
    3 +   1 #     r> dup >r  2 #  dup putstr     ." ( "  2 #  over putstr   2 #  ." | " dup putstr ." ) "  2 #   streq   1 #
    if
      $5555 .
      0 #  rdrop #> exit
    then
    0 #
    dup @  dup   if 1 #   + else 1 #   drop drop 0  then      \ add offset to base, unless offset is 0.
  repeat     0 #
  $5559 .
  drop
  0
  rdrop
0 # #>
  ;

: >cfa
  2 + dup c@ \ skip to the length byte & fetch it.
  + 1 + \ advance length and null term.
  ;
: words
  latest @
  begin
    dup
  while
    dup
    2 + c@  0  do
      dup 3 + i + c@ putchar
      loop
    bl putchar
    dup @  dup if  +  else  then \ add offset to base, unless offset is 0.
  repeat
  ;



\ : double
\     dup + ;
: main1
    $D putchar $2 dup . double dup . double dup . double .
    here . here @ .
    latest . latest @ .
    inbuf . tmpbuf .
    cr getline cr . cr
    ;

: main_getline  getline . . cr cr ;
\ : main_getchar  getchar . getchar . getchar . getchar . cr cr ;

2 allot tmp

: main
    ." Hello FORTH World " ." ! " cr

    20 double . cr

1 traceEnable !
    100 . 100 8 - . cr
    8 . 8 100 - . cr
    " Hello FORTH World: " dup putstr putstr cr
    1 $888 must
    \ 0 $666 must
    64 putchar
    0 if 33 putchar then
    5 if 53 putchar then
    cr
    0 if 33 else 126 then putchar
    5 if 53 else 126 then putchar
    cr
    1 tmp !
    begin
      99 putchar
      tmp @
    while
      100 putchar
      0 tmp !
    repeat cr

    10 0 do i . loop  cr

    \ wordinit
    0 0 0 0 12 os9 . . . . . cr  \ process id, user id

    ." WORDS: "
    words cr cr
    ." Trying abc "   sp   " abc " " abc " streq . cr
    ." Trying abx "    sp  " abc " " abx " streq . cr
    ." Trying ab "    sp  " abc " " ab " streq . cr
    ." Trying abcdefg "  sp    " abc " " abcdefg " streq . cr
    cr cr
1 traceEnable !
    ." FIND+ " " + " find .  cr
0 traceEnable !
    ." FIND% " " % " find .  cr
    cr cr

    \ $8000 . 0 i$readln dup .
      \ dup 0 do inbuf i + c@ . loop
      \ dup 0 do inbuf i + c@ putchar loop cr
      \ drop cr

    \ $8001 . getword wordlen @ . wordbuf strlen . wordbuf 33 show-buf
    \ $8002 . getword wordlen @ . wordbuf strlen . wordbuf 33 show-buf

    $8888 . bye
  ;
