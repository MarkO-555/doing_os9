\ Y: Instruction Pointer
\ X: temporary W register
\ U: Param Stack
\ S: Return Stack

2 allot here
2 allot latest
80 allot inbuf
80 allot tmpbuf

code execute
  pulU x       ; arg -> W
  ldd 0,x      ; goto W+[W]
  jmp D,X
  ;

code swap
  ldx 2,u
  ldd 0,u
  stx 0,u
  std 2,u
  ;

code rot
  ldx 4,u
  ldd 2,u
  std 4,u
  ldd 0,u
  std 2,u
  stx 0,u
  ;
 
code dup
  ldd 0,u
  std ,--u
  ;

code +
  ldd ,u++
  addd 0,u
  std 0,u
  ;

code .
*** Currently prints only in HEX.
  ldd ,u++
  jsr PrintD,pcr
  ldb #32
  jsr putchar,pcr
  ;

code putchar
  ldd ,u++
  jsr putchar,pcr
  ;

code lit
  ldd ,Y++  ; get next cell from IP
  std ,--u  ; and stack it.
  ;

code branch
  ldd ,Y++  ; get next cell from IP
  leay d,y  ; add that offset to the IP.
  jmp Next,pcr
  ;

code 0branch
  ldd ,u++  ; pop a cell from the param stack
  bne b0001 ; only change IP if that was zero.
  ldd ,Y++  ; get next cell from IP
  leay d,y  ; add that offset to the IP.
b0001
  jmp Next,pcr
  ;

code not0branch
  ldd ,u++  ; pop a cell from the param stack
  beq b0002 ; only change IP if that was not zero.
  ldd ,Y++  ; get next cell from IP
  leay d,y  ; add that offset to the IP.
b0002
  jmp Next,pcr
  ;

code >r
  ldd ,u++    ; pop from u, push to s.
  std ,--s
  jmp Next,pcr
  ;

code r>
  ldd ,s++    ; pop from s, push to u.
  std ,--u
  jmp Next,pcr
  ;

code !
  ldx ,u++    ; pop address
  ldd ,u++    ; pop value
  std ,x      ; poke
  jmp Next,pcr
  ;

code @
  ldx ,u      ; the address from the stack
  ldd ,x      ; what was at the address
  std ,u      ; value onto stack
  jmp Next,pcr
  ;

code C!
  ldx ,u++    ; pop address
  ldd ,u++    ; pop value
  stb ,x      ; poke just the low byte.
  jmp Next,pcr
  ;

code C@
  ldx ,u      ; the address from the stack
  ldb ,x      ; what byte was at the address
  clra
  std ,u      ; value onto stack
  jmp Next,pcr
  ;

code exit
  pulS y       ; pop previous IP.
  jmp Next,pcr ; and keep going.
  ;

code bye
OsExit
  ldb #13  ; CR
  jsr putchar,pcr
  ldb #35  ; #
  jsr putchar,pcr
  ldb #13  ; CR
  jsr putchar,pcr
  clrb
  ldb #8
  os9 F$Exit
  ;

: double
    dup + ;
: main
    $D putchar $2 dup . double dup . double dup . double .
    here . here @ . 
    latest . latest @ . 
    inbuf . tmpbuf . bye ;
\ END.
