# wrap_ncl.py : wrap the assembly code generated by cmoc for NCL as an OS9 Module.

import sys, re, os
from collections import defaultdict

MatchSection = re.compile(r'^\s+SECTION\s*([a-z0-9_]+)').match
MatchEndSection = re.compile(r'^\s+ENDSECTION').match
MatchImport = re.compile(r'^([A-Za-z0-9_.$]+)\s+IMPORT').match
MatchExport = re.compile(r'^([A-Za-z0-9_.$]+)\s+EXPORT').match

def Slurp(r):
    imps = []
    d = defaultdict(list)
    name = 'outside'
    for line in r:
        line = line.rstrip()
        m = MatchSection(line)
        if m:
            name = m.group(1)
        elif MatchEndSection(line):
            name = 'outside'
        else:
            d[name].append(line)
            if name == 'outside':
                m = MatchImport(line)
                if m:
                    imps.append(m.group(1))
    return d, imps

d, imps = Slurp(sys.stdin)

print ( '''*** Generated Code (by wrap_ncl.py)
    nam NCL
    ttl NCL

F_Exit          equ     $06     ; Terminate Process
F_Sleep         equ     $0A     ; Suspend Process
I_Write         equ     $8A     ; Write Data
I_ReadLn        equ     $8B     ; Read Line of ASCII Data
I_WritLn        equ     $8C     ; Write Line of ASCII Data

Prgrm          EQU       $10                 Program Module
Objct          EQU       1                   6809 Object Code Module
ReEnt          EQU       %10000000           Re-Entrant Module

tylg     set   Prgrm+Objct
atrv     set   ReEnt+rev
rev      set   $00
edition  set   1

    mod   eom,name,tylg,atrv,start,$8000
name
    fcs /NCL/
    fcb edition

start  pshs Y,U

* **** CASE: USE THIS TO CLEAR ALL MEM ****
* * Need to clear from U to SP.    
* * How many bytes?   SP - U.
*     tfr s,d    ; start with SP
*     subd 2,s    ; subtract pushed U
*     tfr d,x   ; counter in X

**** CASE: USE THIS TO CLEAR ONLY BSS ****
**** ALSO don't #define ZERO_FRESH ****
    ldx #bss_end

    ldb #0
ClearLoop stb ,u+
    leax -1,x
    bne ClearLoop

    puls Y,U
    sts _heap_max,U  ;for malloc
    sts _param_min,U
    sty _param_max,U

    leax bss_end,U
    stx _heap_min  ;for malloc
    stx _heap_brk  ;for malloc

    tfr u,y  ; With cmoc, Y points to the start of global memory.
    ldu #0   ; NULL initial frame pointer.
    pshs U
    pshs U
    pshs U
    pshs U
    lbsr _main
    os9 F_Exit

    org 0                  ; start of global variables.
__unused__   RMB 2   ; Never put things at address 0.

* ;;;;;;;;;;;;;;; bss
''')

for section in ['bss', 'code', 'rodata']:
    for e in d[section]:
        if MatchImport(e): continue
        if MatchExport(e): continue
        if section == 'bss':
            # Use `.` for variable location; `*` is for code.
            if len(e) > 1 and e.endswith('*'):
                # Change final `*` to `.`
                e = e[:-1] + '.'
        print ( e )

# MUL/DIV SUPPORT
print ( '''

* Multiply D by X, unsigned; return result in D; preserve X.
MUL16   PSHS    U,X,B,A         U pushed to create 2 temp bytes at 4,S
        LDB     3,S             low byte of original X
        MUL
        STD     4,S             keep for later
        LDD     1,S             low byte of orig D, high byte of orig X
        MUL
        ADDB    5,S             only low byte is needed
        STB     5,S
        LDA     1,S             low byte of orig D
        LDB     3,S             low byte of orig X
        MUL
        ADDA    5,S
        LEAS    6,S
        RTS


* Divide X by D, signed; return quotient in X, remainder in D.
* Non-zero remainder is negative iff dividend is negative.
SDIV16  PSHS    X,B,A
        CLR     ,-S             counter: number of negative arguments (0..2)
        CLR     ,-S             boolean: was dividend negative?
        TSTA                    is divisor negative?
        BGE     SDIV16_10       if not
        INC     1,S
        COMA                    negate divisor
        COMB
        ADDD    #1
        STD     2,S
SDIV16_10
        LDD     4,S             is dividend negative?
        BGE     SDIV16_20       if not
        INC     ,S
        INC     1,S
        COMA                    negate dividend
        COMB
        ADDD    #1
        STD     4,S
SDIV16_20
        LDD     2,S             reload divisor
        LDX     4,S             reload dividend
        LBSR    DIV16

* Counter is 0, 1 or 2. Quotient negative if counter is 1.
        LSR     1,S             check bit 0 of counter (1 -> negative quotient)
        BCC     SDIV16_30       quotient not negative
        EXG     X,D             put quotient in D and remainder in X
        COMA                    negate quotient
        COMB
        ADDD    #1
        EXG     X,D             return quotient and remainder in X and D

SDIV16_30
* Negate the remainder if the dividend was negative.
        TST     ,S              was dividend negative?
        BEQ     SDIV16_40       if not
        COMA                    negate remainder
        COMB
        ADDD    #1
SDIV16_40
        LEAS    6,S
        RTS

* Divide X by D, unsigned; return quotient in X, remainder in D.
DIV16   PSHS    X,B,A
        LDB     #16
        PSHS    B
        CLRA
        CLRB
        PSHS    B,A
* 0,S=16-bit quotient; 2,S=loop counter;
* 3,S=16-bit divisor; 5,S=16-bit dividend

D16010  LSL     6,S             shift MSB of dividend into carry
        ROL     5,S             shift carry and MSB of dividend, into carry
        ROLB                    new bit of dividend now in bit 0 of B
        ROLA
        CMPD    3,S             does the divisor "fit" into D?
        BLO     D16020          if not
        SUBD    3,S
        ORCC    #1              set carry
        BRA     D16030
D16020  ANDCC   #$FE            reset carry
D16030  ROL     1,S             shift carry into quotient
        ROL     ,S

        DEC     2,S             another bit of the dividend to process?
        BNE     D16010          if yes

        PULS    X               quotient to return
        LEAS    5,S
        RTS

* MUL16BY10:  input & output in D.

MUL16BY10
        LSLB
        ROLA          ; that's times 2.
        PSHS D
        LSLB
        ROLA          ; that's times 4.
        LSLB
        ROLA          ; that's times 8.
        ADDD ,S++      ; 2 + 8 = 10.
        RTS

* Divide D by 10.
* Quotient left in D.
* Does not preserve X.
* Source: Hacker's Delight (Addison-Wesley, 2003, 2012)
*         http://www.hackersdelight.org/divcMore.pdf
*
DIV16BY10
        TFR     D,X     save n
        LSRA
        RORB            D = n >> 1
        PSHS    B,A     q := ,S (word)
        LSRA
        RORB            D = n >> 2
        ADDD    ,S
        STD     ,S      q = (n >> 1) + (n >> 2)
        LSRA
        RORB
        LSRA
        RORB
        LSRA
        RORB
        LSRA
        RORB
        ADDD    ,S
        STD     ,S      D = q + (q >> 4)
        TFR     A,B
        CLRA            q >> 8
        ADDD    ,S
        LSRA
        RORB
        LSRA
        RORB
        LSRA
        RORB            q >> 3
        STD     ,S
        LSLB
        ROLA
        LSLB
        ROLA            q << 2
        ADDD    ,S
        LSLB
        ROLA
        PSHS    B,A
        TFR     X,D     D = n
        SUBD    ,S++    D = r
        CMPD    #9      r > 9 ?
        BLS     DIV16BY10_010
        LDB     #1
        BRA     DIV16BY10_020
DIV16BY10_010
        CLRB
DIV16BY10_020
        LDA     ,S
        ADDB    1,S
        ADCA    #0
        PULS    X,PC    discard q and return D

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; signedJumpTableSwitch
; unsignedJumpTableSwitch
; Input: X => Table of 16-bit offsets, one for each non-default case.
;        D => Switch expression.
; Table: -6,X = minimum case value; -4,X: max value; -2,X: offset for default case.
;
; An offset is to be added to the address of the table (in X) to obtain
; the effective address of the case code to jump to.
;
signedJumpTableSwitch
        cmpd    -4,x        ; higher than max?
        bgt     @default
        subd    -6,x        ; switch value lower than minimum case value?
        blt     @default
        bra     @useTable
unsignedJumpTableSwitch
        cmpd    -4,x        ; higher than max?
        bhi     @default
        subd    -6,x        ; switch value lower than minimum case value?
        blo     @default
@useTable
        lslb                ; 2 bytes per address in table
        rola
        ldd     d,x         ; get offset from table
        jmp     d,x         ; add table address to offset to get absolute address to jump to
@default
        ldd     -2,x        ; get offset of default routine
        jmp     d,x


; Copies a region of memory into the stack.
; X: Address of the region to read.
; D: Size in bytes of the region. Must not be zero.
; S: Address where to copy the region to.
; Example:
;       LEAX    destination,PCR
;       LDD     #17
;       LEAS    -17,S
;       LBSR    pushStruct
; Preserves U, Y. Trashes D, X. Returns nothing.
;
pushStruct
        pshs    u
        leau    4,s             destination (past pushed U and return address)
        leas    -2,s
        pshs    x               preserve source address
        leax    d,x             compute end of source region
        stx     2,s             preserve end
        puls    x               restore source address; ,s is now end
@copyByte
        lda     ,x+
        sta     ,u+
        cmpx    ,s              compare with end address
        bne     @copyByte
        leas    2,s             dispose of end address
        puls    u,pc

* Shifts the 16-bit signed value on the stack right
* by a number of bits given in D.
* Result left in D.
* CAUTION: Trashes X and pops the 16-bit value off the stack.
*
shiftRightSigned
        addd    #0      any shift to do?
        beq     shiftRightSigned_no_change

        cmpd    #15     shifting all mantissa bits out?
        blo     shiftRightSigned_general        if not

* Shifting >= 15 bits out.
        ldd     2,s     left side of shift operator
        tfr     a,b     sign bit of D into bit 7 of B
        sex             repeat bit 7 of B eight times in A
        tfr     a,b     D = $FFFF if original D < 0; D = 0 otherwise
        bra     shiftRightSigned_end

shiftRightSigned_no_change
        ldd     2,s     return left side of shift operator as is
        bra     shiftRightSigned_end

shiftRightSigned_general
        pshs    b       save number of bits to shift
        ldd     3,s     get right side of shift operator
shiftRightSigned_loop
        asra
        rorb
        dec     ,s
        bne     shiftRightSigned_loop
        leas    1,s     discard counter
shiftRightSigned_end
        puls    x       pop return value
        leas    2,s     pop left side
        tfr     x,pc    return from routine (with result in D)

* Shifts the 16-bit unsigned value on the stack right
* by a number of bits given in D.
* Result left in D.
* CAUTION: Trashes X and pops the 16-bit value off the stack.
*
shiftRightUnsigned
        addd    #0      any shift to do?
        beq     shiftRightUnsigned_no_change

        cmpd    #16     shifting all bits out?
        blo     shiftRightUnsigned_general      if not

* Shifting >= 16 bits out.
        clra
        clrb
        bra     shiftRightUnsigned_end

shiftRightUnsigned_no_change
        ldd     2,s     return left side of shift operator as is
        bra     shiftRightUnsigned_end

shiftRightUnsigned_general
        pshs    b       save number of bits to shift
        ldd     3,s     get left side of shift operator
shiftRightUnsigned_loop
        lsra
        rorb
        dec     ,s
        bne     shiftRightUnsigned_loop
        leas    1,s     discard counter
shiftRightUnsigned_end
        puls    x       pop return value
        leas    2,s     pop left side
        tfr     x,pc    return from routine (with result in D)

* Shifts the 16-bit value on the stack left by
* a number of bits given in D.
* Result left in D.
* CAUTION: Trashes X and pops the 16-bit value off the stack.
*
shiftLeft
        addd    #0      any shift to do?
        beq     shiftLeft_no_change

        cmpd    #16     shifting all bits out?
        blo     shiftLeft_general       if not

* Shifting >= 16 bits out.
        clra
        clrb
        bra     shiftLeft_end

shiftLeft_no_change
        ldd     2,s     return left side of shift operator as is
        bra     shiftLeft_end

shiftLeft_general
        pshs    b       save number of bits to shift
        ldd     3,s     get left side of shift operator
shiftLeft_loop
        lslb
        rola
        dec     ,s
        bne     shiftLeft_loop
        leas    1,s     discard counter
shiftLeft_end
        puls    x       pop return value
        leas    2,s     pop left side
        tfr     x,pc    return from routine (with result in D)


''' )

# Finish the module.
print ( '''
    emod
eom equ *
''' )
