                      (    krn_beta5.asm):00001         ********************************************************************
                      (    krn_beta5.asm):00002         * krn - NitrOS-9 Level 2 Kernel
                      (    krn_beta5.asm):00003         *
                      (    krn_beta5.asm):00004         * $Id$
                      (    krn_beta5.asm):00005         *
                      (    krn_beta5.asm):00006         * Edt/Rev  YYYY/MM/DD  Modified by
                      (    krn_beta5.asm):00007         * Comment
                      (    krn_beta5.asm):00008         * ------------------------------------------------------------------
                      (    krn_beta5.asm):00009         *  19r6    2002/08/21  Boisy G. Pitre
                      (    krn_beta5.asm):00010         * Assembles to the os9p1 module that works on my NitrOS-9 system.
                      (    krn_beta5.asm):00011         *
                      (    krn_beta5.asm):00012         *  19r7    2002/09/26  Boisy G. Pitre
                      (    krn_beta5.asm):00013         * Added check for CRC feature bit in init module
                      (    krn_beta5.asm):00014         *
                      (    krn_beta5.asm):00015         *  19r8    2003/09/22  Boisy G. Pitre
                      (    krn_beta5.asm):00016         * Back-ported to OS-9 Level Two.
                      (    krn_beta5.asm):00017         *
                      (    krn_beta5.asm):00018         *  19r8    2004/05/22  Boisy G. Pitre
                      (    krn_beta5.asm):00019         * Renamed to 'krn'
                      (    krn_beta5.asm):00020         *
                      (    krn_beta5.asm):00021         *  19r9    2004/07/12  Boisy G. Pitre
                      (    krn_beta5.asm):00022         * F$SRqMem now properly scans the DAT images of the system to update
                      (    krn_beta5.asm):00023         * the D.SysMem map.
                      (    krn_beta5.asm):00024         *
                      (    krn_beta5.asm):00025         *  19r10   2019/11/15-2019/12/26  L. Curtis Boyle
                      (    krn_beta5.asm):00026         * Optimized register stack copies on 6809 in 4 spots (Loop5, RtiLoop, Looper
                      (    krn_beta5.asm):00027         *   & Loop4)
                      (    krn_beta5.asm):00028         *   Saves over 70 cycles per system call that switches between user &
                      (    krn_beta5.asm):00029         *   system states
                      (    krn_beta5.asm):00030         * Changed F$Move to use D.IRQTmp to eliminate some TFR's, and changed it so
                      (    krn_beta5.asm):00031         *   pshs cc/puls cc replace with orc #IntMask/andcc ^#IntMasks (faster)
                      (    krn_beta5.asm):00032         * Also changed it to pulu routine again (for >64 byte copies, 14 cycles
                      (    krn_beta5.asm):00033         *   faster per 8 bytes copied)
                      (    krn_beta5.asm):00034         * Shrunk 6309 code by 1 byte in F$VModul
                      (    krn_beta5.asm):00035         * 6309-Removed 2 BRN's from F$LDAXY, as they were not 2.01 source, and
                      (    krn_beta5.asm):00036         *   don't appear to useful since F$LDDDXY does the same type of MMU mapping
                      (    krn_beta5.asm):00037         *   without delays.
                      (    krn_beta5.asm):00038         * Moved F$CpyMem from KrnP2, which allows shortcut bsr calls to F$Move,etc.
                      (    krn_beta5.asm):00039         *   Much, much faster. (6809)
                      (    krn_beta5.asm):00040         
                      (    krn_beta5.asm):00041                   nam   krn
                      (    krn_beta5.asm):00042                   ttl   NitrOS-9 Level 2 Kernel
                      (    krn_beta5.asm):00043         
                      (    krn_beta5.asm):00044                 IFP1
                      (    krn_beta5.asm):00045                   use   /dd/defs/deffile
     0002             ( /dd/defs/deffile):00001         Level    set     2
     0000             ( /dd/defs/deffile):00002         CoGrf    set     0
     0000             ( /dd/defs/deffile):00003         MATCHBOX set     0
                      ( /dd/defs/deffile):00004         *H6309    set     0
     0000             ( /dd/defs/deffile):00005         H6309    set     0
                      ( /dd/defs/deffile):00006                  use   /dd/defs/os9.d
                      (   /dd/defs/os9.d):00001         ********************************************************************
                      (   /dd/defs/os9.d):00002         * os9.d - NitrOS-9 System Definitions
                      (   /dd/defs/os9.d):00003         *
                      (   /dd/defs/os9.d):00004         * $Id$
                      (   /dd/defs/os9.d):00005         *
                      (   /dd/defs/os9.d):00006         * Edt/Rev  YYYY/MM/DD  Modified by
                      (   /dd/defs/os9.d):00007         * Comment
                      (   /dd/defs/os9.d):00008         * ------------------------------------------------------------------
                      (   /dd/defs/os9.d):00009         *          1985/08/29  KMZ
                      (   /dd/defs/os9.d):00010         * Fixed DT.SBF/NFM values to 3/4
                      (   /dd/defs/os9.d):00011         *
                      (   /dd/defs/os9.d):00012         *          1985/09/01  KMZ
                      (   /dd/defs/os9.d):00013         * Added SS.FDInf, SS.Attr to accept 68K request thru NET.
                      (   /dd/defs/os9.d):00014         *
                      (   /dd/defs/os9.d):00015         *          1985/09/03  KMZ/Robert F. Doggett
                      (   /dd/defs/os9.d):00016         * Eliminated E$BPrcID, made Error #238 become E$DNE for
                      (   /dd/defs/os9.d):00017         * 68000 compatability.
                      (   /dd/defs/os9.d):00018         *
                      (   /dd/defs/os9.d):00019         *          1986/04/15  Mark G. Hawkins
                      (   /dd/defs/os9.d):00020         * F$AlHRAM System call added for COCO.
                      (   /dd/defs/os9.d):00021         *
                      (   /dd/defs/os9.d):00022         *          1986/09/08  Mark G. Hawkins
                      (   /dd/defs/os9.d):00023         * F$Alarm for COCO Clock Module.
                      (   /dd/defs/os9.d):00024         *
                      (   /dd/defs/os9.d):00025         *          1986/09/17  Mark G. Hawkins
                      (   /dd/defs/os9.d):00026         * SS.Tone For COCO.
                      (   /dd/defs/os9.d):00027         *
                      (   /dd/defs/os9.d):00028         *          1986/09/23  Mark G. Hawkins
                      (   /dd/defs/os9.d):00029         * Added F$NMLink and F$NMLoad for COCO.
                      (   /dd/defs/os9.d):00030         *
                      (   /dd/defs/os9.d):00031         *          1986/09/30  Mark G. Hawkins
                      (   /dd/defs/os9.d):00032         * Added Reserved User $70 to $7f in sytem calls.
                      (   /dd/defs/os9.d):00033         *
                      (   /dd/defs/os9.d):00034         *          1986/09/30  Mark G. Hawkins
                      (   /dd/defs/os9.d):00035         * Created Color Computer 3 Version of OS9Defs.
                      (   /dd/defs/os9.d):00036         *
                      (   /dd/defs/os9.d):00037         *          1998/10/03  Boisy G. Pitre
                      (   /dd/defs/os9.d):00038         * Consoldated Level 1/Level 2 os9defs.
                      (   /dd/defs/os9.d):00039         *
                      (   /dd/defs/os9.d):00040         *          2002/04/04  Boisy G. Pitre
                      (   /dd/defs/os9.d):00041         * Consoldated Level 2/Level 2 V3 os9defs.
                      (   /dd/defs/os9.d):00042         *
                      (   /dd/defs/os9.d):00043         *          2002/04/30  Boisy G. Pitre
                      (   /dd/defs/os9.d):00044         * Added NitrOS-9 definitions.
                      (   /dd/defs/os9.d):00045         *
                      (   /dd/defs/os9.d):00046         *          2003/05/30  Boisy G. Pitre
                      (   /dd/defs/os9.d):00047         * Added WD1002 sys vars to Level One section.
                      (   /dd/defs/os9.d):00048         *
                      (   /dd/defs/os9.d):00049         *          2003/06/02  Boisy G. Pitre
                      (   /dd/defs/os9.d):00050         * Fixed incorrectly ordered D.X*** system globals for OS-9 Level One and
                      (   /dd/defs/os9.d):00051         * changed the sizes from 2 to 3 bytes.
                      (   /dd/defs/os9.d):00052         * DT.NFM is now the same for both Level One and Level Two.
                      (   /dd/defs/os9.d):00053         * Added DT.CDFM type for future CD-ROM file manager
                      (   /dd/defs/os9.d):00054         *
                      (   /dd/defs/os9.d):00055         *          2003/11/05  Robert Gault
                      (   /dd/defs/os9.d):00056         * Fixed MouseInf. Made it rmb 2 as it should be. Also changes to init and cc3io.
                      (   /dd/defs/os9.d):00057         *
                      (   /dd/defs/os9.d):00058         *              2005/11/02  P.Harvey-Smith
                      (   /dd/defs/os9.d):00059         * Added definitions for boot areas on Dragon computers.
                      (   /dd/defs/os9.d):00060         *
                      (   /dd/defs/os9.d):00061         *              2006/03/03  Boisy G. Pitre
                      (   /dd/defs/os9.d):00062         * Added F$Debug and D.DbgMem areas, common to all levels of NitrOS-9
                      (   /dd/defs/os9.d):00063         *
                      (   /dd/defs/os9.d):00064         * Added I$ModDsc call (modify device descriptor in system memory) BN/LCB
                      (   /dd/defs/os9.d):00065         *          2019/10/30  Bill Nobel, from discussions with L. Curtis Boyle
                      (   /dd/defs/os9.d):00066                        NAM       os9.d
                      (   /dd/defs/os9.d):00067                        TTL       NitrOS-9 Level 2 System Symbol Definitions
                      (   /dd/defs/os9.d):00068         
                      (   /dd/defs/os9.d):00069         * Common definitions
     0001             (   /dd/defs/os9.d):00070         true           EQU       1                   useful name
     0000             (   /dd/defs/os9.d):00071         false          EQU       0                   useful name
                      (   /dd/defs/os9.d):00072         
                      (   /dd/defs/os9.d):00073                        PAG       
                      (   /dd/defs/os9.d):00074         *****************************************
                      (   /dd/defs/os9.d):00075         * System Service Request Code Definitions
                      (   /dd/defs/os9.d):00076         *
                      (   /dd/defs/os9.d):00077                        ORG       0
0000                  (   /dd/defs/os9.d):00078         F$Link         RMB       1                   Link to Module
0001                  (   /dd/defs/os9.d):00079         F$Load         RMB       1                   Load Module from File
0002                  (   /dd/defs/os9.d):00080         F$UnLink       RMB       1                   Unlink Module
0003                  (   /dd/defs/os9.d):00081         F$Fork         RMB       1                   Start New Process
0004                  (   /dd/defs/os9.d):00082         F$Wait         RMB       1                   Wait for Child Process to Die
0005                  (   /dd/defs/os9.d):00083         F$Chain        RMB       1                   Chain Process to New Module
0006                  (   /dd/defs/os9.d):00084         F$Exit         RMB       1                   Terminate Process
0007                  (   /dd/defs/os9.d):00085         F$Mem          RMB       1                   Set Memory Size
0008                  (   /dd/defs/os9.d):00086         F$Send         RMB       1                   Send Signal to Process
0009                  (   /dd/defs/os9.d):00087         F$Icpt         RMB       1                   Set Signal Intercept
000A                  (   /dd/defs/os9.d):00088         F$Sleep        RMB       1                   Suspend Process
000B                  (   /dd/defs/os9.d):00089         F$SSpd         RMB       1                   Suspend Process
000C                  (   /dd/defs/os9.d):00090         F$ID           RMB       1                   Return Process ID
000D                  (   /dd/defs/os9.d):00091         F$SPrior       RMB       1                   Set Process Priority
000E                  (   /dd/defs/os9.d):00092         F$SSWI         RMB       1                   Set Software Interrupt
000F                  (   /dd/defs/os9.d):00093         F$PErr         RMB       1                   Print Error
0010                  (   /dd/defs/os9.d):00094         F$PrsNam       RMB       1                   Parse Pathlist Name
0011                  (   /dd/defs/os9.d):00095         F$CmpNam       RMB       1                   Compare Two Names
0012                  (   /dd/defs/os9.d):00096         F$SchBit       RMB       1                   Search Bit Map
0013                  (   /dd/defs/os9.d):00097         F$AllBit       RMB       1                   Allocate in Bit Map
0014                  (   /dd/defs/os9.d):00098         F$DelBit       RMB       1                   Deallocate in Bit Map
0015                  (   /dd/defs/os9.d):00099         F$Time         RMB       1                   Get Current Time
0016                  (   /dd/defs/os9.d):00100         F$STime        RMB       1                   Set Current Time
0017                  (   /dd/defs/os9.d):00101         F$CRC          RMB       1                   Generate CRC ($17)
                      (   /dd/defs/os9.d):00102         
                      (   /dd/defs/os9.d):00103         
                      (   /dd/defs/os9.d):00104         * NitrOS-9 Level 2 system calls
0018                  (   /dd/defs/os9.d):00105         F$GPrDsc       RMB       1                   Get Process Descriptor copy ($18)
0019                  (   /dd/defs/os9.d):00106         F$GBlkMp       RMB       1                   Get System Block Map copy ($19)
001A                  (   /dd/defs/os9.d):00107         F$GModDr       RMB       1                   Get Module Directory copy ($1A)
001B                  (   /dd/defs/os9.d):00108         F$CpyMem       RMB       1                   Copy External Memory ($1B)
001C                  (   /dd/defs/os9.d):00109         F$SUser        RMB       1                   Set User ID number ($1C)
001D                  (   /dd/defs/os9.d):00110         F$UnLoad       RMB       1                   Unlink Module by name ($1D)
001E                  (   /dd/defs/os9.d):00111         F$Alarm        RMB       1                   Color Computer 3 Alarm Call ($1E)
001F                  (   /dd/defs/os9.d):00112                        RMB       2                   Reserved - For overlap of other systems ($1F)
0021                  (   /dd/defs/os9.d):00113         F$NMLink       RMB       1                   Color Computer 3 Non-Mapping Link ($21)
0022                  (   /dd/defs/os9.d):00114         F$NMLoad       RMB       1                   Color Computer 3 Non-Mapping Load ($22)
                      (   /dd/defs/os9.d):00115         
                      (   /dd/defs/os9.d):00116         
                      (   /dd/defs/os9.d):00117         * NitrOS-9 Level 1 system call padding
                      (   /dd/defs/os9.d):00118         
                      (   /dd/defs/os9.d):00119         
0023                  (   /dd/defs/os9.d):00120         F$Debug        RMB       1                   Drop the system into the debugger ($23)
                      (   /dd/defs/os9.d):00121         
                      (   /dd/defs/os9.d):00122         
                      (   /dd/defs/os9.d):00123                        ORG       $25
0025                  (   /dd/defs/os9.d):00124         F$TPS          RMB       1                   Return System's Ticks Per Second
0026                  (   /dd/defs/os9.d):00125         F$TimAlm       RMB       1                   CoCo individual process alarm call
                      (   /dd/defs/os9.d):00126         
                      (   /dd/defs/os9.d):00127         
                      (   /dd/defs/os9.d):00128                        ORG       $27                 Beginning of System Reserved Calls
                      (   /dd/defs/os9.d):00129         * NitrOS-9 common system calls
0027                  (   /dd/defs/os9.d):00130         F$VIRQ         RMB       1                   Install/Delete Virtual IRQ
0028                  (   /dd/defs/os9.d):00131         F$SRqMem       RMB       1                   System Memory Request
0029                  (   /dd/defs/os9.d):00132         F$SRtMem       RMB       1                   System Memory Return
002A                  (   /dd/defs/os9.d):00133         F$IRQ          RMB       1                   Enter IRQ Polling Table
002B                  (   /dd/defs/os9.d):00134         F$IOQu         RMB       1                   Enter I/O Queue
002C                  (   /dd/defs/os9.d):00135         F$AProc        RMB       1                   Enter Active Process Queue
002D                  (   /dd/defs/os9.d):00136         F$NProc        RMB       1                   Start Next Process
002E                  (   /dd/defs/os9.d):00137         F$VModul       RMB       1                   Validate Module
002F                  (   /dd/defs/os9.d):00138         F$Find64       RMB       1                   Find Process/Path Descriptor
0030                  (   /dd/defs/os9.d):00139         F$All64        RMB       1                   Allocate Process/Path Descriptor
0031                  (   /dd/defs/os9.d):00140         F$Ret64        RMB       1                   Return Process/Path Descriptor
0032                  (   /dd/defs/os9.d):00141         F$SSvc         RMB       1                   Service Request Table Initialization
0033                  (   /dd/defs/os9.d):00142         F$IODel        RMB       1                   Delete I/O Module
                      (   /dd/defs/os9.d):00143         
                      (   /dd/defs/os9.d):00144         
0034                  (   /dd/defs/os9.d):00145         F$SLink        RMB       1                   System Link
0035                  (   /dd/defs/os9.d):00146         F$Boot         RMB       1                   Bootstrap System
0036                  (   /dd/defs/os9.d):00147         F$BtMem        RMB       1                   Bootstrap Memory Request
0037                  (   /dd/defs/os9.d):00148         F$GProcP       RMB       1                   Get Process ptr
0038                  (   /dd/defs/os9.d):00149         F$Move         RMB       1                   Move Data (low bound first)
0039                  (   /dd/defs/os9.d):00150         F$AllRAM       RMB       1                   Allocate RAM blocks
003A                  (   /dd/defs/os9.d):00151         F$AllImg       RMB       1                   Allocate Image RAM blocks
003B                  (   /dd/defs/os9.d):00152         F$DelImg       RMB       1                   Deallocate Image RAM blocks
003C                  (   /dd/defs/os9.d):00153         F$SetImg       RMB       1                   Set Process DAT Image
003D                  (   /dd/defs/os9.d):00154         F$FreeLB       RMB       1                   Get Free Low Block
003E                  (   /dd/defs/os9.d):00155         F$FreeHB       RMB       1                   Get Free High Block
003F                  (   /dd/defs/os9.d):00156         F$AllTsk       RMB       1                   Allocate Process Task number
0040                  (   /dd/defs/os9.d):00157         F$DelTsk       RMB       1                   Deallocate Process Task number
0041                  (   /dd/defs/os9.d):00158         F$SetTsk       RMB       1                   Set Process Task DAT registers
0042                  (   /dd/defs/os9.d):00159         F$ResTsk       RMB       1                   Reserve Task number
0043                  (   /dd/defs/os9.d):00160         F$RelTsk       RMB       1                   Release Task number
0044                  (   /dd/defs/os9.d):00161         F$DATLog       RMB       1                   Convert DAT Block/Offset to Logical
0045                  (   /dd/defs/os9.d):00162         F$DATTmp       RMB       1                   Make temporary DAT image (Obsolete)
0046                  (   /dd/defs/os9.d):00163         F$LDAXY        RMB       1                   Load A [X,[Y]]
0047                  (   /dd/defs/os9.d):00164         F$LDAXYP       RMB       1                   Load A [X+,[Y]]
0048                  (   /dd/defs/os9.d):00165         F$LDDDXY       RMB       1                   Load D [D+X,[Y]]
0049                  (   /dd/defs/os9.d):00166         F$LDABX        RMB       1                   Load A from 0,X in task B
004A                  (   /dd/defs/os9.d):00167         F$STABX        RMB       1                   Store A at 0,X in task B
004B                  (   /dd/defs/os9.d):00168         F$AllPrc       RMB       1                   Allocate Process Descriptor
004C                  (   /dd/defs/os9.d):00169         F$DelPrc       RMB       1                   Deallocate Process Descriptor
004D                  (   /dd/defs/os9.d):00170         F$ELink        RMB       1                   Link using Module Directory Entry
004E                  (   /dd/defs/os9.d):00171         F$FModul       RMB       1                   Find Module Directory Entry
004F                  (   /dd/defs/os9.d):00172         F$MapBlk       RMB       1                   Map Specific Block
0050                  (   /dd/defs/os9.d):00173         F$ClrBlk       RMB       1                   Clear Specific Block
0051                  (   /dd/defs/os9.d):00174         F$DelRAM       RMB       1                   Deallocate RAM blocks
0052                  (   /dd/defs/os9.d):00175         F$GCMDir       RMB       1                   Pack module directory
0053                  (   /dd/defs/os9.d):00176         F$AlHRAM       RMB       1                   Allocate HIGH RAM Blocks
                      (   /dd/defs/os9.d):00177         
                      (   /dd/defs/os9.d):00178         * Alan DeKok additions
0054                  (   /dd/defs/os9.d):00179         F$ReBoot       RMB       1                   Reboot machine (reload OS9Boot) or drop to RSDOS
0055                  (   /dd/defs/os9.d):00180         F$CRCMod       RMB       1                   CRC mode, toggle or report current status
0056                  (   /dd/defs/os9.d):00181         F$XTime        RMB       1                   Get Extended time packet from RTC (fractions of second)
0057                  (   /dd/defs/os9.d):00182         F$VBlock       RMB       1                   Verify modules in a block of memory, add to module directory
                      (   /dd/defs/os9.d):00183         
                      (   /dd/defs/os9.d):00184         
                      (   /dd/defs/os9.d):00185         *
                      (   /dd/defs/os9.d):00186         * Numbers $70 through $7F are reserved for user definitions
                      (   /dd/defs/os9.d):00187         *
                      (   /dd/defs/os9.d):00188                        ORG       $70
                      (   /dd/defs/os9.d):00189         
                      (   /dd/defs/os9.d):00190         
                      (   /dd/defs/os9.d):00191         
                      (   /dd/defs/os9.d):00192         
0070                  (   /dd/defs/os9.d):00193         F$RegDmp       RMB       1                   Ron Lammardo's debugging register dump
0071                  (   /dd/defs/os9.d):00194         F$NVRAM        RMB       1                   Non Volatile RAM (RTC battery backed static) read/write
                      (   /dd/defs/os9.d):00195         
0072                  (   /dd/defs/os9.d):00196                        RMB       $80-.               Reserved for user definitions
                      (   /dd/defs/os9.d):00197         
                      (   /dd/defs/os9.d):00198                        PAG       
                      (   /dd/defs/os9.d):00199         **************************************
                      (   /dd/defs/os9.d):00200         * I/O Service Request Code Definitions
                      (   /dd/defs/os9.d):00201         *
                      (   /dd/defs/os9.d):00202                        ORG       $80
0080                  (   /dd/defs/os9.d):00203         I$Attach       RMB       1                   Attach I/O Device
0081                  (   /dd/defs/os9.d):00204         I$Detach       RMB       1                   Detach I/O Device
0082                  (   /dd/defs/os9.d):00205         I$Dup          RMB       1                   Duplicate Path
0083                  (   /dd/defs/os9.d):00206         I$Create       RMB       1                   Create New File
0084                  (   /dd/defs/os9.d):00207         I$Open         RMB       1                   Open Existing File
0085                  (   /dd/defs/os9.d):00208         I$MakDir       RMB       1                   Make Directory File
0086                  (   /dd/defs/os9.d):00209         I$ChgDir       RMB       1                   Change Default Directory
0087                  (   /dd/defs/os9.d):00210         I$Delete       RMB       1                   Delete File
0088                  (   /dd/defs/os9.d):00211         I$Seek         RMB       1                   Change Current Position
0089                  (   /dd/defs/os9.d):00212         I$Read         RMB       1                   Read Data
008A                  (   /dd/defs/os9.d):00213         I$Write        RMB       1                   Write Data
008B                  (   /dd/defs/os9.d):00214         I$ReadLn       RMB       1                   Read Line of ASCII Data
008C                  (   /dd/defs/os9.d):00215         I$WritLn       RMB       1                   Write Line of ASCII Data
008D                  (   /dd/defs/os9.d):00216         I$GetStt       RMB       1                   Get Path Status
008E                  (   /dd/defs/os9.d):00217         I$SetStt       RMB       1                   Set Path Status
008F                  (   /dd/defs/os9.d):00218         I$Close        RMB       1                   Close Path
0090                  (   /dd/defs/os9.d):00219         I$DeletX       RMB       1                   Delete from current exec dir
0091                  (   /dd/defs/os9.d):00220         I$ModDsc       RMB       1                   Modify SCF/RBF Descriptor in Memory
                      (   /dd/defs/os9.d):00221         
                      (   /dd/defs/os9.d):00222         *******************
                      (   /dd/defs/os9.d):00223         * File Access Modes
                      (   /dd/defs/os9.d):00224         *
     0001             (   /dd/defs/os9.d):00225         READ.          EQU       %00000001
     0002             (   /dd/defs/os9.d):00226         WRITE.         EQU       %00000010
     0003             (   /dd/defs/os9.d):00227         UPDAT.         EQU       READ.+WRITE.
     0004             (   /dd/defs/os9.d):00228         EXEC.          EQU       %00000100
     0008             (   /dd/defs/os9.d):00229         PREAD.         EQU       %00001000
     0010             (   /dd/defs/os9.d):00230         PWRIT.         EQU       %00010000
     0020             (   /dd/defs/os9.d):00231         PEXEC.         EQU       %00100000
     0040             (   /dd/defs/os9.d):00232         SHARE.         EQU       %01000000
     0080             (   /dd/defs/os9.d):00233         DIR.           EQU       %10000000
     0020             (   /dd/defs/os9.d):00234         ISIZ.          EQU       %00100000
                      (   /dd/defs/os9.d):00235         
                      (   /dd/defs/os9.d):00236         **************
                      (   /dd/defs/os9.d):00237         * Signal Codes
                      (   /dd/defs/os9.d):00238         *
                      (   /dd/defs/os9.d):00239                        ORG       0
0000                  (   /dd/defs/os9.d):00240         S$Kill         RMB       1                   Non-Interceptable Abort
0001                  (   /dd/defs/os9.d):00241         S$Wake         RMB       1                   Wake-up Sleeping Process
0002                  (   /dd/defs/os9.d):00242         S$Abort        RMB       1                   Keyboard Abort
0003                  (   /dd/defs/os9.d):00243         S$Intrpt       RMB       1                   Keyboard Interrupt
0004                  (   /dd/defs/os9.d):00244         S$Window       RMB       1                   Window Change
     0004             (   /dd/defs/os9.d):00245         S$HUP          EQU       S$Window            Hang Up
0005                  (   /dd/defs/os9.d):00246         S$Alarm        RMB       1                   CoCo individual process' alarm signal
                      (   /dd/defs/os9.d):00247         
                      (   /dd/defs/os9.d):00248                        PAG       
                      (   /dd/defs/os9.d):00249         **********************************
                      (   /dd/defs/os9.d):00250         * Status Codes for GetStat/GetStat
                      (   /dd/defs/os9.d):00251         *
                      (   /dd/defs/os9.d):00252                        ORG       0
0000                  (   /dd/defs/os9.d):00253         SS.Opt         RMB       1                   Read/Write PD Options
0001                  (   /dd/defs/os9.d):00254         SS.Ready       RMB       1                   Check for Device Ready
0002                  (   /dd/defs/os9.d):00255         SS.Size        RMB       1                   Read/Write File Size
0003                  (   /dd/defs/os9.d):00256         SS.Reset       RMB       1                   Device Restore
0004                  (   /dd/defs/os9.d):00257         SS.WTrk        RMB       1                   Device Write Track
0005                  (   /dd/defs/os9.d):00258         SS.Pos         RMB       1                   Get File Current Position
0006                  (   /dd/defs/os9.d):00259         SS.EOF         RMB       1                   Test for End of File
0007                  (   /dd/defs/os9.d):00260         SS.Link        RMB       1                   Link to Status routines
0008                  (   /dd/defs/os9.d):00261         SS.ULink       RMB       1                   Unlink Status routines
0009                  (   /dd/defs/os9.d):00262         SS.Feed        RMB       1                   Issue form feed
000A                  (   /dd/defs/os9.d):00263         SS.Frz         RMB       1                   Freeze DD. information
000B                  (   /dd/defs/os9.d):00264         SS.SPT         RMB       1                   Set DD.TKS to given value
000C                  (   /dd/defs/os9.d):00265         SS.SQD         RMB       1                   Sequence down hard disk
000D                  (   /dd/defs/os9.d):00266         SS.DCmd        RMB       1                   Send direct command to disk
000E                  (   /dd/defs/os9.d):00267         SS.DevNm       RMB       1                   Return Device name (32-bytes at [X])
000F                  (   /dd/defs/os9.d):00268         SS.FD          RMB       1                   Return File Descriptor (Y-bytes at [X])
0010                  (   /dd/defs/os9.d):00269         SS.Ticks       RMB       1                   Set Lockout honor duration
0011                  (   /dd/defs/os9.d):00270         SS.Lock        RMB       1                   Lock/Release record
0012                  (   /dd/defs/os9.d):00271         SS.DStat       RMB       1                   Return Display Status (CoCo)
0013                  (   /dd/defs/os9.d):00272         SS.Joy         RMB       1                   Return Joystick Value (CoCo)
0014                  (   /dd/defs/os9.d):00273         SS.BlkRd       RMB       1                   Block Read
0015                  (   /dd/defs/os9.d):00274         SS.BlkWr       RMB       1                   Block Write
0016                  (   /dd/defs/os9.d):00275         SS.Reten       RMB       1                   Retension cycle
0017                  (   /dd/defs/os9.d):00276         SS.WFM         RMB       1                   Write File Mark
0018                  (   /dd/defs/os9.d):00277         SS.RFM         RMB       1                   Read past File Mark
0019                  (   /dd/defs/os9.d):00278         SS.ELog        RMB       1                   Read Error Log
001A                  (   /dd/defs/os9.d):00279         SS.SSig        RMB       1                   Send signal on data ready
001B                  (   /dd/defs/os9.d):00280         SS.Relea       RMB       1                   Release device
001C                  (   /dd/defs/os9.d):00281         SS.AlfaS       RMB       1                   Return Alfa Display Status (CoCo, SCF/GetStat)
     001C             (   /dd/defs/os9.d):00282         SS.Attr        EQU       SS.AlfaS            To serve 68K/RBF/SetStat only, thru NET
001D                  (   /dd/defs/os9.d):00283         SS.Break       RMB       1                   Send break signal out acia
001E                  (   /dd/defs/os9.d):00284         SS.RsBit       RMB       1                   Reserve bitmap sector (do not allocate in) LSB(X)=sct#
001F                  (   /dd/defs/os9.d):00285                        RMB       1                   Reserved
     0020             (   /dd/defs/os9.d):00286         SS.FDInf       EQU       $20                 To serve 68K/RBF/GetStat only, thru NET
0020                  (   /dd/defs/os9.d):00287         SS.DirEnt      RMB       1                   Reserve bitmap sector (do not allocate in) LSB(X)=sct#
0021                  (   /dd/defs/os9.d):00288                        RMB       3                   Reserve $20-$23 for Japanese version (Hoshi)
0024                  (   /dd/defs/os9.d):00289         SS.SetMF       RMB       1                   Reserve $24 for Gimix G68 (Flex compatability?)
0025                  (   /dd/defs/os9.d):00290         SS.Cursr       RMB       1                   Cursor information for COCO
0026                  (   /dd/defs/os9.d):00291         SS.ScSiz       RMB       1                   Return screen size for COCO
0027                  (   /dd/defs/os9.d):00292         SS.KySns       RMB       1                   Getstat/SetStat for COCO keyboard
0028                  (   /dd/defs/os9.d):00293         SS.ComSt       RMB       1                   Getstat/SetStat for Baud/Parity
0029                  (   /dd/defs/os9.d):00294         SS.Open        RMB       1                   SetStat to tell driver a path was opened
002A                  (   /dd/defs/os9.d):00295         SS.Close       RMB       1                   SetStat to tell driver a path was closed
002B                  (   /dd/defs/os9.d):00296         SS.HngUp       RMB       1                   SetStat to tell driver to hangup phone
002C                  (   /dd/defs/os9.d):00297         SS.FSig        RMB       1                   New signal for temp locked files
     0026             (   /dd/defs/os9.d):00298         SS.DSize       EQU       SS.ScSiz            Return disk size (RBF GetStat)
     0012             (   /dd/defs/os9.d):00299         SS.VarSect     EQU       SS.DStat            Variable Sector Size (RBF GetStat)
                      (   /dd/defs/os9.d):00300         
                      (   /dd/defs/os9.d):00301         * System Specific and User defined codes above $80
                      (   /dd/defs/os9.d):00302                        ORG       $80
0080                  (   /dd/defs/os9.d):00303         SS.AAGBf       RMB       1                   SetStat to Allocate Additional Graphic Buffer
0081                  (   /dd/defs/os9.d):00304         SS.SLGBf       RMB       1                   SetStat to Select a different Graphic Buffer
0082                  (   /dd/defs/os9.d):00305         SS.Mount       RMB       1                   Network 4 Mount Setstat
0083                  (   /dd/defs/os9.d):00306         SS.RdNet       RMB       1                   Read Raw Sector from Network 4 Omnidrive
0084                  (   /dd/defs/os9.d):00307         SS.MpGPB       RMB       1                   SetStat to request a Get/Put Buffer be mapped in workspace
0085                  (   /dd/defs/os9.d):00308         SS.Slots       RMB       1                   Network 4 slots? getstat
                      (   /dd/defs/os9.d):00309         
                      (   /dd/defs/os9.d):00310         *               IFGT      Level-1
                      (   /dd/defs/os9.d):00311         * Level 2 Windowing
0086                  (   /dd/defs/os9.d):00312         SS.WnSet       RMB       1                   Set up High Level Windowing Information
0087                  (   /dd/defs/os9.d):00313         SS.MnSel       RMB       1                   Request High level Menu Handler take determine next event
0088                  (   /dd/defs/os9.d):00314         SS.SBar        RMB       1                   SetStat to set position block on Window scroll bars
0089                  (   /dd/defs/os9.d):00315         SS.Mouse       RMB       1                   Return Mouse information packet (COCO)
008A                  (   /dd/defs/os9.d):00316         SS.MsSig       RMB       1                   SetStat to tell driver to send signal on mouse event
008B                  (   /dd/defs/os9.d):00317         SS.AScrn       RMB       1                   Allocate a screen for application poking
008C                  (   /dd/defs/os9.d):00318         SS.DScrn       RMB       1                   Display a screen allocated by SS.AScrn
008D                  (   /dd/defs/os9.d):00319         SS.FScrn       RMB       1                   Free a screen allocated by SS.AScrn
008E                  (   /dd/defs/os9.d):00320         SS.PScrn       RMB       1                   Polymorph Screen into different screen type
008F                  (   /dd/defs/os9.d):00321         SS.ScInf       RMB       1                   Get Current screen info for direct writes
0090                  (   /dd/defs/os9.d):00322                        RMB       1                   Reserved
0091                  (   /dd/defs/os9.d):00323         SS.Palet       RMB       1                   Return palette information
0092                  (   /dd/defs/os9.d):00324         SS.Montr       RMB       1                   Get and Set Monitor Type
0093                  (   /dd/defs/os9.d):00325         SS.ScTyp       RMB       1                   Get screen type information
0094                  (   /dd/defs/os9.d):00326         SS.GIP         RMB       1                   Global Input Parameters (SetStat)
0095                  (   /dd/defs/os9.d):00327         SS.UMBar       RMB       1                   update menu bar (SetStat)
0096                  (   /dd/defs/os9.d):00328         SS.FBRgs       RMB       1                   return color registers (GetStat)
0097                  (   /dd/defs/os9.d):00329         SS.DfPal       RMB       1                   set/return default palette registers (Getstat/Setstat)
0098                  (   /dd/defs/os9.d):00330         SS.Tone        RMB       1                   Generate a tone using 6 bit sound
0099                  (   /dd/defs/os9.d):00331         SS.GIP2        RMB       1                   Global Input Params #2 (L2V3)
009A                  (   /dd/defs/os9.d):00332         SS.AnPal       RMB       1                   Animate palettes (L2V3)
009B                  (   /dd/defs/os9.d):00333         SS.FndBf       RMB       1                   Find named buffer (L2V3)
                      (   /dd/defs/os9.d):00334         
                      (   /dd/defs/os9.d):00335         * sc6551 defined
     0099             (   /dd/defs/os9.d):00336         SS.CDSta       EQU       SS.GIP2
     009A             (   /dd/defs/os9.d):00337         SS.CDSig       EQU       SS.AnPal
     009B             (   /dd/defs/os9.d):00338         SS.CDRel       EQU       SS.FndBf
                      (   /dd/defs/os9.d):00339         * These are wide open in Level 1
                      (   /dd/defs/os9.d):00340         
                      (   /dd/defs/os9.d):00341         * sc6551 defined
                      (   /dd/defs/os9.d):00342         
                      (   /dd/defs/os9.d):00343                        ORG       $A0
                      (   /dd/defs/os9.d):00344         *
                      (   /dd/defs/os9.d):00345         * New Default SCF input buffer Set status call
00A0                  (   /dd/defs/os9.d):00346         SS.Fill        RMB       1                   Pre-load SCF device input buffer
00A1                  (   /dd/defs/os9.d):00347         SS.Hist        RMB       1                   Enable command-line history easily
                      (   /dd/defs/os9.d):00348         
                      (   /dd/defs/os9.d):00349         
                      (   /dd/defs/os9.d):00350                        ORG       $B0
                      (   /dd/defs/os9.d):00351         *
                      (   /dd/defs/os9.d):00352         * New WDDisk get/set status calls
00B0                  (   /dd/defs/os9.d):00353         SS.ECC         RMB       1                   ECC corrected data error enable/disable (GetStat/SetStat)
                      (   /dd/defs/os9.d):00354         
                      (   /dd/defs/os9.d):00355         *
                      (   /dd/defs/os9.d):00356         
                      (   /dd/defs/os9.d):00357         * VRN get/set status calls.  Named by Alan DeKok.
     0080             (   /dd/defs/os9.d):00358         SS.VCtr        EQU       $80                 Return FS2 total VIRQ counter
     0081             (   /dd/defs/os9.d):00359         SS.VSig        EQU       $81                 Return FS2 number of signals sent
                      (   /dd/defs/os9.d):00360         
     0081             (   /dd/defs/os9.d):00361         SS.FClr        EQU       $81                 Set/clear FS2 VIRQ
     00C7             (   /dd/defs/os9.d):00362         SS.FSet        EQU       $C7                 Set FS2+ VIRQ
     00C8             (   /dd/defs/os9.d):00363         SS.KSet        EQU       $C8                 Set KQ3 VIRQ
     00C9             (   /dd/defs/os9.d):00364         SS.KClr        EQU       $C9                 Clr KQ3 VIRQ
     00CA             (   /dd/defs/os9.d):00365         SS.ARAM        EQU       $CA                 Allocate RAM blocks
     00CB             (   /dd/defs/os9.d):00366         SS.DRAM        EQU       $CB                 De-allocate RAM blocks
                      (   /dd/defs/os9.d):00367         
                      (   /dd/defs/os9.d):00368         * SDisk 3 Definition Equates
     0080             (   /dd/defs/os9.d):00369         SS.DRead       EQU       SS.AAGBf            SDisk3 Direct Sector Read ($80)
     0080             (   /dd/defs/os9.d):00370         SS.DWrit       EQU       SS.DRead            SDisk3 Direct sector Write ($80)
     0081             (   /dd/defs/os9.d):00371         SS.UnFrz       EQU       SS.SLGBf            SDisk3 UNFreeze DD info ($81)
     0082             (   /dd/defs/os9.d):00372         SS.MOFF        EQU       SS.Mount            SDisk3 fast motor off call ($82)
     0083             (   /dd/defs/os9.d):00373         SS.MoTim       EQU       SS.RdNet            SDisk3 Set motor shut off time ($83)
     0084             (   /dd/defs/os9.d):00374         SS.SDRD        EQU       SS.MpGPB            SDisk3 System direct read ($84)
     0084             (   /dd/defs/os9.d):00375         SS.SDWRT       EQU       SS.SDRD             SDisk3 System direct writes ($84)
     0085             (   /dd/defs/os9.d):00376         SS.Sleep       EQU       SS.Slots            SDisk3 (DMC ONLY) Enable/disable F$Sleep calls in read/write 1773 I/O ($85)
     0086             (   /dd/defs/os9.d):00377         SS.DrvCh       EQU       SS.WnSet            SDisk3 (DMC ONLY) Set drive number to cache, or return ($86)
                      (   /dd/defs/os9.d):00378         
                      (   /dd/defs/os9.d):00379         
                      (   /dd/defs/os9.d):00380                        TTL       Direct Page Definitions
                      (   /dd/defs/os9.d):00381                        PAG       
                      (   /dd/defs/os9.d):00382         
                      (   /dd/defs/os9.d):00383         **********************************
                      (   /dd/defs/os9.d):00384         * Direct Page Variable Definitions
                      (   /dd/defs/os9.d):00385         *
                      (   /dd/defs/os9.d):00386                        ORG       $00
0000                  (   /dd/defs/os9.d):00387         D.WDAddr       RMB       2                   FHL/Isted WD1002-05 interface base address
0002                  (   /dd/defs/os9.d):00388         D.WDBtDr       RMB       1                   FHL/Isted WD1002-05 boot physical device drive num.
0003                  (   /dd/defs/os9.d):00389         D.SWPage       RMB       1                   SmartWatch page # (see clock2_smart)
0004                  (   /dd/defs/os9.d):00390                        RMB       5
0009                  (   /dd/defs/os9.d):00391         D.COCOXT       RMB       1                   Busy flag for CoCo-XT driver (one drive at a time)
000A                  (   /dd/defs/os9.d):00392         D.DbgMem       RMB       2                   Debug memory pointer
000C                  (   /dd/defs/os9.d):00393         D.DWSubAddr    RMB       2                   DriveWire subroutine module pointer
000E                  (   /dd/defs/os9.d):00394         D.DWStat       RMB       2                   DriveWire statics page
0010                  (   /dd/defs/os9.d):00395         D.DWSrvID      RMB       1                   DriveWire server ID
                      (   /dd/defs/os9.d):00396         
     0011             (   /dd/defs/os9.d):00397         D.IRQTmp       EQU     $0011  ; 1 or 2 byte DP scratch var [strick yak adds]
                      (   /dd/defs/os9.d):00398         
                      (   /dd/defs/os9.d):00399                        ORG       $20
                      (   /dd/defs/os9.d):00400         
                      (   /dd/defs/os9.d):00401         
                      (   /dd/defs/os9.d):00402         * Level 1 DP vars
                      (   /dd/defs/os9.d):00403         
                      (   /dd/defs/os9.d):00404         *D.XSWI3        RMB       3
                      (   /dd/defs/os9.d):00405         *D.XSWI2        RMB       3
                      (   /dd/defs/os9.d):00406         *D.XFIRQ        RMB       3
                      (   /dd/defs/os9.d):00407         *D.XIRQ         RMB       3
                      (   /dd/defs/os9.d):00408         *D.XSWI         RMB       3
                      (   /dd/defs/os9.d):00409         *D.XNMI         RMB       3
                      (   /dd/defs/os9.d):00410         
                      (   /dd/defs/os9.d):00411         
                      (   /dd/defs/os9.d):00412         * Table Sizes
                      (   /dd/defs/os9.d):00413         
                      (   /dd/defs/os9.d):00414         
                      (   /dd/defs/os9.d):00415         * Level 2 DP vars
0020                  (   /dd/defs/os9.d):00416         D.Tasks        RMB       2                   Task User Table
0022                  (   /dd/defs/os9.d):00417         D.TmpDAT       RMB       2                   Temporary DAT Image stack
0024                  (   /dd/defs/os9.d):00418         D.Init         RMB       2                   Initialization Module ptr
0026                  (   /dd/defs/os9.d):00419         D.Poll         RMB       2                   Interrupt Polling Routine ptr
     0028             (   /dd/defs/os9.d):00420         D.Time         EQU       .                   System Time
0028                  (   /dd/defs/os9.d):00421         D.Year         RMB       1
0029                  (   /dd/defs/os9.d):00422         D.Month        RMB       1
002A                  (   /dd/defs/os9.d):00423         D.Day          RMB       1
002B                  (   /dd/defs/os9.d):00424         D.Hour         RMB       1
002C                  (   /dd/defs/os9.d):00425         D.Min          RMB       1
002D                  (   /dd/defs/os9.d):00426         D.Sec          RMB       1
002E                  (   /dd/defs/os9.d):00427         D.Tick         RMB       1
002F                  (   /dd/defs/os9.d):00428         D.Slice        RMB       1                   current slice remaining
0030                  (   /dd/defs/os9.d):00429         D.TSlice       RMB       1                   Ticks per Slice
0031                  (   /dd/defs/os9.d):00430         D.Boot         RMB       1                   Bootstrap attempted flag
0032                  (   /dd/defs/os9.d):00431         D.MotOn        RMB       1                   Floppy Disk Motor-On time out
0033                  (   /dd/defs/os9.d):00432         D.ErrCod       RMB       1                   Reset Error Code
0034                  (   /dd/defs/os9.d):00433         D.Daywk        RMB       1                   day of week, com-trol clock
0035                  (   /dd/defs/os9.d):00434         D.TkCnt        RMB       1                   Tick Counter
0036                  (   /dd/defs/os9.d):00435         D.BtPtr        RMB       2                   Address of Boot in System Address space
0038                  (   /dd/defs/os9.d):00436         D.BtSz         RMB       2                   Size of Boot
                      (   /dd/defs/os9.d):00437         
003A                  (   /dd/defs/os9.d):00438                        RMB       1                   Currently unused in NitrOS-9/6809
                      (   /dd/defs/os9.d):00439         
003B                  (   /dd/defs/os9.d):00440         D.CRC          RMB       1                   CRC checking mode flag
                      (   /dd/defs/os9.d):00441         
003C                  (   /dd/defs/os9.d):00442         D.Tenths       RMB       1                   Tenths and hundredths of second for F$Xtime
003D                  (   /dd/defs/os9.d):00443         D.Task1N       RMB       1                   Map type 1 task number*2 - offset into [D.TskIPt]
003E                  (   /dd/defs/os9.d):00444         D.Quick        RMB       1                   Quick system call return flag - 0 =stack is at $FEE1
003F                  (   /dd/defs/os9.d):00445         D.QIRQ         RMB       1                   Quick IRQ flag - 0 =IRQ wasn't clock, so quick return
                      (   /dd/defs/os9.d):00446         
                      (   /dd/defs/os9.d):00447                        ORG       $40
0040                  (   /dd/defs/os9.d):00448         D.BlkMap       RMB       4                   Memory Block Map ptr
0044                  (   /dd/defs/os9.d):00449         D.ModDir       RMB       4                   Module Directory ptrs
0048                  (   /dd/defs/os9.d):00450         D.PrcDBT       RMB       2                   Process Descriptor Block Table ptr
004A                  (   /dd/defs/os9.d):00451         D.SysPrc       RMB       2                   System Process Descriptor ptr
004C                  (   /dd/defs/os9.d):00452         D.SysDAT       RMB       2                   System DAT Image ptr
004E                  (   /dd/defs/os9.d):00453         D.SysMem       RMB       2                   System Memory Map ptr
0050                  (   /dd/defs/os9.d):00454         D.Proc         RMB       2                   Current Process ptr
0052                  (   /dd/defs/os9.d):00455         D.AProcQ       RMB       2                   Active Process Queue
0054                  (   /dd/defs/os9.d):00456         D.WProcQ       RMB       2                   Waiting Process Queue
0056                  (   /dd/defs/os9.d):00457         D.SProcQ       RMB       2                   Sleeping Process Queue
0058                  (   /dd/defs/os9.d):00458         D.ModEnd       RMB       2                   Module Directory end ptr
005A                  (   /dd/defs/os9.d):00459         D.ModDAT       RMB       2                   Module Dir DAT image end ptr
005C                  (   /dd/defs/os9.d):00460         D.CldRes       RMB       2                   Cold Restart vector
005E                  (   /dd/defs/os9.d):00461         D.BtBug        RMB       3                   Boot debug information
0061                  (   /dd/defs/os9.d):00462         D.Pipe         RMB       2
                      (   /dd/defs/os9.d):00463         
                      (   /dd/defs/os9.d):00464                        ORG       $6B
006B                  (   /dd/defs/os9.d):00465         D.Crash        RMB       6                   Pointer to CC Crash Routine
0071                  (   /dd/defs/os9.d):00466         D.CBStrt       RMB       $B                  Reserved for CC warmstart ($71)
007C                  (   /dd/defs/os9.d):00467         D.QCnt         RMB       1                   Count of number of quick system calls performed
                      (   /dd/defs/os9.d):00468         
                      (   /dd/defs/os9.d):00469                        ORG       $80
0080                  (   /dd/defs/os9.d):00470         D.DevTbl       RMB       2                   I/O Device Table
0082                  (   /dd/defs/os9.d):00471         D.PolTbl       RMB       2                   I/O Polling Table
0084                  (   /dd/defs/os9.d):00472                        RMB       4                   reserved
0088                  (   /dd/defs/os9.d):00473         D.PthDBT       RMB       2                   Path Descriptor Block Table ptr
008A                  (   /dd/defs/os9.d):00474         D.DMAReq       RMB       1                   DMA Request flag
                      (   /dd/defs/os9.d):00475         
                      (   /dd/defs/os9.d):00476         ********
                      (   /dd/defs/os9.d):00477         * CoCo 3 STUFF COMES NEXT
                      (   /dd/defs/os9.d):00478         * This area is used for the CoCo Hardware Registers
                      (   /dd/defs/os9.d):00479         *
                      (   /dd/defs/os9.d):00480                        ORG       $90
0090                  (   /dd/defs/os9.d):00481         D.HINIT        RMB       1                   GIME INIT0 register (hardware setup $FF90)
0091                  (   /dd/defs/os9.d):00482         D.TINIT        RMB       1                   GIME INIT1 register (timer/task register $FF91)
0092                  (   /dd/defs/os9.d):00483         D.IRQER        RMB       1                   Interrupt enable regsiter ($FF92)
0093                  (   /dd/defs/os9.d):00484         D.FRQER        RMB       1                   Fast Interrupt enable register ($FF93)
0094                  (   /dd/defs/os9.d):00485         D.TIMMS        RMB       1                   Timer most significant nibble ($FF94)
0095                  (   /dd/defs/os9.d):00486         D.TIMLS        RMB       1                   Timer least significant byte ($FF95)
0096                  (   /dd/defs/os9.d):00487         D.RESV1        RMB       1                   reserved register ($FF96)
0097                  (   /dd/defs/os9.d):00488         D.RESV2        RMB       1                   reserved register ($FF97)
0098                  (   /dd/defs/os9.d):00489         D.VIDMD        RMB       1                   video mode register ($FF98)
0099                  (   /dd/defs/os9.d):00490         D.VIDRS        RMB       1                   video resolution register ($FF99)
009A                  (   /dd/defs/os9.d):00491         D.BORDR        RMB       1                   border register ($FF9A)
009B                  (   /dd/defs/os9.d):00492         D.RESV3        RMB       1                   reserved register ($FF9B)
009C                  (   /dd/defs/os9.d):00493         D.VOFF2        RMB       1                   vertical scroll/offset 2 register ($FF9C)
009D                  (   /dd/defs/os9.d):00494         D.VOFF1        RMB       1                   vertical offset 1 register ($FF9D)
009E                  (   /dd/defs/os9.d):00495         D.VOFF0        RMB       1                   vertical offset 0 register ($FF9E)
009F                  (   /dd/defs/os9.d):00496         D.HOFF0        RMB       1                   horizontal offset 0 register ($FF9F)
00A0                  (   /dd/defs/os9.d):00497         D.Speed        RMB       1                   Speed of COCO CPU 0=slow,1=fast ($A0)
00A1                  (   /dd/defs/os9.d):00498         D.TskIPt       RMB       2                   Task image Pointer table (CC) ($A1)
00A3                  (   /dd/defs/os9.d):00499         D.MemSz        RMB       1                   128/512K memory flag (CC) ($A3)
00A4                  (   /dd/defs/os9.d):00500         D.SSTskN       RMB       1                   System State Task Number (COCO) ($A4)
00A5                  (   /dd/defs/os9.d):00501         D.CCMem        RMB       2                   Pointer to beginning of CC Memory ($A5)
00A7                  (   /dd/defs/os9.d):00502         D.CCStk        RMB       2                   Pointer to top of CC Memory ($A7)
00A9                  (   /dd/defs/os9.d):00503         D.Flip0        RMB       2                   Change to Task 0 ($A9)
00AB                  (   /dd/defs/os9.d):00504         D.Flip1        RMB       2                   Change to reserved Task 1 ($AB)
00AD                  (   /dd/defs/os9.d):00505         D.VIRQ         RMB       2                   VIRQ Polling routine ($AD)
00AF                  (   /dd/defs/os9.d):00506         D.IRQS         RMB       1                   IRQ shadow register (CC Temporary) ($AF)
00B0                  (   /dd/defs/os9.d):00507         D.CLTb         RMB       2                   VIRQ Table address ($B0)
00B2                  (   /dd/defs/os9.d):00508         D.AltIRQ       RMB       2                   Alternate IRQ Vector (CC) ($B2)
00B4                  (   /dd/defs/os9.d):00509         D.GPoll        RMB       2                   CC GIME IRQ enable/disable toggle
00B6                  (   /dd/defs/os9.d):00510         D.Clock2       RMB       2                   CC Clock2 entry address
                      (   /dd/defs/os9.d):00511                        ORG       $C0
00C0                  (   /dd/defs/os9.d):00512         D.SysSvc       RMB       2                   System Service Routine entry
00C2                  (   /dd/defs/os9.d):00513         D.SysDis       RMB       2                   System Service Dispatch Table ptr
00C4                  (   /dd/defs/os9.d):00514         D.SysIRQ       RMB       2                   System IRQ Routine entry
00C6                  (   /dd/defs/os9.d):00515         D.UsrSvc       RMB       2                   User Service Routine entry
00C8                  (   /dd/defs/os9.d):00516         D.UsrDis       RMB       2                   User Service Dispatch Table ptr
00CA                  (   /dd/defs/os9.d):00517         D.UsrIRQ       RMB       2                   User IRQ Routine entry
00CC                  (   /dd/defs/os9.d):00518         D.SysStk       RMB       2                   System stack
00CE                  (   /dd/defs/os9.d):00519         D.SvcIRQ       RMB       2                   In-System IRQ service
00D0                  (   /dd/defs/os9.d):00520         D.SysTsk       RMB       1                   System Task number
                      (   /dd/defs/os9.d):00521                        ORG       $E0
00E0                  (   /dd/defs/os9.d):00522         D.Clock        RMB       2
00E2                  (   /dd/defs/os9.d):00523         D.XSWI3        RMB       2
00E4                  (   /dd/defs/os9.d):00524         D.XSWI2        RMB       2
00E6                  (   /dd/defs/os9.d):00525         D.XFIRQ        RMB       2
00E8                  (   /dd/defs/os9.d):00526         D.XIRQ         RMB       2
00EA                  (   /dd/defs/os9.d):00527         D.XSWI         RMB       2
00EC                  (   /dd/defs/os9.d):00528         D.XNMI         RMB       2
00EE                  (   /dd/defs/os9.d):00529         D.ErrRst       RMB       2
00F0                  (   /dd/defs/os9.d):00530         D.SysVec       RMB       2                   F$xxx system call vector for NitrOS-9 Level 3
00F2                  (   /dd/defs/os9.d):00531         D.SWI3         RMB       2
00F4                  (   /dd/defs/os9.d):00532         D.SWI2         RMB       2
00F6                  (   /dd/defs/os9.d):00533         D.FIRQ         RMB       2
00F8                  (   /dd/defs/os9.d):00534         D.IRQ          RMB       2
00FA                  (   /dd/defs/os9.d):00535         D.SWI          RMB       2
00FC                  (   /dd/defs/os9.d):00536         D.NMI          RMB       2
                      (   /dd/defs/os9.d):00537         
                      (   /dd/defs/os9.d):00538         *************************
                      (   /dd/defs/os9.d):00539         * Level 2 flags used for bytes in the memory block map at D.BlkMap
                      (   /dd/defs/os9.d):00540         * and for bytes in the system memory map at D.SysMem.
                      (   /dd/defs/os9.d):00541         * A value of 0 indicates an unused/unassigned block.
                      (   /dd/defs/os9.d):00542         * In the code, block assignment often involves incrementing a value
                      (   /dd/defs/os9.d):00543         * from 0 to 1 rather than explict use of RAMinUse.
                      (   /dd/defs/os9.d):00544         *
     0080             (   /dd/defs/os9.d):00545         NotRAM         EQU       %10000000           Block Not RAM flag
     0004             (   /dd/defs/os9.d):00546         VidRAM         EQU       %00000100           Block is being used as Video RAM
     0002             (   /dd/defs/os9.d):00547         ModBlock       EQU       %00000010           Module in Block
     0001             (   /dd/defs/os9.d):00548         RAMinUse       EQU       %00000001           RAM Block in use flag
                      (   /dd/defs/os9.d):00549         *
                      (   /dd/defs/os9.d):00550         * Service Dispatch Table special entries
                      (   /dd/defs/os9.d):00551         *
     00FE             (   /dd/defs/os9.d):00552         IOEntry        EQU       254
                      (   /dd/defs/os9.d):00553         
                      (   /dd/defs/os9.d):00554         
                      (   /dd/defs/os9.d):00555                        TTL       Structure Formats
                      (   /dd/defs/os9.d):00556                        PAG       
                      (   /dd/defs/os9.d):00557         ************************************
                      (   /dd/defs/os9.d):00558         * Module Directory Entry Definitions
                      (   /dd/defs/os9.d):00559         *
                      (   /dd/defs/os9.d):00560                        ORG       0
0000                  (   /dd/defs/os9.d):00561         MD$MPDAT       RMB       2                   Module DAT Image ptr
0002                  (   /dd/defs/os9.d):00562         MD$MBSiz       RMB       2                   Memory Block size
0004                  (   /dd/defs/os9.d):00563         MD$MPtr        RMB       2                   Module ptr
0006                  (   /dd/defs/os9.d):00564         MD$Link        RMB       2                   Module Link count
     0008             (   /dd/defs/os9.d):00565         MD$ESize       EQU       .                   Module Directory Entry size
                      (   /dd/defs/os9.d):00566         
                      (   /dd/defs/os9.d):00567         ************************************
                      (   /dd/defs/os9.d):00568         * Module Definitions
                      (   /dd/defs/os9.d):00569         *
                      (   /dd/defs/os9.d):00570         * Universal Module Offsets
                      (   /dd/defs/os9.d):00571         *
                      (   /dd/defs/os9.d):00572                        ORG       0
0000                  (   /dd/defs/os9.d):00573         M$ID           RMB       2                   ID Code
0002                  (   /dd/defs/os9.d):00574         M$Size         RMB       2                   Module Size
0004                  (   /dd/defs/os9.d):00575         M$Name         RMB       2                   Module Name
0006                  (   /dd/defs/os9.d):00576         M$Type         RMB       1                   Type / Language
0007                  (   /dd/defs/os9.d):00577         M$Revs         RMB       1                   Attributes / Revision Level
0008                  (   /dd/defs/os9.d):00578         M$Parity       RMB       1                   Header Parity
     0009             (   /dd/defs/os9.d):00579         M$IDSize       EQU       .                   Module ID Size
                      (   /dd/defs/os9.d):00580         *
                      (   /dd/defs/os9.d):00581         * Type-Dependent Module Offsets
                      (   /dd/defs/os9.d):00582         *
                      (   /dd/defs/os9.d):00583         * System, File Manager, Device Driver, Program Module
                      (   /dd/defs/os9.d):00584         *
0009                  (   /dd/defs/os9.d):00585         M$Exec         RMB       2                   Execution Entry Offset
                      (   /dd/defs/os9.d):00586         *
                      (   /dd/defs/os9.d):00587         * Device Driver, Program Module
                      (   /dd/defs/os9.d):00588         *
000B                  (   /dd/defs/os9.d):00589         M$Mem          RMB       2                   Stack Requirement
                      (   /dd/defs/os9.d):00590         *
                      (   /dd/defs/os9.d):00591         * Device Driver, Device Descriptor Module
                      (   /dd/defs/os9.d):00592         *
000D                  (   /dd/defs/os9.d):00593         M$Mode         RMB       1                   Device Driver Mode Capabilities
                      (   /dd/defs/os9.d):00594         *
                      (   /dd/defs/os9.d):00595         * Device Descriptor Module
                      (   /dd/defs/os9.d):00596         *
                      (   /dd/defs/os9.d):00597                        ORG       M$IDSize
0009                  (   /dd/defs/os9.d):00598         M$FMgr         RMB       2                   File Manager Name Offset
000B                  (   /dd/defs/os9.d):00599         M$PDev         RMB       2                   Device Driver Name Offset
000D                  (   /dd/defs/os9.d):00600                        RMB       1                   M$Mode (defined above)
000E                  (   /dd/defs/os9.d):00601         M$Port         RMB       3                   Port Address
0011                  (   /dd/defs/os9.d):00602         M$Opt          RMB       1                   Device Default Options
0012                  (   /dd/defs/os9.d):00603         M$DTyp         RMB       1                   Device Type
     0012             (   /dd/defs/os9.d):00604         IT.DTP         EQU       M$DTyp              Descriptor type offset
                      (   /dd/defs/os9.d):00605         *
                      (   /dd/defs/os9.d):00606         * Configuration Module Entry Offsets
                      (   /dd/defs/os9.d):00607         *
                      (   /dd/defs/os9.d):00608                        ORG       M$IDSize
0009                  (   /dd/defs/os9.d):00609         MaxMem         RMB       3                   Maximum Free Memory
000C                  (   /dd/defs/os9.d):00610         PollCnt        RMB       1                   Entries in Interrupt Polling Table
000D                  (   /dd/defs/os9.d):00611         DevCnt         RMB       1                   Entries in Device Table
000E                  (   /dd/defs/os9.d):00612         InitStr        RMB       2                   Initial Module Name
0010                  (   /dd/defs/os9.d):00613         SysStr         RMB       2                   System Device Name
0012                  (   /dd/defs/os9.d):00614         StdStr         RMB       2                   Standard I/O Pathlist
0014                  (   /dd/defs/os9.d):00615         BootStr        RMB       2                   Bootstrap Module name
0016                  (   /dd/defs/os9.d):00616         ProtFlag       RMB       1                   Write protect enable flag
                      (   /dd/defs/os9.d):00617         
0017                  (   /dd/defs/os9.d):00618         OSLevel        RMB       1                   OS level
0018                  (   /dd/defs/os9.d):00619         OSVer          RMB       1                   OS version
0019                  (   /dd/defs/os9.d):00620         OSMajor        RMB       1                   OS major
001A                  (   /dd/defs/os9.d):00621         OSMinor        RMB       1                   OS minor
001B                  (   /dd/defs/os9.d):00622         Feature1       RMB       1                   feature byte 1
001C                  (   /dd/defs/os9.d):00623         Feature2       RMB       1                   feature byte 2
001D                  (   /dd/defs/os9.d):00624         OSName         RMB       2                   OS revision name string (nul terminated)
001F                  (   /dd/defs/os9.d):00625         InstallName    RMB       2                   installation name string (nul terminated)
0021                  (   /dd/defs/os9.d):00626                        RMB       4                   reserved for future use
                      (   /dd/defs/os9.d):00627         
                      (   /dd/defs/os9.d):00628         * -- VTIO area -- (NitrOS-9 Level 2 and above) *
0025                  (   /dd/defs/os9.d):00629         MonType        RMB       1                   Monitor type (0=CMP,1=RGB,2=MONO)
0026                  (   /dd/defs/os9.d):00630         MouseInf       RMB       2                   Mouse resolution/Mouse port; was 1, major error RG.
0028                  (   /dd/defs/os9.d):00631         KeyRptS        RMB       1                   Key repeat start constant
0029                  (   /dd/defs/os9.d):00632         KeyRptD        RMB       1                   Key repeat delay constant
                      (   /dd/defs/os9.d):00633         
                      (   /dd/defs/os9.d):00634         * Feature1 byte definitions
     0001             (   /dd/defs/os9.d):00635         CRCOn          EQU       %00000001           CRC checking on
     0000             (   /dd/defs/os9.d):00636         CRCOff         EQU       %00000000           CRC checking off
     0000             (   /dd/defs/os9.d):00637         Proc6809       EQU       %00000000           6809 procesor
     0002             (   /dd/defs/os9.d):00638         Proc6309       EQU       %00000010           6309 procesor
                      (   /dd/defs/os9.d):00639         
                      (   /dd/defs/os9.d):00640                        PAG       
                      (   /dd/defs/os9.d):00641         **************************
                      (   /dd/defs/os9.d):00642         * Module Field Definitions
                      (   /dd/defs/os9.d):00643         *
                      (   /dd/defs/os9.d):00644         * ID Field - First two bytes of a NitrOS-9 module
                      (   /dd/defs/os9.d):00645         *
     0087             (   /dd/defs/os9.d):00646         M$ID1          EQU       $87                 Module ID code byte one
     00CD             (   /dd/defs/os9.d):00647         M$ID2          EQU       $CD                 Module ID code byte two
     87CD             (   /dd/defs/os9.d):00648         M$ID12         EQU       M$ID1*256+M$ID2
                      (   /dd/defs/os9.d):00649         
                      (   /dd/defs/os9.d):00650         *
                      (   /dd/defs/os9.d):00651         * Module Type/Language Field Masks
                      (   /dd/defs/os9.d):00652         *
     00F0             (   /dd/defs/os9.d):00653         TypeMask       EQU       %11110000           Type Field
     000F             (   /dd/defs/os9.d):00654         LangMask       EQU       %00001111           Language Field
                      (   /dd/defs/os9.d):00655         
                      (   /dd/defs/os9.d):00656         *
                      (   /dd/defs/os9.d):00657         * Module Type Values
                      (   /dd/defs/os9.d):00658         *
     00F0             (   /dd/defs/os9.d):00659         Devic          EQU       $F0                 Device Descriptor Module
     00E0             (   /dd/defs/os9.d):00660         Drivr          EQU       $E0                 Physical Device Driver
     00D0             (   /dd/defs/os9.d):00661         FlMgr          EQU       $D0                 File Manager
     00C0             (   /dd/defs/os9.d):00662         Systm          EQU       $C0                 System Module
     0050             (   /dd/defs/os9.d):00663         ShellSub       EQU       $50                 Shell+ shell sub module
     0040             (   /dd/defs/os9.d):00664         Data           EQU       $40                 Data Module
     0030             (   /dd/defs/os9.d):00665         Multi          EQU       $30                 Multi-Module
     0020             (   /dd/defs/os9.d):00666         Sbrtn          EQU       $20                 Subroutine Module
     0010             (   /dd/defs/os9.d):00667         Prgrm          EQU       $10                 Program Module
                      (   /dd/defs/os9.d):00668         
                      (   /dd/defs/os9.d):00669         *
                      (   /dd/defs/os9.d):00670         * Module Language Values
                      (   /dd/defs/os9.d):00671         *
     0001             (   /dd/defs/os9.d):00672         Objct          EQU       1                   6809 Object Code Module
     0002             (   /dd/defs/os9.d):00673         ICode          EQU       2                   Basic09 I-code
     0003             (   /dd/defs/os9.d):00674         PCode          EQU       3                   Pascal P-code
     0004             (   /dd/defs/os9.d):00675         CCode          EQU       4                   C I-code
     0005             (   /dd/defs/os9.d):00676         CblCode        EQU       5                   Cobol I-code
     0006             (   /dd/defs/os9.d):00677         FrtnCode       EQU       6                   Fortran I-code
     0007             (   /dd/defs/os9.d):00678         Obj6309        EQU       7                   6309 object code
                      (   /dd/defs/os9.d):00679         *
                      (   /dd/defs/os9.d):00680         * Module Attributes / Revision byte
                      (   /dd/defs/os9.d):00681         *
                      (   /dd/defs/os9.d):00682         * Field Masks
                      (   /dd/defs/os9.d):00683         *
     00F0             (   /dd/defs/os9.d):00684         AttrMask       EQU       %11110000           Attributes Field
     000F             (   /dd/defs/os9.d):00685         RevsMask       EQU       %00001111           Revision Level Field
                      (   /dd/defs/os9.d):00686         *
                      (   /dd/defs/os9.d):00687         * Attribute Flags
                      (   /dd/defs/os9.d):00688         *
     0080             (   /dd/defs/os9.d):00689         ReEnt          EQU       %10000000           Re-Entrant Module
     0040             (   /dd/defs/os9.d):00690         ModProt        EQU       %01000000           Gimix Module protect bit (0=protected, 1=write enable)
     0020             (   /dd/defs/os9.d):00691         ModNat         EQU       %00100000           6309 native mode attribute
     0040             (   /dd/defs/os9.d):00692         BufWrits       EQU       ModProt             SCF buffered read supported (Coco only at this point)
     0010             (   /dd/defs/os9.d):00693         BufReads       EQU       %00010000           SCF buffered write supported (Coco only at this point)
                      (   /dd/defs/os9.d):00694         * LCB - propose we add Buffered Read/Buffered Write attribute bits for Coco (in descriptors and
                      (   /dd/defs/os9.d):00695         *   drivers for SCF), with one of them replacing ModProt. SCF would check Read/ReadLn and Write/WritLn
                      (   /dd/defs/os9.d):00696         *   calls, and if both the driver and descriptor have the appropriate bit set, it would do buffered 32
                      (   /dd/defs/os9.d):00697         *   byte (for now) reads/writes like the Grfdrv write call does now, for all bytes that are ASCII >$1F
                      (   /dd/defs/os9.d):00698         *   (ie non-control chars, which need special processing)
                      (   /dd/defs/os9.d):00699         
                      (   /dd/defs/os9.d):00700         
                      (   /dd/defs/os9.d):00701         ********************
                      (   /dd/defs/os9.d):00702         * Device Type Values
                      (   /dd/defs/os9.d):00703         *
                      (   /dd/defs/os9.d):00704         * These values define various classes of devices, which are
                      (   /dd/defs/os9.d):00705         * managed by a file manager module.  The Device Type is embedded
                      (   /dd/defs/os9.d):00706         * in a device's device descriptor.
                      (   /dd/defs/os9.d):00707         *
     0000             (   /dd/defs/os9.d):00708         DT.SCF         EQU       0                   Sequential Character File Manager
     0001             (   /dd/defs/os9.d):00709         DT.RBF         EQU       1                   Random Block File Manager
     0002             (   /dd/defs/os9.d):00710         DT.Pipe        EQU       2                   Pipe File Manager
     0003             (   /dd/defs/os9.d):00711         DT.SBF         EQU       3                   Sequential Block File Manager
     0004             (   /dd/defs/os9.d):00712         DT.NFM         EQU       4                   Network File Manager
     0005             (   /dd/defs/os9.d):00713         DT.CDFM        EQU       5                   CD-ROM File Manager
     0006             (   /dd/defs/os9.d):00714         DT.RFM                  EQU             6                                       Remote File Manager
                      (   /dd/defs/os9.d):00715         
                      (   /dd/defs/os9.d):00716         *********************
                      (   /dd/defs/os9.d):00717         * CRC Result Constant
                      (   /dd/defs/os9.d):00718         *
     0080             (   /dd/defs/os9.d):00719         CRCCon1        EQU       $80
     0FE3             (   /dd/defs/os9.d):00720         CRCCon23       EQU       $0FE3
                      (   /dd/defs/os9.d):00721         
                      (   /dd/defs/os9.d):00722                        TTL       Process Information
                      (   /dd/defs/os9.d):00723                        PAG       
                      (   /dd/defs/os9.d):00724         ********************************
                      (   /dd/defs/os9.d):00725         * Process Descriptor Definitions
                      (   /dd/defs/os9.d):00726         *
                      (   /dd/defs/os9.d):00727         
                      (   /dd/defs/os9.d):00728         * Level 1 process descriptor defs
                      (   /dd/defs/os9.d):00729         
                      (   /dd/defs/os9.d):00730         
                      (   /dd/defs/os9.d):00731         *
                      (   /dd/defs/os9.d):00732         * Process State Flags
                      (   /dd/defs/os9.d):00733         *
                      (   /dd/defs/os9.d):00734         
                      (   /dd/defs/os9.d):00735         
                      (   /dd/defs/os9.d):00736         * Level 2 process descriptor defs
     0010             (   /dd/defs/os9.d):00737         DefIOSiz       EQU       16                  Default I/O Data Length
     000C             (   /dd/defs/os9.d):00738         NefIOSiz       EQU       12                  On-Net Default I/O Data Length
     0010             (   /dd/defs/os9.d):00739         NumPaths       EQU       16                  Number of Local Paths
                      (   /dd/defs/os9.d):00740         
                      (   /dd/defs/os9.d):00741                        ORG       0
0000                  (   /dd/defs/os9.d):00742         P$ID           RMB       1                   Process ID
0001                  (   /dd/defs/os9.d):00743         P$PID          RMB       1                   Parent's ID
0002                  (   /dd/defs/os9.d):00744         P$SID          RMB       1                   Sibling's ID
0003                  (   /dd/defs/os9.d):00745         P$CID          RMB       1                   Child's ID
0004                  (   /dd/defs/os9.d):00746         P$SP           RMB       2                   Stack ptr
0006                  (   /dd/defs/os9.d):00747         P$Task         RMB       1                   Task Number
0007                  (   /dd/defs/os9.d):00748         P$PagCnt       RMB       1                   Memory Page Count
0008                  (   /dd/defs/os9.d):00749         P$User         RMB       2                   User Index
000A                  (   /dd/defs/os9.d):00750         P$Prior        RMB       1                   Priority
000B                  (   /dd/defs/os9.d):00751         P$Age          RMB       1                   Age
000C                  (   /dd/defs/os9.d):00752         P$State        RMB       1                   Status
000D                  (   /dd/defs/os9.d):00753         P$Queue        RMB       2                   Queue Link (Process ptr)
000F                  (   /dd/defs/os9.d):00754         P$IOQP         RMB       1                   Previous I/O Queue Link (Process ID)
0010                  (   /dd/defs/os9.d):00755         P$IOQN         RMB       1                   Next I/O Queue Link (Process ID)
0011                  (   /dd/defs/os9.d):00756         P$PModul       RMB       2                   Primary Module
0013                  (   /dd/defs/os9.d):00757         P$SWI          RMB       2                   SWI Entry Point
0015                  (   /dd/defs/os9.d):00758         P$SWI2         RMB       2                   SWI2 Entry Point
0017                  (   /dd/defs/os9.d):00759         P$SWI3         RMB       2                   SWI3 Entry Point
0019                  (   /dd/defs/os9.d):00760         P$Signal       RMB       1                   Signal Code
001A                  (   /dd/defs/os9.d):00761         P$SigVec       RMB       2                   Signal Intercept Vector
001C                  (   /dd/defs/os9.d):00762         P$SigDat       RMB       2                   Signal Intercept Data Address
001E                  (   /dd/defs/os9.d):00763         P$DeadLk       RMB       1                   Dominant proc ID if I/O locked
001F                  (   /dd/defs/os9.d):00764                        RMB       $20-.               unused
0020                  (   /dd/defs/os9.d):00765         P$DIO          RMB       DefIOSiz            Default I/O ptrs
0030                  (   /dd/defs/os9.d):00766         P$Path         RMB       NumPaths            I/O Path Table
0040                  (   /dd/defs/os9.d):00767         P$DATImg       RMB       64                  DAT Image
0080                  (   /dd/defs/os9.d):00768         P$Links        RMB       32                  Block Link counts
00A0                  (   /dd/defs/os9.d):00769         P$NIO          RMB       6*2                 additional DIO ptrs for net, compatible  with 68k
00AC                  (   /dd/defs/os9.d):00770         P$SelP         RMB       1                   Selected Path for COCO Windows (Default 0)
00AD                  (   /dd/defs/os9.d):00771         P$UTicks       RMB       4                   proc User Tick counter        (L2V3)
00B1                  (   /dd/defs/os9.d):00772         P$STicks       RMB       4                   proc System Tick counter      (L2V3)
00B5                  (   /dd/defs/os9.d):00773         P$FCalls       RMB       4                   proc F$ call counter          (L2V3)
00B9                  (   /dd/defs/os9.d):00774         P$ICalls       RMB       4                   proc I$ call counter          (L2V3)
00BD                  (   /dd/defs/os9.d):00775         P$DatBeg       RMB       3                   proc Date of creation (Y/M/D) (L2V3)
00C0                  (   /dd/defs/os9.d):00776         P$TimBeg       RMB       3                   proc Time of creation (H/M/S) (L2V3)
00C3                  (   /dd/defs/os9.d):00777         P$Alarm        RMB       6
00C9                  (   /dd/defs/os9.d):00778                        RMB       $200-.              Local stack
     0200             (   /dd/defs/os9.d):00779         P$Stack        EQU       .                   Top of Stack
     0200             (   /dd/defs/os9.d):00780         P$Size         EQU       .                   Size of Process Descriptor
                      (   /dd/defs/os9.d):00781         
                      (   /dd/defs/os9.d):00782         *
                      (   /dd/defs/os9.d):00783         * Process State Flags
                      (   /dd/defs/os9.d):00784         *
     0080             (   /dd/defs/os9.d):00785         SysState       EQU       %10000000
     0040             (   /dd/defs/os9.d):00786         TimSleep       EQU       %01000000
     0020             (   /dd/defs/os9.d):00787         TimOut         EQU       %00100000
     0010             (   /dd/defs/os9.d):00788         ImgChg         EQU       %00010000
     0008             (   /dd/defs/os9.d):00789         Suspend        EQU       %00001000
     0002             (   /dd/defs/os9.d):00790         Condem         EQU       %00000010
     0001             (   /dd/defs/os9.d):00791         Dead           EQU       %00000001
                      (   /dd/defs/os9.d):00792         
                      (   /dd/defs/os9.d):00793         
                      (   /dd/defs/os9.d):00794                        TTL       NitrOS-9 I/O Symbolic Definitions
                      (   /dd/defs/os9.d):00795                        PAG       
                      (   /dd/defs/os9.d):00796         *************************
                      (   /dd/defs/os9.d):00797         * Path Descriptor Offsets
                      (   /dd/defs/os9.d):00798         *
                      (   /dd/defs/os9.d):00799                        ORG       0
0000                  (   /dd/defs/os9.d):00800         PD.PD          RMB       1                   Path Number
0001                  (   /dd/defs/os9.d):00801         PD.MOD         RMB       1                   Mode (Read/Write/Update)
0002                  (   /dd/defs/os9.d):00802         PD.CNT         RMB       1                   Number of Open Images
0003                  (   /dd/defs/os9.d):00803         PD.DEV         RMB       2                   Device Table Entry Address
0005                  (   /dd/defs/os9.d):00804         PD.CPR         RMB       1                   Current Process
0006                  (   /dd/defs/os9.d):00805         PD.RGS         RMB       2                   Caller's Register Stack
0008                  (   /dd/defs/os9.d):00806         PD.BUF         RMB       2                   Buffer Address
000A                  (   /dd/defs/os9.d):00807         PD.FST         RMB       32-.                File Manager's Storage
     0020             (   /dd/defs/os9.d):00808         PD.OPT         EQU       .                   PD GetSts(0) Options
0020                  (   /dd/defs/os9.d):00809         PD.DTP         RMB       1                   Device Type
0021                  (   /dd/defs/os9.d):00810                        RMB       64-.                Path options
     0040             (   /dd/defs/os9.d):00811         PDSIZE         EQU       .
                      (   /dd/defs/os9.d):00812         
                      (   /dd/defs/os9.d):00813         *
                      (   /dd/defs/os9.d):00814         * Pathlist Special Symbols
                      (   /dd/defs/os9.d):00815         *
     002F             (   /dd/defs/os9.d):00816         PDELIM         EQU       '/                  Pathlist Name Separator
     002E             (   /dd/defs/os9.d):00817         PDIR           EQU       '.                  Directory
     0040             (   /dd/defs/os9.d):00818         PENTIR         EQU       '@                  Entire Device
                      (   /dd/defs/os9.d):00819         
                      (   /dd/defs/os9.d):00820                        PAG       
                      (   /dd/defs/os9.d):00821         ****************************
                      (   /dd/defs/os9.d):00822         * File Manager Entry Offsets
                      (   /dd/defs/os9.d):00823         *
                      (   /dd/defs/os9.d):00824                        ORG       0
0000                  (   /dd/defs/os9.d):00825         FMCREA         RMB       3                   Create (Open New) File
0003                  (   /dd/defs/os9.d):00826         FMOPEN         RMB       3                   Open File
0006                  (   /dd/defs/os9.d):00827         FMMDIR         RMB       3                   Make Directory
0009                  (   /dd/defs/os9.d):00828         FMCDIR         RMB       3                   Change Directory
000C                  (   /dd/defs/os9.d):00829         FMDLET         RMB       3                   Delete File
000F                  (   /dd/defs/os9.d):00830         FMSEEK         RMB       3                   Position File
0012                  (   /dd/defs/os9.d):00831         FMREAD         RMB       3                   Read from File
0015                  (   /dd/defs/os9.d):00832         FMWRIT         RMB       3                   Write to File
0018                  (   /dd/defs/os9.d):00833         FMRDLN         RMB       3                   ReadLn
001B                  (   /dd/defs/os9.d):00834         FMWRLN         RMB       3                   WritLn
001E                  (   /dd/defs/os9.d):00835         FMGSTA         RMB       3                   Get File Status
0021                  (   /dd/defs/os9.d):00836         FMSSTA         RMB       3                   Set File Status
0024                  (   /dd/defs/os9.d):00837         FMCLOS         RMB       3                   Close File
                      (   /dd/defs/os9.d):00838         
                      (   /dd/defs/os9.d):00839         *****************************
                      (   /dd/defs/os9.d):00840         * Device Driver Entry Offsets
                      (   /dd/defs/os9.d):00841         *
                      (   /dd/defs/os9.d):00842                        ORG       0
0000                  (   /dd/defs/os9.d):00843         D$INIT         RMB       3                   Device Initialization
0003                  (   /dd/defs/os9.d):00844         D$READ         RMB       3                   Read from Device
0006                  (   /dd/defs/os9.d):00845         D$WRIT         RMB       3                   Write to Device
0009                  (   /dd/defs/os9.d):00846         D$GSTA         RMB       3                   Get Device Status
000C                  (   /dd/defs/os9.d):00847         D$PSTA         RMB       3                   Put Device Status
000F                  (   /dd/defs/os9.d):00848         D$TERM         RMB       3                   Device Termination
                      (   /dd/defs/os9.d):00849         
                      (   /dd/defs/os9.d):00850         *********************
                      (   /dd/defs/os9.d):00851         * Device Table Format
                      (   /dd/defs/os9.d):00852         *
                      (   /dd/defs/os9.d):00853                        ORG       0
0000                  (   /dd/defs/os9.d):00854         V$DRIV         RMB       2                   Device Driver module
0002                  (   /dd/defs/os9.d):00855         V$STAT         RMB       2                   Device Driver Static storage
0004                  (   /dd/defs/os9.d):00856         V$DESC         RMB       2                   Device Descriptor module
0006                  (   /dd/defs/os9.d):00857         V$FMGR         RMB       2                   File Manager module
0008                  (   /dd/defs/os9.d):00858         V$USRS         RMB       1                   use count
0009                  (   /dd/defs/os9.d):00859         V$DRIVEX       RMB       2                   Device Driver execution address
000B                  (   /dd/defs/os9.d):00860         V$FMGREX       RMB       2                   File Manager execution address
     000D             (   /dd/defs/os9.d):00861         DEVSIZ         EQU       .
                      (   /dd/defs/os9.d):00862         
                      (   /dd/defs/os9.d):00863         *******************************
                      (   /dd/defs/os9.d):00864         * Device Static Storage Offsets
                      (   /dd/defs/os9.d):00865         *
                      (   /dd/defs/os9.d):00866                        ORG       0
0000                  (   /dd/defs/os9.d):00867         V.PAGE         RMB       1                   Port Extended Address
0001                  (   /dd/defs/os9.d):00868         V.PORT         RMB       2                   Device 'Base' Port Address
0003                  (   /dd/defs/os9.d):00869         V.LPRC         RMB       1                   Last Active Process ID
0004                  (   /dd/defs/os9.d):00870         V.BUSY         RMB       1                   Active Process ID (0=UnBusy)
0005                  (   /dd/defs/os9.d):00871         V.WAKE         RMB       1                   Active PD if Driver MUST Wake-up
     0006             (   /dd/defs/os9.d):00872         V.USER         EQU       .                   Driver Allocation Origin
                      (   /dd/defs/os9.d):00873         
                      (   /dd/defs/os9.d):00874         ********************************
                      (   /dd/defs/os9.d):00875         * Interrupt Polling Table Format
                      (   /dd/defs/os9.d):00876         *
                      (   /dd/defs/os9.d):00877                        ORG       0
0000                  (   /dd/defs/os9.d):00878         Q$POLL         RMB       2                   Absolute Polling Address
0002                  (   /dd/defs/os9.d):00879         Q$FLIP         RMB       1                   Flip (EOR) Byte ..normally Zero
0003                  (   /dd/defs/os9.d):00880         Q$MASK         RMB       1                   Polling Mask (after Flip)
0004                  (   /dd/defs/os9.d):00881         Q$SERV         RMB       2                   Absolute Service routine Address
0006                  (   /dd/defs/os9.d):00882         Q$STAT         RMB       2                   Static Storage Address
0008                  (   /dd/defs/os9.d):00883         Q$PRTY         RMB       1                   Priority (Low Numbers=Top Priority)
0009                  (   /dd/defs/os9.d):00884         Q$MAP          RMB       2                   NitrOS-9 Level 2 and above
     000B             (   /dd/defs/os9.d):00885         POLSIZ         EQU       .
                      (   /dd/defs/os9.d):00886         
                      (   /dd/defs/os9.d):00887         ********************
                      (   /dd/defs/os9.d):00888         * VIRQ packet format
                      (   /dd/defs/os9.d):00889         *
                      (   /dd/defs/os9.d):00890                        ORG       0
0000                  (   /dd/defs/os9.d):00891         Vi.Cnt         RMB       2                   count down counter
0002                  (   /dd/defs/os9.d):00892         Vi.Rst         RMB       2                   reset value for counter
0004                  (   /dd/defs/os9.d):00893         Vi.Stat        RMB       1                   status byte
     0005             (   /dd/defs/os9.d):00894         Vi.PkSz        EQU       .
                      (   /dd/defs/os9.d):00895         
     0001             (   /dd/defs/os9.d):00896         Vi.IFlag       EQU       %00000001           status byte virq flag
                      (   /dd/defs/os9.d):00897         
                      (   /dd/defs/os9.d):00898                        PAG       
                      (   /dd/defs/os9.d):00899         *************************************
                      (   /dd/defs/os9.d):00900         * Machine Characteristics Definitions
                      (   /dd/defs/os9.d):00901         *
     0000             (   /dd/defs/os9.d):00902         R$CC           EQU       0                   Condition Codes register
     0001             (   /dd/defs/os9.d):00903         R$A            EQU       1                   A Accumulator
     0002             (   /dd/defs/os9.d):00904         R$B            EQU       2                   B Accumulator
     0001             (   /dd/defs/os9.d):00905         R$D            EQU       R$A                 Combined A:B Accumulator
                      (   /dd/defs/os9.d):00906                        IFNE      H6309
0005                  (   /dd/defs/os9.d):00907         R$E            EQU       3
0005                  (   /dd/defs/os9.d):00908         R$F            EQU       4
0005                  (   /dd/defs/os9.d):00909         R$W            EQU       R$E
0005                  (   /dd/defs/os9.d):00910         R$Q            EQU       R$A
0005                  (   /dd/defs/os9.d):00911         R$DP           EQU       5
0005                  (   /dd/defs/os9.d):00912         R$X            EQU       6
0005                  (   /dd/defs/os9.d):00913         R$Y            EQU       8
0005                  (   /dd/defs/os9.d):00914         R$U            EQU       10
0005                  (   /dd/defs/os9.d):00915         R$PC           EQU       12
0005                  (   /dd/defs/os9.d):00916         R$Size         EQU       14
                      (   /dd/defs/os9.d):00917                        ELSE
     0003             (   /dd/defs/os9.d):00918         R$DP           EQU       3                   Direct Page register
     0004             (   /dd/defs/os9.d):00919         R$X            EQU       4                   X Index register
     0006             (   /dd/defs/os9.d):00920         R$Y            EQU       6                   Y Index register
     0008             (   /dd/defs/os9.d):00921         R$U            EQU       8                   User Stack register
     000A             (   /dd/defs/os9.d):00922         R$PC           EQU       10                  Program Counter register
     000C             (   /dd/defs/os9.d):00923         R$Size         EQU       12                  Total register package size
                      (   /dd/defs/os9.d):00924                        ENDC
                      (   /dd/defs/os9.d):00925         
                      (   /dd/defs/os9.d):00926         * MD register masks
                      (   /dd/defs/os9.d):00927         * 6309 definitions
     0080             (   /dd/defs/os9.d):00928         DIV0           EQU       %10000000           division by 0 trap flag       : 1 = trap occured
     0040             (   /dd/defs/os9.d):00929         badinstr       EQU       %01000000           illegal instruction trap flag : 1 = trap occured
                      (   /dd/defs/os9.d):00930         
     0080             (   /dd/defs/os9.d):00931         Entire         EQU       %10000000           Full Register Stack flag
     0040             (   /dd/defs/os9.d):00932         FIRQMask       EQU       %01000000           Fast-Interrupt Mask bit
     0020             (   /dd/defs/os9.d):00933         HalfCrry       EQU       %00100000           Half Carry flag
     0010             (   /dd/defs/os9.d):00934         IRQMask        EQU       %00010000           Interrupt Mask bit
     0008             (   /dd/defs/os9.d):00935         Negative       EQU       %00001000           Negative flag
     0004             (   /dd/defs/os9.d):00936         Zero           EQU       %00000100           Zero flag
     0002             (   /dd/defs/os9.d):00937         TwosOvfl       EQU       %00000010           Two's Comp Overflow flag
     0001             (   /dd/defs/os9.d):00938         Carry          EQU       %00000001           Carry bit
     0050             (   /dd/defs/os9.d):00939         IntMasks       EQU       IRQMask+FIRQMask
     0080             (   /dd/defs/os9.d):00940         Sign           EQU       %10000000           sign bit
                      (   /dd/defs/os9.d):00941         
                      (   /dd/defs/os9.d):00942                        TTL       Error Code Definitions
                      (   /dd/defs/os9.d):00943                        PAG       
                      (   /dd/defs/os9.d):00944         ************************
                      (   /dd/defs/os9.d):00945         * Error Code Definitions
                      (   /dd/defs/os9.d):00946         *
                      (   /dd/defs/os9.d):00947         * Basic09 Error Codes
                      (   /dd/defs/os9.d):00948         *
                      (   /dd/defs/os9.d):00949                        ORG       10
000A                  (   /dd/defs/os9.d):00950         E$UnkSym       RMB       1                   Unknown symbol
000B                  (   /dd/defs/os9.d):00951         E$ExcVrb       RMB       1                   Excessive verbage
000C                  (   /dd/defs/os9.d):00952         E$IllStC       RMB       1                   Illegal statement construction
000D                  (   /dd/defs/os9.d):00953         E$ICOvf        RMB       1                   I-code overflow
000E                  (   /dd/defs/os9.d):00954         E$IChRef       RMB       1                   Illegal channel reference
000F                  (   /dd/defs/os9.d):00955         E$IllMod       RMB       1                   Illegal mode
0010                  (   /dd/defs/os9.d):00956         E$IllNum       RMB       1                   Illegal number
0011                  (   /dd/defs/os9.d):00957         E$IllPrf       RMB       1                   Illegal prefix
0012                  (   /dd/defs/os9.d):00958         E$IllOpd       RMB       1                   Illegal operand
0013                  (   /dd/defs/os9.d):00959         E$IllOpr       RMB       1                   Illegal operator
0014                  (   /dd/defs/os9.d):00960         E$IllRFN       RMB       1                   Illegal record field name
0015                  (   /dd/defs/os9.d):00961         E$IllDim       RMB       1                   Illegal dimension
0016                  (   /dd/defs/os9.d):00962         E$IllLit       RMB       1                   Illegal literal
0017                  (   /dd/defs/os9.d):00963         E$IllRet       RMB       1                   Illegal relational
0018                  (   /dd/defs/os9.d):00964         E$IllSfx       RMB       1                   Illegal type suffix
0019                  (   /dd/defs/os9.d):00965         E$DimLrg       RMB       1                   Dimension too large
001A                  (   /dd/defs/os9.d):00966         E$LinLrg       RMB       1                   Line number too large
001B                  (   /dd/defs/os9.d):00967         E$NoAssg       RMB       1                   Missing assignment statement
001C                  (   /dd/defs/os9.d):00968         E$NoPath       RMB       1                   Missing path number
001D                  (   /dd/defs/os9.d):00969         E$NoComa       RMB       1                   Missing coma
001E                  (   /dd/defs/os9.d):00970         E$NoDim        RMB       1                   Missing dimension
001F                  (   /dd/defs/os9.d):00971         E$NoDO         RMB       1                   Missing DO statement
0020                  (   /dd/defs/os9.d):00972         E$MFull        RMB       1                   Memory full
0021                  (   /dd/defs/os9.d):00973         E$NoGoto       RMB       1                   Missing GOTO
0022                  (   /dd/defs/os9.d):00974         E$NoLPar       RMB       1                   Missing left parenthesis
0023                  (   /dd/defs/os9.d):00975         E$NoLRef       RMB       1                   Missing line reference
0024                  (   /dd/defs/os9.d):00976         E$NoOprd       RMB       1                   Missing operand
0025                  (   /dd/defs/os9.d):00977         E$NoRPar       RMB       1                   Missing right parenthesis
0026                  (   /dd/defs/os9.d):00978         E$NoTHEN       RMB       1                   Missing THEN statement
0027                  (   /dd/defs/os9.d):00979         E$NoTO         RMB       1                   Missing TO statement
0028                  (   /dd/defs/os9.d):00980         E$NoVRef       RMB       1                   Missing variable reference
0029                  (   /dd/defs/os9.d):00981         E$EndQou       RMB       1                   Missing end quote
002A                  (   /dd/defs/os9.d):00982         E$SubLrg       RMB       1                   Too many subscripts
002B                  (   /dd/defs/os9.d):00983         E$UnkPrc       RMB       1                   Unknown procedure
002C                  (   /dd/defs/os9.d):00984         E$MulPrc       RMB       1                   Multiply defined procedure
002D                  (   /dd/defs/os9.d):00985         E$DivZer       RMB       1                   Divice by zero
002E                  (   /dd/defs/os9.d):00986         E$TypMis       RMB       1                   Operand type mismatch
002F                  (   /dd/defs/os9.d):00987         E$StrOvf       RMB       1                   String stack overflow
0030                  (   /dd/defs/os9.d):00988         E$NoRout       RMB       1                   Unimplemented routine
0031                  (   /dd/defs/os9.d):00989         E$UndVar       RMB       1                   Undefined variable
0032                  (   /dd/defs/os9.d):00990         E$FltOvf       RMB       1                   Floating Overflow
0033                  (   /dd/defs/os9.d):00991         E$LnComp       RMB       1                   Line with compiler error
0034                  (   /dd/defs/os9.d):00992         E$ValRng       RMB       1                   Value out of range for destination
0035                  (   /dd/defs/os9.d):00993         E$SubOvf       RMB       1                   Subroutine stack overflow
0036                  (   /dd/defs/os9.d):00994         E$SubUnd       RMB       1                   Subroutine stack underflow
0037                  (   /dd/defs/os9.d):00995         E$SubRng       RMB       1                   Subscript out of range
0038                  (   /dd/defs/os9.d):00996         E$ParmEr       RMB       1                   Paraemter error
0039                  (   /dd/defs/os9.d):00997         E$SysOvf       RMB       1                   System stack overflow
003A                  (   /dd/defs/os9.d):00998         E$IOMism       RMB       1                   I/O type mismatch
003B                  (   /dd/defs/os9.d):00999         E$IONum        RMB       1                   I/O numeric input format bad
003C                  (   /dd/defs/os9.d):01000         E$IOConv       RMB       1                   I/O conversion: number out of range
003D                  (   /dd/defs/os9.d):01001         E$IllInp       RMB       1                   Illegal input format
003E                  (   /dd/defs/os9.d):01002         E$IOFRpt       RMB       1                   I/O format repeat error
003F                  (   /dd/defs/os9.d):01003         E$IOFSyn       RMB       1                   I/O format syntax error
0040                  (   /dd/defs/os9.d):01004         E$IllPNm       RMB       1                   Illegal path number
0041                  (   /dd/defs/os9.d):01005         E$WrSub        RMB       1                   Wrong number of subscripts
0042                  (   /dd/defs/os9.d):01006         E$NonRcO       RMB       1                   Non-record type operand
0043                  (   /dd/defs/os9.d):01007         E$IllA         RMB       1                   Illegal argument
0044                  (   /dd/defs/os9.d):01008         E$IllCnt       RMB       1                   Illegal control structure
0045                  (   /dd/defs/os9.d):01009         E$UnmCnt       RMB       1                   Unmatched control structure
0046                  (   /dd/defs/os9.d):01010         E$IllFOR       RMB       1                   Illegal FOR variable
0047                  (   /dd/defs/os9.d):01011         E$IllExp       RMB       1                   Illegal expression type
0048                  (   /dd/defs/os9.d):01012         E$IllDec       RMB       1                   Illegal declarative statement
0049                  (   /dd/defs/os9.d):01013         E$ArrOvf       RMB       1                   Array size overflow
004A                  (   /dd/defs/os9.d):01014         E$UndLin       RMB       1                   Undefined line number
004B                  (   /dd/defs/os9.d):01015         E$MltLin       RMB       1                   Multiply defined line number
004C                  (   /dd/defs/os9.d):01016         E$MltVar       RMB       1                   Multiply defined variable
004D                  (   /dd/defs/os9.d):01017         E$IllIVr       RMB       1                   Illegal input variable
004E                  (   /dd/defs/os9.d):01018         E$SeekRg       RMB       1                   Seek out of range
004F                  (   /dd/defs/os9.d):01019         E$NoData       RMB       1                   Missing data statement
                      (   /dd/defs/os9.d):01020         
                      (   /dd/defs/os9.d):01021         *
                      (   /dd/defs/os9.d):01022         * System Dependent Error Codes
                      (   /dd/defs/os9.d):01023         *
                      (   /dd/defs/os9.d):01024         
                      (   /dd/defs/os9.d):01025         * Level 2 windowing error codes
                      (   /dd/defs/os9.d):01026                        ORG       183
00B7                  (   /dd/defs/os9.d):01027         E$IWTyp        RMB       1                   Illegal window type
00B8                  (   /dd/defs/os9.d):01028         E$WADef        RMB       1                   Window already defined
00B9                  (   /dd/defs/os9.d):01029         E$NFont        RMB       1                   Font not found
00BA                  (   /dd/defs/os9.d):01030         E$StkOvf       RMB       1                   Stack overflow
00BB                  (   /dd/defs/os9.d):01031         E$IllArg       RMB       1                   Illegal argument
00BC                  (   /dd/defs/os9.d):01032                        RMB       1                   reserved
00BD                  (   /dd/defs/os9.d):01033         E$ICoord       RMB       1                   Illegal coordinates
00BE                  (   /dd/defs/os9.d):01034         E$Bug          RMB       1                   Bug (should never be returned)
00BF                  (   /dd/defs/os9.d):01035         E$BufSiz       RMB       1                   Buffer size is too small
00C0                  (   /dd/defs/os9.d):01036         E$IllCmd       RMB       1                   Illegal command
00C1                  (   /dd/defs/os9.d):01037         E$TblFul       RMB       1                   Screen or window table is full
00C2                  (   /dd/defs/os9.d):01038         E$BadBuf       RMB       1                   Bad/Undefined buffer number
00C3                  (   /dd/defs/os9.d):01039         E$IWDef        RMB       1                   Illegal window definition
00C4                  (   /dd/defs/os9.d):01040         E$WUndef       RMB       1                   Window undefined
                      (   /dd/defs/os9.d):01041         
00C5                  (   /dd/defs/os9.d):01042         E$Up           RMB       1                   Up arrow pressed on SCF I$ReadLn with PD.UP enabled
00C6                  (   /dd/defs/os9.d):01043         E$Dn           RMB       1                   Down arrow pressed on SCF I$ReadLn with PD.DOWN enabled
00C7                  (   /dd/defs/os9.d):01044         E$Alias        RMB       1
                      (   /dd/defs/os9.d):01045         
                      (   /dd/defs/os9.d):01046         
                      (   /dd/defs/os9.d):01047         *
                      (   /dd/defs/os9.d):01048         * Standard NitrOS-9 Error Codes
                      (   /dd/defs/os9.d):01049         *
                      (   /dd/defs/os9.d):01050                        ORG       200
00C8                  (   /dd/defs/os9.d):01051         E$PthFul       RMB       1                   Path Table full
00C9                  (   /dd/defs/os9.d):01052         E$BPNum        RMB       1                   Bad Path Number
00CA                  (   /dd/defs/os9.d):01053         E$Poll         RMB       1                   Polling Table Full
00CB                  (   /dd/defs/os9.d):01054         E$BMode        RMB       1                   Bad Mode
00CC                  (   /dd/defs/os9.d):01055         E$DevOvf       RMB       1                   Device Table Overflow
00CD                  (   /dd/defs/os9.d):01056         E$BMID         RMB       1                   Bad Module ID
00CE                  (   /dd/defs/os9.d):01057         E$DirFul       RMB       1                   Module Directory Full
00CF                  (   /dd/defs/os9.d):01058         E$MemFul       RMB       1                   Process Memory Full
00D0                  (   /dd/defs/os9.d):01059         E$UnkSvc       RMB       1                   Unknown Service Code
00D1                  (   /dd/defs/os9.d):01060         E$ModBsy       RMB       1                   Module Busy
00D2                  (   /dd/defs/os9.d):01061         E$BPAddr       RMB       1                   Bad Page Address
00D3                  (   /dd/defs/os9.d):01062         E$EOF          RMB       1                   End of File
00D4                  (   /dd/defs/os9.d):01063                        RMB       1
00D5                  (   /dd/defs/os9.d):01064         E$NES          RMB       1                   Non-Existing Segment
00D6                  (   /dd/defs/os9.d):01065         E$FNA          RMB       1                   File Not Accesible
00D7                  (   /dd/defs/os9.d):01066         E$BPNam        RMB       1                   Bad Path Name
00D8                  (   /dd/defs/os9.d):01067         E$PNNF         RMB       1                   Path Name Not Found
00D9                  (   /dd/defs/os9.d):01068         E$SLF          RMB       1                   Segment List Full
00DA                  (   /dd/defs/os9.d):01069         E$CEF          RMB       1                   Creating Existing File
00DB                  (   /dd/defs/os9.d):01070         E$IBA          RMB       1                   Illegal Block Address
00DC                  (   /dd/defs/os9.d):01071         E$HangUp       RMB       1                   Carrier Detect Lost
00DD                  (   /dd/defs/os9.d):01072         E$MNF          RMB       1                   Module Not Found
00DE                  (   /dd/defs/os9.d):01073                        RMB       1
00DF                  (   /dd/defs/os9.d):01074         E$DelSP        RMB       1                   Deleting Stack Pointer memory
00E0                  (   /dd/defs/os9.d):01075         E$IPrcID       RMB       1                   Illegal Process ID
     00E0             (   /dd/defs/os9.d):01076         E$BPrcID       EQU       E$IPrcID            Bad Process ID (formerly #238)
00E1                  (   /dd/defs/os9.d):01077                        RMB       1
00E2                  (   /dd/defs/os9.d):01078         E$NoChld       RMB       1                   No Children
00E3                  (   /dd/defs/os9.d):01079         E$ISWI         RMB       1                   Illegal SWI code
00E4                  (   /dd/defs/os9.d):01080         E$PrcAbt       RMB       1                   Process Aborted
00E5                  (   /dd/defs/os9.d):01081         E$PrcFul       RMB       1                   Process Table Full
00E6                  (   /dd/defs/os9.d):01082         E$IForkP       RMB       1                   Illegal Fork Parameter
00E7                  (   /dd/defs/os9.d):01083         E$KwnMod       RMB       1                   Known Module
00E8                  (   /dd/defs/os9.d):01084         E$BMCRC        RMB       1                   Bad Module CRC
00E9                  (   /dd/defs/os9.d):01085         E$USigP        RMB       1                   Unprocessed Signal Pending
00EA                  (   /dd/defs/os9.d):01086         E$NEMod        RMB       1                   Non Existing Module
00EB                  (   /dd/defs/os9.d):01087         E$BNam         RMB       1                   Bad Name
00EC                  (   /dd/defs/os9.d):01088         E$BMHP         RMB       1                   (bad module header parity)
00ED                  (   /dd/defs/os9.d):01089         E$NoRAM        RMB       1                   No (System) RAM Available
00EE                  (   /dd/defs/os9.d):01090         E$DNE          RMB       1                   Directory not empty
00EF                  (   /dd/defs/os9.d):01091         E$NoTask       RMB       1                   No available Task number
                      (   /dd/defs/os9.d):01092                        RMB       $F0-.               reserved
00F0                  (   /dd/defs/os9.d):01093         E$Unit         RMB       1                   Illegal Unit (drive)
00F1                  (   /dd/defs/os9.d):01094         E$Sect         RMB       1                   Bad Sector number
00F2                  (   /dd/defs/os9.d):01095         E$WP           RMB       1                   Write Protect
00F3                  (   /dd/defs/os9.d):01096         E$CRC          RMB       1                   Bad Check Sum
00F4                  (   /dd/defs/os9.d):01097         E$Read         RMB       1                   Read Error
00F5                  (   /dd/defs/os9.d):01098         E$Write        RMB       1                   Write Error
00F6                  (   /dd/defs/os9.d):01099         E$NotRdy       RMB       1                   Device Not Ready
00F7                  (   /dd/defs/os9.d):01100         E$Seek         RMB       1                   Seek Error
00F8                  (   /dd/defs/os9.d):01101         E$Full         RMB       1                   Media Full
00F9                  (   /dd/defs/os9.d):01102         E$BTyp         RMB       1                   Bad Type (incompatable) media
00FA                  (   /dd/defs/os9.d):01103         E$DevBsy       RMB       1                   Device Busy
00FB                  (   /dd/defs/os9.d):01104         E$DIDC         RMB       1                   Disk ID Change
00FC                  (   /dd/defs/os9.d):01105         E$Lock         RMB       1                   Record is busy (locked out)
00FD                  (   /dd/defs/os9.d):01106         E$Share        RMB       1                   Non-sharable file busy
00FE                  (   /dd/defs/os9.d):01107         E$DeadLk       RMB       1                   I/O Deadlock error
                      (   /dd/defs/os9.d):01108         
                      (   /dd/defs/os9.d):01109         
                      (   /dd/defs/os9.d):01110         ***************************
                      (   /dd/defs/os9.d):01111         * Level 3 Defs
                      (   /dd/defs/os9.d):01112         *
                      (   /dd/defs/os9.d):01113         * These definitions apply to NitrOS-9 Level 3
                      (   /dd/defs/os9.d):01114         *
                      (   /dd/defs/os9.d):01115         
                      ( /dd/defs/deffile):00007                  use   /dd/defs/rbf.d
                      (   /dd/defs/rbf.d):00001         ********************************************************************
                      (   /dd/defs/rbf.d):00002         * rbf.d - Random Block File Manager Definitions
                      (   /dd/defs/rbf.d):00003         *
                      (   /dd/defs/rbf.d):00004         * $Id$
                      (   /dd/defs/rbf.d):00005         *
                      (   /dd/defs/rbf.d):00006         * RBF stands for 'Random Block Filemanager' and is a package of subroutines
                      (   /dd/defs/rbf.d):00007         * that define the logical structure of a disk and allows access to the files
                      (   /dd/defs/rbf.d):00008         * in that structure.
                      (   /dd/defs/rbf.d):00009         *
                      (   /dd/defs/rbf.d):00010         * The data structures in this file give RBF its 'personality' and are used
                      (   /dd/defs/rbf.d):00011         * by RBF itself, as well as applications that will require disk I/O.
                      (   /dd/defs/rbf.d):00012         *
                      (   /dd/defs/rbf.d):00013         * Edt/Rev  YYYY/MM/DD  Modified by
                      (   /dd/defs/rbf.d):00014         * Comment
                      (   /dd/defs/rbf.d):00015         * ------------------------------------------------------------------
                      (   /dd/defs/rbf.d):00016         *          1982/07/13  Robert F. Doggett
                      (   /dd/defs/rbf.d):00017         * PD.Exten added to path descriptor and PE Entries defined.
                      (   /dd/defs/rbf.d):00018         *
                      (   /dd/defs/rbf.d):00019         *          1982/07/15  Robert F. Doggett
                      (   /dd/defs/rbf.d):00020         * V.FileHd inserted in driver static storage.
                      (   /dd/defs/rbf.d):00021         *
                      (   /dd/defs/rbf.d):00022         *          1982/09/10  WGP
                      (   /dd/defs/rbf.d):00023         * Level One/Level Two condionals added.
                      (   /dd/defs/rbf.d):00024         *
                      (   /dd/defs/rbf.d):00025         *          1982/09/17  WGP
                      (   /dd/defs/rbf.d):00026         *
                      (   /dd/defs/rbf.d):00027         *          1982/09/17  Robert F. Doggett
                      (   /dd/defs/rbf.d):00028         * PD.SLE renamed to PD.Creat.
                      (   /dd/defs/rbf.d):00029         *
                      (   /dd/defs/rbf.d):00030         *          1982/09/17  Robert F. Doggett
                      (   /dd/defs/rbf.d):00031         * V.DiskID, V.BMapSz, V.MapSct added for smart multi-sector bitmap searching.
                      (   /dd/defs/rbf.d):00032         *
                      (   /dd/defs/rbf.d):00033         *          1982/09/20  Robert F. Doggett
                      (   /dd/defs/rbf.d):00034         * Reserved areas added in static storage.
                      (   /dd/defs/rbf.d):00035         
                      (   /dd/defs/rbf.d):00036         *          1983/06/07  Robert F. Doggett
                      (   /dd/defs/rbf.d):00037         * Added InDriver flag in PD.SMF.
                      (   /dd/defs/rbf.d):00038         *
                      (   /dd/defs/rbf.d):00039         *          1983/06/13  Robert F. Doggett
                      (   /dd/defs/rbf.d):00040         * Added PE.Req tmp save for PE.Lock.
                      (   /dd/defs/rbf.d):00041         *
                      (   /dd/defs/rbf.d):00042         *          1983/08/08  Robert F. Doggett
                      (   /dd/defs/rbf.d):00043         * Reserved PD.SToff for Japanese.
                      (   /dd/defs/rbf.d):00044         *
                      (   /dd/defs/rbf.d):00045         *          1983/11/19  Robert F. Doggett
                      (   /dd/defs/rbf.d):00046         * Added V.ResBit in drive tables.
                      (   /dd/defs/rbf.d):00047         *
                      (   /dd/defs/rbf.d):00048         *          1983/12/12  Robert F. Doggett
                      (   /dd/defs/rbf.d):00049         * Added PE.Prior to save process priority.
                      (   /dd/defs/rbf.d):00050         *
                      (   /dd/defs/rbf.d):00051         *          1983/12/13  Robert F. Doggett
                      (   /dd/defs/rbf.d):00052         * Added BufBusy bit in state flag (PD.SMF).
                      (   /dd/defs/rbf.d):00053         *
                      (   /dd/defs/rbf.d):00054         *          1984/07/06  Mark G. Hawkins
                      (   /dd/defs/rbf.d):00055         * Added Bit Definitions for DD.FMT.
                      (   /dd/defs/rbf.d):00056         *
                      (   /dd/defs/rbf.d):00057         *          1987/06/23  Kevin K. Darling
                      (   /dd/defs/rbf.d):00058         * Updated with Dev Desc Info
                      (   /dd/defs/rbf.d):00059         *
                      (   /dd/defs/rbf.d):00060         *          2003/06/02  Boisy G. Pitre
                      (   /dd/defs/rbf.d):00061         * Updated comments for clarity.
                      (   /dd/defs/rbf.d):00062         * Added TYP.256-TYP.2048 definitions for future expansion.
                      (   /dd/defs/rbf.d):00063         *
                      (   /dd/defs/rbf.d):00064         *          2004/04/14  Boisy G. Pitre
                      (   /dd/defs/rbf.d):00065         * Added new entries to device descriptor as per OS-9 Level One V2.00.00
                      (   /dd/defs/rbf.d):00066         * addendum.  Pointed out by Rodney Hamilton.
                      (   /dd/defs/rbf.d):00067         *
                      (   /dd/defs/rbf.d):00068         *          2005/05/31  P.Harvey-Smith.
                      (   /dd/defs/rbf.d):00069         * Added defines for bit 2 of IT.DNS, which the format command uses to
                      (   /dd/defs/rbf.d):00070         * determine if a drive should have it's track 0 as single or double density
                      (   /dd/defs/rbf.d):00071         *
                      (   /dd/defs/rbf.d):00072         *          2005/11/23  Robert Gault
                      (   /dd/defs/rbf.d):00073         * Added IT.MPI giving it duplicate location with IT.TFM. This will not be
                      (   /dd/defs/rbf.d):00074         * transferred to the path descriptor, thus the  equ *  rahter than  rmb 1.
                      (   /dd/defs/rbf.d):00075         *
                      (   /dd/defs/rbf.d):00076         *          2005/12/11  Boisy G. Pitre
                      (   /dd/defs/rbf.d):00077         * Added IT.SOFF1-ITSOFF3 and IT.LLDRV for SuperDrivers.
                      (   /dd/defs/rbf.d):00078         
                      (   /dd/defs/rbf.d):00079                        NAM       rbf.d
                      (   /dd/defs/rbf.d):00080                        TTL       Random Block File Manager Definitions
                      (   /dd/defs/rbf.d):00081         
                      (   /dd/defs/rbf.d):00082                        PAG
                      (   /dd/defs/rbf.d):00083         *******************************
                      (   /dd/defs/rbf.d):00084         * RBF Device Descriptor Offsets
                      (   /dd/defs/rbf.d):00085         *
                      (   /dd/defs/rbf.d):00086         * These definitions are for RBF device descriptors.
                      (   /dd/defs/rbf.d):00087         
                      (   /dd/defs/rbf.d):00088                        ORG       M$DTyp
0012                  (   /dd/defs/rbf.d):00089                        RMB       1                   Device type (DT.RBF)
0013                  (   /dd/defs/rbf.d):00090         IT.DRV         RMB       1                   Drive number
0014                  (   /dd/defs/rbf.d):00091         IT.STP         RMB       1                   Step rate
0015                  (   /dd/defs/rbf.d):00092         IT.TYP         RMB       1                   Disk device type information
0016                  (   /dd/defs/rbf.d):00093         IT.DNS         RMB       1                   Density capability
0017                  (   /dd/defs/rbf.d):00094         IT.CYL         RMB       2                   Number of cylinders
0019                  (   /dd/defs/rbf.d):00095         IT.SID         RMB       1                   Number of surfaces
001A                  (   /dd/defs/rbf.d):00096         IT.VFY         RMB       1                   Verify disk writes (0 = verify, 1 = don't)
001B                  (   /dd/defs/rbf.d):00097         IT.SCT         RMB       2                   Default sectors/track
001D                  (   /dd/defs/rbf.d):00098         IT.T0S         RMB       2                   Default sectors/track for track 0 sector 0
001F                  (   /dd/defs/rbf.d):00099         IT.ILV         RMB       1                   Sector interleave offset
0020                  (   /dd/defs/rbf.d):00100         IT.SAS         RMB       1                   Segment allocation size
                      (   /dd/defs/rbf.d):00101         * The following fields are from the OS-9 Level One V2.00.00 Addendum
0021                  (   /dd/defs/rbf.d):00102         IT.TFM         RMB       1                   DMA Transfer Mode
0022                  (   /dd/defs/rbf.d):00103         IT.Exten       RMB       2                   Path Extension (PE) for record locking
0024                  (   /dd/defs/rbf.d):00104         IT.SToff       RMB       1                   Sector/Track offsets (for "foreign" disk formats)
                      (   /dd/defs/rbf.d):00105         * The following fields are not copied to the path descriptor
0025                  (   /dd/defs/rbf.d):00106         IT.WPC         RMB       1                   Write precomp cyl/4 (HD)
0026                  (   /dd/defs/rbf.d):00107         IT.OFS         RMB       2                   Starting cylinder offset (HD)
0028                  (   /dd/defs/rbf.d):00108         IT.RWC         RMB       2                   Reduced write current cylinder (HD)
                      (   /dd/defs/rbf.d):00109         * These fields have been added because of SuperDriver.  They probably
                      (   /dd/defs/rbf.d):00110         * can be used in other drivers
                      (   /dd/defs/rbf.d):00111                        ORG       IT.WPC
0025                  (   /dd/defs/rbf.d):00112         IT.SOFF1       RMB       1
0026                  (   /dd/defs/rbf.d):00113         IT.SOFF2       RMB       1
0027                  (   /dd/defs/rbf.d):00114         IT.SOFF3       RMB       1
0028                  (   /dd/defs/rbf.d):00115         IT.LLDRV       RMB       2
002A                  (   /dd/defs/rbf.d):00116         IT.MPI         RMB       1
                      (   /dd/defs/rbf.d):00117         
                      (   /dd/defs/rbf.d):00118         
                      (   /dd/defs/rbf.d):00119         * IT.TYP Definitions
                      (   /dd/defs/rbf.d):00120         *
     0080             (   /dd/defs/rbf.d):00121         TYP.HARD       EQU       %10000000           Hard disk
     0000             (   /dd/defs/rbf.d):00122         TYP.FLP        EQU       %00000000           Floppy disk
     0040             (   /dd/defs/rbf.d):00123         TYP.NSF        EQU       %01000000           Non-standard format
     0000             (   /dd/defs/rbf.d):00124         TYP.SOF        EQU       %00000000           Standard NitrOS-9 format
                      (   /dd/defs/rbf.d):00125         
                      (   /dd/defs/rbf.d):00126         * IT.TYP bit definitions if bit 7 of IT.TYP is set (hard disk)
     0000             (   /dd/defs/rbf.d):00127         TYPH.256       EQU       %00000000           256 byte sector media
     0001             (   /dd/defs/rbf.d):00128         TYPH.512       EQU       %00000001           512 byte sector media
     0002             (   /dd/defs/rbf.d):00129         TYPH.1024      EQU       %00000010           1024 byte sector media
     0003             (   /dd/defs/rbf.d):00130         TYPH.2048      EQU       %00000011           2048 byte sector media
     0003             (   /dd/defs/rbf.d):00131         TYPH.SSM       EQU       %00000011           Sector size mask
     000C             (   /dd/defs/rbf.d):00132         TYPH.DRSV      EQU       %00001100           Driver-reserved bits
     0010             (   /dd/defs/rbf.d):00133         TYPH.DSQ       EQU       %00010000           Drive size query flag
                      (   /dd/defs/rbf.d):00134         
                      (   /dd/defs/rbf.d):00135         * IT.TYP bit definitions if bit 7 of IT.TYP is clear (floppy disk)
     0000             (   /dd/defs/rbf.d):00136         TYP.5          EQU       %00000000           5" media
     0001             (   /dd/defs/rbf.d):00137         TYP.3          EQU       %00000001           3.5" media
     0002             (   /dd/defs/rbf.d):00138         TYP.SBO        EQU       %00000010           Sector base offset (clear = 0; sect = 1)
     0000             (   /dd/defs/rbf.d):00139         TYP.256        EQU       %00000000           256 byte sector media
     0004             (   /dd/defs/rbf.d):00140         TYP.512        EQU       %00000100           512 byte sector media
     0020             (   /dd/defs/rbf.d):00141         TYP.CCF        EQU       %00100000           CoCo format
     0000             (   /dd/defs/rbf.d):00142         TYP.NCCF       EQU       %00000000           Non-CoCo format
                      (   /dd/defs/rbf.d):00143         
                      (   /dd/defs/rbf.d):00144         * IT.DNS Definitions
                      (   /dd/defs/rbf.d):00145         *
                      (   /dd/defs/rbf.d):00146         
                      (   /dd/defs/rbf.d):00147         * If bit 7 of IT.TYP is set, IT.DNS is driver-dependent
                      (   /dd/defs/rbf.d):00148         
                      (   /dd/defs/rbf.d):00149         * IT.DNS bit definitions if bit 7 of IT.TYP is clear (floppy disk)
     0000             (   /dd/defs/rbf.d):00150         DNS.FM         EQU       %00000000           Single-density (FM)
     0001             (   /dd/defs/rbf.d):00151         DNS.MFM        EQU       %00000001           Double-density (MFM)
     0000             (   /dd/defs/rbf.d):00152         DNS.STD        EQU       %00000000           Single track distance (48/135 tpi)
     0002             (   /dd/defs/rbf.d):00153         DNS.DTD        EQU       %00000010           Double track distance (96 tpi)
                      (   /dd/defs/rbf.d):00154         
                      (   /dd/defs/rbf.d):00155         * Added PHS,2005-05-31, as format seems to use these
     0000             (   /dd/defs/rbf.d):00156         DNS.FM0        EQU       %00000000           Single density track 0
     0004             (   /dd/defs/rbf.d):00157         DNS.MFM0       EQU       %00000100           Double density track 0
                      (   /dd/defs/rbf.d):00158         
                      (   /dd/defs/rbf.d):00159         * Floppy disk step rate definitions
     0000             (   /dd/defs/rbf.d):00160         STP.30ms       EQU       0                   30ms step rate
     0001             (   /dd/defs/rbf.d):00161         STP.20ms       EQU       1                   20ms step rate
     0002             (   /dd/defs/rbf.d):00162         STP.12ms       EQU       2                   12ms step rate
     0003             (   /dd/defs/rbf.d):00163         STP.6ms        EQU       3                   6ms step rate
                      (   /dd/defs/rbf.d):00164         
                      (   /dd/defs/rbf.d):00165                        PAG
                      (   /dd/defs/rbf.d):00166         *************************************
                      (   /dd/defs/rbf.d):00167         * Random Block Path Descriptor Format
                      (   /dd/defs/rbf.d):00168         *
                      (   /dd/defs/rbf.d):00169         * A path descriptor is created for every new path that is open
                      (   /dd/defs/rbf.d):00170         * via the I$Open system call (processed by IOMan).  Process
                      (   /dd/defs/rbf.d):00171         * descriptors track state information of a path.
                      (   /dd/defs/rbf.d):00172         *
                      (   /dd/defs/rbf.d):00173                        ORG       PD.FST
000A                  (   /dd/defs/rbf.d):00174         PD.SMF         RMB       1                   State flags
000B                  (   /dd/defs/rbf.d):00175         PD.CP          RMB       4                   Current logical byte position
000F                  (   /dd/defs/rbf.d):00176         PD.SIZ         RMB       4                   File size
0013                  (   /dd/defs/rbf.d):00177         PD.SBL         RMB       3                   Segment beginning lsn
0016                  (   /dd/defs/rbf.d):00178         PD.SBP         RMB       3                   Segment beginning psn
0019                  (   /dd/defs/rbf.d):00179         PD.SSZ         RMB       3                   Segment size
001C                  (   /dd/defs/rbf.d):00180         PD.DSK         RMB       2                   Disk id
001E                  (   /dd/defs/rbf.d):00181         PD.DTB         RMB       2                   Drive table ptr
                      (   /dd/defs/rbf.d):00182                        ORG       PD.OPT
0020                  (   /dd/defs/rbf.d):00183                        RMB       1                   Device type
0021                  (   /dd/defs/rbf.d):00184         PD.DRV         RMB       1                   Drive number
0022                  (   /dd/defs/rbf.d):00185         PD.STP         RMB       1                   Step rate
0023                  (   /dd/defs/rbf.d):00186         PD.TYP         RMB       1                   Disk device type (5" 8" other)
0024                  (   /dd/defs/rbf.d):00187         PD.DNS         RMB       1                   Density capability
0025                  (   /dd/defs/rbf.d):00188         PD.CYL         RMB       2                   Number of cylinders
0027                  (   /dd/defs/rbf.d):00189         PD.SID         RMB       1                   Number of surfaces
0028                  (   /dd/defs/rbf.d):00190         PD.VFY         RMB       1                   0=verify disk writes
0029                  (   /dd/defs/rbf.d):00191         PD.SCT         RMB       2                   Default sectors/track
002B                  (   /dd/defs/rbf.d):00192         PD.T0S         RMB       2                   Default sectors/track tr00,s0
002D                  (   /dd/defs/rbf.d):00193         PD.ILV         RMB       1                   Sector interleave offset
002E                  (   /dd/defs/rbf.d):00194         PD.SAS         RMB       1                   Segment allocation size
002F                  (   /dd/defs/rbf.d):00195         PD.TFM         RMB       1                   DMA Transfer Mode
0030                  (   /dd/defs/rbf.d):00196         PD.Exten       RMB       2                   Path Extension (PE) for record locking
0032                  (   /dd/defs/rbf.d):00197         PD.SToff       RMB       1                   Sector/Track offsets (for "foreign" disk formats)
0033                  (   /dd/defs/rbf.d):00198         PD.ATT         RMB       1                   File attributes
0034                  (   /dd/defs/rbf.d):00199         PD.FD          RMB       3                   File descriptor psn
0037                  (   /dd/defs/rbf.d):00200         PD.DFD         RMB       3                   Directory file descriptor psn
003A                  (   /dd/defs/rbf.d):00201         PD.DCP         RMB       4                   File directory entry ptr
003E                  (   /dd/defs/rbf.d):00202         PD.DVT         RMB       2                   User readable dev tbl ptr
                      (   /dd/defs/rbf.d):00203         
                      (   /dd/defs/rbf.d):00204         * State Flags
     0001             (   /dd/defs/rbf.d):00205         BUFMOD         EQU       $01                 Buffer modified
     0002             (   /dd/defs/rbf.d):00206         SINBUF         EQU       $02                 Sector in buffer
     0004             (   /dd/defs/rbf.d):00207         FDBUF          EQU       $04                 File descriptor in buffer
                      (   /dd/defs/rbf.d):00208         *EOFSEC equ $08 End of file sector
                      (   /dd/defs/rbf.d):00209         *EOF equ $10 End of file
     0020             (   /dd/defs/rbf.d):00210         InDriver       EQU       $20                 Currently in Disk Driver, or queued
     0040             (   /dd/defs/rbf.d):00211         BufBusy        EQU       $40                 Buffer is currently busy
                      (   /dd/defs/rbf.d):00212         
                      (   /dd/defs/rbf.d):00213         ************************************
                      (   /dd/defs/rbf.d):00214         * Random Block Path Extension Format
                      (   /dd/defs/rbf.d):00215         *
                      (   /dd/defs/rbf.d):00216         * RBF paths under Level Two have additional information that
                      (   /dd/defs/rbf.d):00217         * is referenced by the path extension area.
                      (   /dd/defs/rbf.d):00218         *
                      (   /dd/defs/rbf.d):00219                        ORG       0
0000                  (   /dd/defs/rbf.d):00220         PE.PE          RMB       1                   PE path number
0001                  (   /dd/defs/rbf.d):00221         PE.PDptr       RMB       2                   Back ptr to this PE's Path Descriptor
0003                  (   /dd/defs/rbf.d):00222         PE.NxFil       RMB       2                   Drive Open-File list ptr
0005                  (   /dd/defs/rbf.d):00223         PE.Confl       RMB       2                   Circular File Conflict list
0007                  (   /dd/defs/rbf.d):00224         PE.Lock        RMB       1                   Path lockout status
0008                  (   /dd/defs/rbf.d):00225         PE.LoLck       RMB       4                   Low Locked Logical addr
000C                  (   /dd/defs/rbf.d):00226         PE.HiLck       RMB       4                   High Locked Logical addr
0010                  (   /dd/defs/rbf.d):00227         PE.Wait        RMB       2                   PE ptr to (next) locked-out PE
0012                  (   /dd/defs/rbf.d):00228         PE.TmOut       RMB       2                   Max ticks to wait for locked segment
0014                  (   /dd/defs/rbf.d):00229         PE.Owner       RMB       1                   Process ID of owner of locked segment
0015                  (   /dd/defs/rbf.d):00230         PE.Req         RMB       1                   Temp for PE.Lock in GAIN when LockSeg fails
0016                  (   /dd/defs/rbf.d):00231         PE.Prior       RMB       1                   Temp for process priority while in driver
0017                  (   /dd/defs/rbf.d):00232         PE.SigSg       RMB       1                   Signal code to send
0018                  (   /dd/defs/rbf.d):00233         PE.SigID       RMB       1                   Process ID to send the signal to
0019                  (   /dd/defs/rbf.d):00234                        RMB       32-.                Reserved
0020                  (   /dd/defs/rbf.d):00235         PE.FilNm       RMB       32                  Temp for filename during directory search
                      (   /dd/defs/rbf.d):00236         
                      (   /dd/defs/rbf.d):00237         * PE.Lock status codes
     0000             (   /dd/defs/rbf.d):00238         Unlocked       EQU       0                   No portion of file is locked
     0001             (   /dd/defs/rbf.d):00239         RcdLock        EQU       1                   Record from LoLck to HiLck locked
     0002             (   /dd/defs/rbf.d):00240         FileLock       EQU       2                   Entire file locked
     0004             (   /dd/defs/rbf.d):00241         EofLock        EQU       4                   End of file is locked
                      (   /dd/defs/rbf.d):00242         
                      (   /dd/defs/rbf.d):00243         
                      (   /dd/defs/rbf.d):00244                        PAG
                      (   /dd/defs/rbf.d):00245         ***********************
                      (   /dd/defs/rbf.d):00246         * LSN0 Disk Data Format
                      (   /dd/defs/rbf.d):00247         *
                      (   /dd/defs/rbf.d):00248         * Logical Sector Number 0 is the first sector on an RBF formatted device
                      (   /dd/defs/rbf.d):00249         * and contains information about the device's size and format.
                      (   /dd/defs/rbf.d):00250         *
                      (   /dd/defs/rbf.d):00251                        ORG       0
0000                  (   /dd/defs/rbf.d):00252         DD.TOT         RMB       3                   Total number of sectors
0003                  (   /dd/defs/rbf.d):00253         DD.TKS         RMB       1                   Track size in sectors
0004                  (   /dd/defs/rbf.d):00254         DD.MAP         RMB       2                   Number of bytes in allocation bit map
0006                  (   /dd/defs/rbf.d):00255         DD.BIT         RMB       2                   Number of sectors/bit
0008                  (   /dd/defs/rbf.d):00256         DD.DIR         RMB       3                   Address of root directory fd
000B                  (   /dd/defs/rbf.d):00257         DD.OWN         RMB       2                   Owner
000D                  (   /dd/defs/rbf.d):00258         DD.ATT         RMB       1                   Attributes
000E                  (   /dd/defs/rbf.d):00259         DD.DSK         RMB       2                   Disk ID
0010                  (   /dd/defs/rbf.d):00260         DD.FMT         RMB       1                   Disk format; density/sides
0011                  (   /dd/defs/rbf.d):00261         DD.SPT         RMB       2                   Sectors/track
0013                  (   /dd/defs/rbf.d):00262         DD.RES         RMB       2                   Reserved for future use
     0015             (   /dd/defs/rbf.d):00263         DD.SIZ         EQU       .                   Device descriptor minimum size
0015                  (   /dd/defs/rbf.d):00264         DD.BT          RMB       3                   System bootstrap sector
0018                  (   /dd/defs/rbf.d):00265         DD.BSZ         RMB       2                   Size of system bootstrap
001A                  (   /dd/defs/rbf.d):00266         DD.DAT         RMB       5                   Creation date
001F                  (   /dd/defs/rbf.d):00267         DD.NAM         RMB       32                  Volume name
003F                  (   /dd/defs/rbf.d):00268         DD.OPT         RMB       32                  Option area
                      (   /dd/defs/rbf.d):00269         
                      (   /dd/defs/rbf.d):00270         *************************
                      (   /dd/defs/rbf.d):00271         * 2012/11/09 Gene Heskett - Some additions for bootlink etc use.
                      (   /dd/defs/rbf.d):00272                 ORG $60         More options from device descriptor
0060                  (   /dd/defs/rbf.d):00273         VD.STP      RMB 1   This is for the /sh and /ih virtual disks in HDBDOS
0061                  (   /dd/defs/rbf.d):00274         VD.OFS      RMB 3   This is DT.WPC and DT.OSF combined, might be more
                      (   /dd/defs/rbf.d):00275         
                      (   /dd/defs/rbf.d):00276         * DD.FMT Bit Definitions - valid only if device is a floppy disk
     0001             (   /dd/defs/rbf.d):00277         FMT.SIDE       EQU       %00000001           Single Sided=0, Double Sided=1
     0002             (   /dd/defs/rbf.d):00278         FMT.DNS        EQU       %00000010           Single Density=0, Double Density=1
     0004             (   /dd/defs/rbf.d):00279         FMT.TDNS       EQU       %00000100           Track Density: 48/135 TPI=0, 96 TPI=1
     0020             (   /dd/defs/rbf.d):00280         FMT.T0DN       EQU       %00100000           Track 0 Density, see FMT.DNS
                      (   /dd/defs/rbf.d):00281         
                      (   /dd/defs/rbf.d):00282         
                      (   /dd/defs/rbf.d):00283                        PAG
                      (   /dd/defs/rbf.d):00284         ************************
                      (   /dd/defs/rbf.d):00285         * File Descriptor Format
                      (   /dd/defs/rbf.d):00286         *
                      (   /dd/defs/rbf.d):00287         * The file descriptor is a sector that is present for every file
                      (   /dd/defs/rbf.d):00288         * on an RBF device.  It contains attributes, modification dates,
                      (   /dd/defs/rbf.d):00289         * and segment information on a file.
                      (   /dd/defs/rbf.d):00290         *
                      (   /dd/defs/rbf.d):00291                        ORG       0
0000                  (   /dd/defs/rbf.d):00292         FD.ATT         RMB       1                   Attributes
0001                  (   /dd/defs/rbf.d):00293         FD.OWN         RMB       2                   Owner
0003                  (   /dd/defs/rbf.d):00294         FD.DAT         RMB       5                   Date last modified
0008                  (   /dd/defs/rbf.d):00295         FD.LNK         RMB       1                   Link count
0009                  (   /dd/defs/rbf.d):00296         FD.SIZ         RMB       4                   File size
000D                  (   /dd/defs/rbf.d):00297         FD.Creat       RMB       3                   File creation date (YY/MM/DD)
     0010             (   /dd/defs/rbf.d):00298         FD.SEG         EQU       .                   Beginning of segment list
                      (   /dd/defs/rbf.d):00299         * Segment List Entry Format
                      (   /dd/defs/rbf.d):00300                        ORG       0
0000                  (   /dd/defs/rbf.d):00301         FDSL.A         RMB       3                   Segment beginning physical sector number
0003                  (   /dd/defs/rbf.d):00302         FDSL.B         RMB       2                   Segment size
     0005             (   /dd/defs/rbf.d):00303         FDSL.S         EQU       .                   Segment list entry size
     00FB             (   /dd/defs/rbf.d):00304         FD.LS1         EQU       FD.SEG+((256-FD.SEG)/FDSL.S-1)*FDSL.S
     00FA             (   /dd/defs/rbf.d):00305         FD.LS2         EQU       (256/FDSL.S-1)*FDSL.S
     0010             (   /dd/defs/rbf.d):00306         MINSEC         SET       16
                      (   /dd/defs/rbf.d):00307         
                      (   /dd/defs/rbf.d):00308         
                      (   /dd/defs/rbf.d):00309                        PAG
                      (   /dd/defs/rbf.d):00310         ************************
                      (   /dd/defs/rbf.d):00311         * Directory Entry Format
                      (   /dd/defs/rbf.d):00312         *
                      (   /dd/defs/rbf.d):00313         * Directory entries are part of a directory and define the name
                      (   /dd/defs/rbf.d):00314         * of the file, as well as a pointer to its file descriptor.
                      (   /dd/defs/rbf.d):00315         *
                      (   /dd/defs/rbf.d):00316                        ORG       0
0000                  (   /dd/defs/rbf.d):00317         DIR.NM         RMB       29                  File name
001D                  (   /dd/defs/rbf.d):00318         DIR.FD         RMB       3                   File descriptor physical sector number
     0020             (   /dd/defs/rbf.d):00319         DIR.SZ         EQU       .                   Directory record size
                      (   /dd/defs/rbf.d):00320         
                      (   /dd/defs/rbf.d):00321         
                      (   /dd/defs/rbf.d):00322                        PAG
                      (   /dd/defs/rbf.d):00323         ********************
                      (   /dd/defs/rbf.d):00324         * RBF Static Storage
                      (   /dd/defs/rbf.d):00325         *
                      (   /dd/defs/rbf.d):00326         * Overall Disk Static Storage
                      (   /dd/defs/rbf.d):00327         *
                      (   /dd/defs/rbf.d):00328         * Note:  This does not reserve any memory for drive tables.  Each
                      (   /dd/defs/rbf.d):00329         *        driver is responsible for reserving sufficient memory for
                      (   /dd/defs/rbf.d):00330         *        the appropriate number of tables.
                      (   /dd/defs/rbf.d):00331         *
                      (   /dd/defs/rbf.d):00332                        ORG       V.USER              Reserve required           ($06)
0006                  (   /dd/defs/rbf.d):00333         V.NDRV         RMB       1                   Number of drives           ($07)
0007                  (   /dd/defs/rbf.d):00334                        RMB       8                   reserved                   ($08)
     000F             (   /dd/defs/rbf.d):00335         DRVBEG         EQU       .                   Beginning of drive tables  ($10)
                      (   /dd/defs/rbf.d):00336         
                      (   /dd/defs/rbf.d):00337                        PAG
                      (   /dd/defs/rbf.d):00338         ****************
                      (   /dd/defs/rbf.d):00339         * Global Storage For Disk Drive Tables
                      (   /dd/defs/rbf.d):00340         *
                      (   /dd/defs/rbf.d):00341         * Each table contains the first 'DD.SIZ' bytes from
                      (   /dd/defs/rbf.d):00342         * LSN 0, and the current track, stepping rate,
                      (   /dd/defs/rbf.d):00343         * bitmap use flag, and disk type.
                      (   /dd/defs/rbf.d):00344         *
                      (   /dd/defs/rbf.d):00345                        ORG       0
0000                  (   /dd/defs/rbf.d):00346                        RMB       DD.SIZ              Device descriptor, LSN 0
0015                  (   /dd/defs/rbf.d):00347         V.TRAK         RMB       2                   Current track
0017                  (   /dd/defs/rbf.d):00348         V.BMB          RMB       1                   Bit-map use flag
0018                  (   /dd/defs/rbf.d):00349         V.FileHd       RMB       2                   Open file list for this drive
001A                  (   /dd/defs/rbf.d):00350         V.DiskID       RMB       2                   Disk ID
001C                  (   /dd/defs/rbf.d):00351         V.BMapSz       RMB       1                   Bitmap Size
001D                  (   /dd/defs/rbf.d):00352         V.MapSct       RMB       1                   Lowest reasonable bitmap sector
001E                  (   /dd/defs/rbf.d):00353         V.ResBit       RMB       1                   Reserved bitmap sector (for compaction)
001F                  (   /dd/defs/rbf.d):00354         V.ScTkOf       RMB       1                   Sector/Track byte (Combined from descriptor)
0020                  (   /dd/defs/rbf.d):00355         V.ScOfst       RMB       1                   Sector offset split from byte above
0021                  (   /dd/defs/rbf.d):00356         V.TkOfst       RMB       1                   Track offset split from byte above
0022                  (   /dd/defs/rbf.d):00357                        RMB       4                   Reserved
     0026             (   /dd/defs/rbf.d):00358         DRVMEM         EQU       .
                      (   /dd/defs/rbf.d):00359         
                      (   /dd/defs/rbf.d):00360         
                      ( /dd/defs/deffile):00008                  use   /dd/defs/scf.d
                      (   /dd/defs/scf.d):00001         ********************************************************************
                      (   /dd/defs/scf.d):00002         * scf.d - Sequential Character File Manager Definitions
                      (   /dd/defs/scf.d):00003         *
                      (   /dd/defs/scf.d):00004         * $Id$
                      (   /dd/defs/scf.d):00005         *
                      (   /dd/defs/scf.d):00006         * SCF stands for 'Sequential Character Filemanager' and is a package of subroutines
                      (   /dd/defs/scf.d):00007         * that define the logical structure of a serial device.
                      (   /dd/defs/scf.d):00008         *
                      (   /dd/defs/scf.d):00009         * The data structures in this file give SCF its 'personality' and are used
                      (   /dd/defs/scf.d):00010         * by SCF itself, as well as applications that will require disk I/O.
                      (   /dd/defs/scf.d):00011         *
                      (   /dd/defs/scf.d):00012         * Edt/Rev  YYYY/MM/DD  Modified by
                      (   /dd/defs/scf.d):00013         * Comment
                      (   /dd/defs/scf.d):00014         * ------------------------------------------------------------------
                      (   /dd/defs/scf.d):00015         *          1984/01/11  YO
                      (   /dd/defs/scf.d):00016         * Added V.KANJI, V.KBUF, V.MODADR for new kanji input process.
                      (   /dd/defs/scf.d):00017         *
                      (   /dd/defs/scf.d):00018         *          1985/04/20  Mark G. Hawkins
                      (   /dd/defs/scf.d):00019         * Added V.PDLHd Path Descriptor List Head.
                      (   /dd/defs/scf.d):00020         *
                      (   /dd/defs/scf.d):00021         *          1985/04/21  Mark G. Hawkins
                      (   /dd/defs/scf.d):00022         * Added PD.PLP and PD.PST for modem handling.
                      (   /dd/defs/scf.d):00023         *
                      (   /dd/defs/scf.d):00024         *          1987/06/23  Kevin K. Darling
                      (   /dd/defs/scf.d):00025         * Updated with Dev Desc info.
                      (   /dd/defs/scf.d):00026         *
                      (   /dd/defs/scf.d):00027         *          1998/10/03  Boisy G. Pitre
                      (   /dd/defs/scf.d):00028         * Consolidated L1/L2 scfdefs.
                      (   /dd/defs/scf.d):00029         *
                      (   /dd/defs/scf.d):00030         *          2003/01/21  Boisy G. Pitre
                      (   /dd/defs/scf.d):00031         * Added symbolics for enhanced SCF line editing.
                      (   /dd/defs/scf.d):00032         *
                      (   /dd/defs/scf.d):00033         *          2003/06/02  Boisy G. Pitre
                      (   /dd/defs/scf.d):00034         * Updated comments for clarity.
                      (   /dd/defs/scf.d):00035         *
                      (   /dd/defs/scf.d):00036         *          2004/05/17  Boisy G. Pitre
                      (   /dd/defs/scf.d):00037         * Added higher baud rates.
                      (   /dd/defs/scf.d):00038         
                      (   /dd/defs/scf.d):00039                        NAM       scf.d
                      (   /dd/defs/scf.d):00040                        TTL       Sequential File Manager Definitions
                      (   /dd/defs/scf.d):00041         
                      (   /dd/defs/scf.d):00042                        PAG
                      (   /dd/defs/scf.d):00043         *******************************
                      (   /dd/defs/scf.d):00044         * SCF Device Descriptor Offsets
                      (   /dd/defs/scf.d):00045         *
                      (   /dd/defs/scf.d):00046         * These definitions are for SCF device descriptors.
                      (   /dd/defs/scf.d):00047         
                      (   /dd/defs/scf.d):00048                        ORG       M$DTyp
0012                  (   /dd/defs/scf.d):00049         IT.DVC         RMB       1                   Device type (DT.SCF)
0013                  (   /dd/defs/scf.d):00050         IT.UPC         RMB       1                   Uppercase flag
0014                  (   /dd/defs/scf.d):00051         IT.BSO         RMB       1                   Backspace behavior
0015                  (   /dd/defs/scf.d):00052         IT.DLO         RMB       1                   Delete behavior
0016                  (   /dd/defs/scf.d):00053         IT.EKO         RMB       1                   Echo flag
0017                  (   /dd/defs/scf.d):00054         IT.ALF         RMB       1                   Auto linefeed flag
0018                  (   /dd/defs/scf.d):00055         IT.NUL         RMB       1                   End-of-line null count
0019                  (   /dd/defs/scf.d):00056         IT.PAU         RMB       1                   Page pause flag
001A                  (   /dd/defs/scf.d):00057         IT.PAG         RMB       1                   Number of lines per page
001B                  (   /dd/defs/scf.d):00058         IT.BSP         RMB       1                   Backspace character
001C                  (   /dd/defs/scf.d):00059         IT.DEL         RMB       1                   Delete-line character
001D                  (   /dd/defs/scf.d):00060         IT.EOR         RMB       1                   End-of-record character
001E                  (   /dd/defs/scf.d):00061         IT.EOF         RMB       1                   End-of-file character
001F                  (   /dd/defs/scf.d):00062         IT.RPR         RMB       1                   Reprint-line character
0020                  (   /dd/defs/scf.d):00063         IT.DUP         RMB       1                   Duplicate-last-line character
0021                  (   /dd/defs/scf.d):00064         IT.PSC         RMB       1                   Pause character
0022                  (   /dd/defs/scf.d):00065         IT.INT         RMB       1                   Interrupt character
0023                  (   /dd/defs/scf.d):00066         IT.QUT         RMB       1                   Quit character
0024                  (   /dd/defs/scf.d):00067         IT.BSE         RMB       1                   Backspace echo character
0025                  (   /dd/defs/scf.d):00068         IT.OVF         RMB       1                   Bell character
0026                  (   /dd/defs/scf.d):00069         IT.PAR         RMB       1                   Parity
0027                  (   /dd/defs/scf.d):00070         IT.BAU         RMB       1                   Baud rate
0028                  (   /dd/defs/scf.d):00071         IT.D2P         RMB       2                   Attached device name string offset
002A                  (   /dd/defs/scf.d):00072         IT.XON         RMB       1                   X-ON character
002B                  (   /dd/defs/scf.d):00073         IT.XOFF        RMB       1                   X-OFF character
002C                  (   /dd/defs/scf.d):00074         IT.COL         RMB       1                   Number of columns for display
002D                  (   /dd/defs/scf.d):00075         IT.ROW         RMB       1                   Number of rows for display
002E                  (   /dd/defs/scf.d):00076         IT.XTYP        RMB       1                   Extended type (added by BRI)
                      (   /dd/defs/scf.d):00077         
                      (   /dd/defs/scf.d):00078         * Window Descriptor Additions
                      (   /dd/defs/scf.d):00079         * For CoCo window, where IT.PAR = $80
                      (   /dd/defs/scf.d):00080                        ORG       IT.ROW+1
002E                  (   /dd/defs/scf.d):00081         IT.WND         RMB       1                   Window number (matches device name) ($2E)
002F                  (   /dd/defs/scf.d):00082         IT.VAL         RMB       1                   Use defaults on Init (0=no, 1=yes)
0030                  (   /dd/defs/scf.d):00083         IT.STY         RMB       1                   Screen type default
0031                  (   /dd/defs/scf.d):00084         IT.CPX         RMB       1                   Column start default
0032                  (   /dd/defs/scf.d):00085         IT.CPY         RMB       1                   Row start default
0033                  (   /dd/defs/scf.d):00086         IT.FGC         RMB       1                   Foreground color default
0034                  (   /dd/defs/scf.d):00087         IT.BGC         RMB       1                   Background color default
0035                  (   /dd/defs/scf.d):00088         IT.BDC         RMB       1                   Border color default
                      (   /dd/defs/scf.d):00089         
                      (   /dd/defs/scf.d):00090         
                      (   /dd/defs/scf.d):00091                        PAG
                      (   /dd/defs/scf.d):00092         ********************
                      (   /dd/defs/scf.d):00093         * SCF Static Storage
                      (   /dd/defs/scf.d):00094         *
                      (   /dd/defs/scf.d):00095         * SCF devices must reserve this space for SCF
                      (   /dd/defs/scf.d):00096         *
                      (   /dd/defs/scf.d):00097                        ORG       V.USER
0006                  (   /dd/defs/scf.d):00098         V.TYPE         RMB       1                   Device type or parity
0007                  (   /dd/defs/scf.d):00099         V.LINE         RMB       1                   Lines left until end of page
0008                  (   /dd/defs/scf.d):00100         V.PAUS         RMB       1                   Immediate Pause request
0009                  (   /dd/defs/scf.d):00101         V.DEV2         RMB       2                   Attached device's static
000B                  (   /dd/defs/scf.d):00102         V.INTR         RMB       1                   Interrupt char
000C                  (   /dd/defs/scf.d):00103         V.QUIT         RMB       1                   Quit char
000D                  (   /dd/defs/scf.d):00104         V.PCHR         RMB       1                   Pause char
000E                  (   /dd/defs/scf.d):00105         V.ERR          RMB       1                   Accumulated errors
000F                  (   /dd/defs/scf.d):00106         V.XON          RMB       1                   X-On char
0010                  (   /dd/defs/scf.d):00107         V.XOFF         RMB       1                   X-Off char
0011                  (   /dd/defs/scf.d):00108         V.KANJI        RMB       1                   Kanji mode flag
0012                  (   /dd/defs/scf.d):00109         V.KBUF         RMB       2                   Kana - Kanji convert routine work address
0014                  (   /dd/defs/scf.d):00110         V.MODADR       RMB       2                   Kana - Kanji convert module address
0016                  (   /dd/defs/scf.d):00111         V.PDLHd        RMB       2                   Open path descriptor list head pointer
0018                  (   /dd/defs/scf.d):00112         V.RSV          RMB       5                   Reserve bytes for future expansion
     001D             (   /dd/defs/scf.d):00113         V.SCF          EQU       .                   Total SCF manager static overhead
                      (   /dd/defs/scf.d):00114         
                      (   /dd/defs/scf.d):00115         
                      (   /dd/defs/scf.d):00116                        PAG
                      (   /dd/defs/scf.d):00117         ***********************
                      (   /dd/defs/scf.d):00118         * Character Definitions
                      (   /dd/defs/scf.d):00119         *
     0000             (   /dd/defs/scf.d):00120         C$NULL         SET       0                   Null char
     0001             (   /dd/defs/scf.d):00121         C$RPET         SET       $01                 (CTRL-A - SOH) Repeat last input line
     0003             (   /dd/defs/scf.d):00122         C$INTR         SET       $03                 (CTRL-C - ETX) Keyboard interrupt
     0004             (   /dd/defs/scf.d):00123         C$RPRT         SET       $04                 (CTRL-D - EOT) Reprint current input line
     0005             (   /dd/defs/scf.d):00124         C$QUIT         SET       $05                 (CTRL-E - ENQ) Keyboard Abort
     0007             (   /dd/defs/scf.d):00125         C$BELL         SET       $07                 (CTRL-G - BEL) Line overflow warning
     0008             (   /dd/defs/scf.d):00126         C$BSP          SET       $08                 (CTRL-H - BS ) Back space
     0009             (   /dd/defs/scf.d):00127         C$RARR         SET       $09                 Right Arrow
     0005             (   /dd/defs/scf.d):00128         C$EL           SET       $05                 Erase Line
     000A             (   /dd/defs/scf.d):00129         C$LF           SET       $0A                 Line feed
     000B             (   /dd/defs/scf.d):00130         C$HOME         SET       $0B                 Home position Code
     0015             (   /dd/defs/scf.d):00131         C$Clsgr        SET       $15                 Graphic screen clear (use FM-11)
     0016             (   /dd/defs/scf.d):00132         C$Clsall       SET       $16                 Graphic & character clear (use FM-11)
     000D             (   /dd/defs/scf.d):00133         C$CR           SET       $0D                 Carriage return
     000C             (   /dd/defs/scf.d):00134         C$FORM         SET       $0C                 (CTRL-L - FF ) Form Feed ... screen clear
     000F             (   /dd/defs/scf.d):00135         C$SI           SET       $0F                 Shift IN Code
     000E             (   /dd/defs/scf.d):00136         C$SO           SET       $0E                 Shift OUT Code
     0010             (   /dd/defs/scf.d):00137         C$DELETE       SET       $10                 Delete char (for SCF enhanced line editing)
     0011             (   /dd/defs/scf.d):00138         C$XON          SET       $11                 (CTRL-Q - DC1) Transmit Enable
     0011             (   /dd/defs/scf.d):00139         C$INSERT       SET       C$XON               Insert char (for SCF enhanced line editing)
     0013             (   /dd/defs/scf.d):00140         C$XOFF         SET       $13                 (CTRL-S - DC3) Transmit Disable
     0013             (   /dd/defs/scf.d):00141         C$PLINE        SET       C$XOFF              Print remaining line (for SCF enhanced line editing)
     0017             (   /dd/defs/scf.d):00142         C$PAUS         SET       $17                 (CTRL-W - ETB) Pause character
     0018             (   /dd/defs/scf.d):00143         C$DEL          SET       $18                 (CTRL-X - CAN) Delete line
     0019             (   /dd/defs/scf.d):00144         C$SHRARR       SET       $19                 Shift Right-Arrow
     001B             (   /dd/defs/scf.d):00145         C$EOF          SET       $1B                 (CTRL-[ - ESC) END of file
     001C             (   /dd/defs/scf.d):00146         C$RGT          SET       $1C                 Cursor right
     001D             (   /dd/defs/scf.d):00147         C$LFT          SET       $1D                 Cursor left
     001E             (   /dd/defs/scf.d):00148         C$UP           SET       $1E                 Cursor up
     001F             (   /dd/defs/scf.d):00149         C$DWN          SET       $1F                 Cursor down
     0020             (   /dd/defs/scf.d):00150         C$SPAC         SET       $20                 Space
     002E             (   /dd/defs/scf.d):00151         C$PERD         SET       '.
     002C             (   /dd/defs/scf.d):00152         C$COMA         SET       ',
                      (   /dd/defs/scf.d):00153         
                      (   /dd/defs/scf.d):00154         
                      (   /dd/defs/scf.d):00155                        PAG
                      (   /dd/defs/scf.d):00156         *********************************************
                      (   /dd/defs/scf.d):00157         * Sequential Character Path Descriptor Format
                      (   /dd/defs/scf.d):00158         *
                      (   /dd/defs/scf.d):00159         * A path descriptor is created for every new path that is open
                      (   /dd/defs/scf.d):00160         * via the I$Open system call (processed by IOMan).  Process
                      (   /dd/defs/scf.d):00161         * descriptors track state information of a path.
                      (   /dd/defs/scf.d):00162         *
                      (   /dd/defs/scf.d):00163                        ORG       PD.FST
000A                  (   /dd/defs/scf.d):00164         PD.DV2         RMB       2                   Output device table pointer
000C                  (   /dd/defs/scf.d):00165         PD.RAW         RMB       1                   Read/Write or ReadLn/WritLn mode
000D                  (   /dd/defs/scf.d):00166         PD.MAX         RMB       2                   ReadLn high byte count
000F                  (   /dd/defs/scf.d):00167         PD.MIN         RMB       1                   Devices are "mine" if clear
0010                  (   /dd/defs/scf.d):00168         PD.STS         RMB       2                   Status routine module addr
0012                  (   /dd/defs/scf.d):00169         PD.STM         RMB       2                   Reserved for status routine
                      (   /dd/defs/scf.d):00170                        ORG       PD.OPT
0020                  (   /dd/defs/scf.d):00171                        RMB       1                   Device type
0021                  (   /dd/defs/scf.d):00172         PD.UPC         RMB       1                   Case (0=both, 1=upper only)
0022                  (   /dd/defs/scf.d):00173         PD.BSO         RMB       1                   Backspace (0=BSE, 1=BSE,SP,BSE)
0023                  (   /dd/defs/scf.d):00174         PD.DLO         RMB       1                   Delete (0=BSE over line, 1=CRLF)
0024                  (   /dd/defs/scf.d):00175         PD.EKO         RMB       1                   Echo (0=No Echo)
0025                  (   /dd/defs/scf.d):00176         PD.ALF         RMB       1                   Auto linefeed (0=No auto LF)
0026                  (   /dd/defs/scf.d):00177         PD.NUL         RMB       1                   End of Line null count
0027                  (   /dd/defs/scf.d):00178         PD.PAU         RMB       1                   Page pause (0=No end of page pause)
0028                  (   /dd/defs/scf.d):00179         PD.PAG         RMB       1                   Lines per page
0029                  (   /dd/defs/scf.d):00180         PD.BSP         RMB       1                   Backspace character
002A                  (   /dd/defs/scf.d):00181         PD.DEL         RMB       1                   Delete Line character
002B                  (   /dd/defs/scf.d):00182         PD.EOR         RMB       1                   End of Record character (read only)
002C                  (   /dd/defs/scf.d):00183         PD.EOF         RMB       1                   End of File character
002D                  (   /dd/defs/scf.d):00184         PD.RPR         RMB       1                   Repront Line character
002E                  (   /dd/defs/scf.d):00185         PD.DUP         RMB       1                   Dup Last Line character
002F                  (   /dd/defs/scf.d):00186         PD.PSC         RMB       1                   Pause character
0030                  (   /dd/defs/scf.d):00187         PD.INT         RMB       1                   Keyboard interrupt character (CTRL-C)
0031                  (   /dd/defs/scf.d):00188         PD.QUT         RMB       1                   Keyboard quit character (CTRL-E)
0032                  (   /dd/defs/scf.d):00189         PD.BSE         RMB       1                   Backspace echo character
0033                  (   /dd/defs/scf.d):00190         PD.OVF         RMB       1                   Line overflow character (BELL)
0034                  (   /dd/defs/scf.d):00191         PD.PAR         RMB       1                   Parity code
0035                  (   /dd/defs/scf.d):00192         PD.BAU         RMB       1                   ACIA baud rate (Color Computer)
0036                  (   /dd/defs/scf.d):00193         PD.D2P         RMB       2                   Offset of DEV2 name
0038                  (   /dd/defs/scf.d):00194         PD.XON         RMB       1                   ACIA X-ON character
0039                  (   /dd/defs/scf.d):00195         PD.XOFF        RMB       1                   ACIA X-OFF character
     001A             (   /dd/defs/scf.d):00196         OPTCNT         EQU       .-PD.OPT            Total user settable options
003A                  (   /dd/defs/scf.d):00197         PD.ERR         RMB       1                   Most recent I/O error status
003B                  (   /dd/defs/scf.d):00198         PD.TBL         RMB       2                   Device table addr (copy)
003D                  (   /dd/defs/scf.d):00199         PD.PLP         RMB       2                   Path Descriptor List Pointer
003F                  (   /dd/defs/scf.d):00200         PD.PST         RMB       1                   Current path status
                      (   /dd/defs/scf.d):00201         
                      (   /dd/defs/scf.d):00202         
                      (   /dd/defs/scf.d):00203         * PD.PST values Path Descriptor Status byte
                      (   /dd/defs/scf.d):00204         *
     0001             (   /dd/defs/scf.d):00205         PST.DCD        EQU       %00000001           Set if DCD is lost on Serial port
                      (   /dd/defs/scf.d):00206         
                      (   /dd/defs/scf.d):00207         
                      (   /dd/defs/scf.d):00208         * PD.PAR definitions
                      (   /dd/defs/scf.d):00209         *
                      (   /dd/defs/scf.d):00210         * Parity
     0000             (   /dd/defs/scf.d):00211         PARNONE        EQU       %00000000
     0020             (   /dd/defs/scf.d):00212         PARODD         EQU       %00100000
     0060             (   /dd/defs/scf.d):00213         PAREVEN        EQU       %01100000
     00A0             (   /dd/defs/scf.d):00214         PARMARK        EQU       %10100000
     00E0             (   /dd/defs/scf.d):00215         PARSPACE       EQU       %11100000
     00E0             (   /dd/defs/scf.d):00216         PARMASK        EQU       %11100000
                      (   /dd/defs/scf.d):00217         
                      (   /dd/defs/scf.d):00218         * PD.BAU definitions
                      (   /dd/defs/scf.d):00219         *
                      (   /dd/defs/scf.d):00220         * Baud rate
     0000             (   /dd/defs/scf.d):00221         B110           EQU       %00000000
     0001             (   /dd/defs/scf.d):00222         B300           EQU       %00000001
     0002             (   /dd/defs/scf.d):00223         B600           EQU       %00000010
     0003             (   /dd/defs/scf.d):00224         B1200          EQU       %00000011
     0004             (   /dd/defs/scf.d):00225         B2400          EQU       %00000100
     0005             (   /dd/defs/scf.d):00226         B4800          EQU       %00000101
     0006             (   /dd/defs/scf.d):00227         B9600          EQU       %00000110
     0007             (   /dd/defs/scf.d):00228         B19200         EQU       %00000111
     0008             (   /dd/defs/scf.d):00229         B38400         EQU       %00001000
     0009             (   /dd/defs/scf.d):00230         B57600         EQU       %00001001
     000A             (   /dd/defs/scf.d):00231         B115200        EQU       %00001010
                      (   /dd/defs/scf.d):00232         * Word size
     0000             (   /dd/defs/scf.d):00233         WORD8          EQU       %00000000
     0020             (   /dd/defs/scf.d):00234         WORD7          EQU       %00100000
                      (   /dd/defs/scf.d):00235         * Stop bits
     0000             (   /dd/defs/scf.d):00236         STOP1          EQU       %00000000
     0010             (   /dd/defs/scf.d):00237         STOP2          EQU       %00010000
                      (   /dd/defs/scf.d):00238         
                      ( /dd/defs/deffile):00009                  use   /dd/defs/coco.d
                      (  /dd/defs/coco.d):00001         ********************************************************************
                      (  /dd/defs/coco.d):00002         * CoCoDefs - NitrOS-9 System Definitions for the Tandy Color Computer
                      (  /dd/defs/coco.d):00003         *
                      (  /dd/defs/coco.d):00004         * $Id$
                      (  /dd/defs/coco.d):00005         *
                      (  /dd/defs/coco.d):00006         * Edt/Rev  YYYY/MM/DD  Modified by
                      (  /dd/defs/coco.d):00007         * Comment
                      (  /dd/defs/coco.d):00008         * ------------------------------------------------------------------
                      (  /dd/defs/coco.d):00009         *          1998/10/13  Boisy G. Pitre
                      (  /dd/defs/coco.d):00010         * Added defs by Bruce Isted from his Eliminator archive.
                      (  /dd/defs/coco.d):00011         *
                      (  /dd/defs/coco.d):00012         *          1998/10/31  Boisy G. Pitre
                      (  /dd/defs/coco.d):00013         * Merged cc3global.defs into this file.
                      (  /dd/defs/coco.d):00014         *
                      (  /dd/defs/coco.d):00015         *          2002/04/30  Boisy G. Pitre
                      (  /dd/defs/coco.d):00016         * Merged Level One and Level Two sysdefs.
                      (  /dd/defs/coco.d):00017         *
                      (  /dd/defs/coco.d):00018         *          2002/06/22  Boisy G. Pitre
                      (  /dd/defs/coco.d):00019         * Removed PIA.U4 and PIA.U8, improved comments
                      (  /dd/defs/coco.d):00020         *
                      (  /dd/defs/coco.d):00021         *          2003/11/05  Robert Gault
                      (  /dd/defs/coco.d):00022         * Made changes in window globals and grfdrv memory to handle regW
                      (  /dd/defs/coco.d):00023         * in 6809 systems.
                      (  /dd/defs/coco.d):00024         *
                      (  /dd/defs/coco.d):00025         *          2003/11/30  Boisy G. Pitre
                      (  /dd/defs/coco.d):00026         * Statics now are prefaced with V. to identify them easier in source.
                      (  /dd/defs/coco.d):00027         *
                      (  /dd/defs/coco.d):00028         *          2004/07/18  Boisy G. Pitre
                      (  /dd/defs/coco.d):00029         * Moved CoCo 3 Window stuff into cc3iodefs
                      (  /dd/defs/coco.d):00030         *
                      (  /dd/defs/coco.d):00031         *          2012/02/24  Boisy G. Pitre
                      (  /dd/defs/coco.d):00032         * Consolidated all CoCo-specific defs files into here.
                      (  /dd/defs/coco.d):00033         
                      (  /dd/defs/coco.d):00034                        NAM       CoCoDefs
                      (  /dd/defs/coco.d):00035                        TTL       NitrOS-9 Level 2 System Type Definitions
                      (  /dd/defs/coco.d):00036         
                      (  /dd/defs/coco.d):00037         
                      (  /dd/defs/coco.d):00038         **********************
                      (  /dd/defs/coco.d):00039         * CPU Type Definitions
                      (  /dd/defs/coco.d):00040         *
     0001             (  /dd/defs/coco.d):00041         Color          SET       1
     0002             (  /dd/defs/coco.d):00042         Color3         SET       2
     0002             (  /dd/defs/coco.d):00043         CPUType        SET       Color3
                      (  /dd/defs/coco.d):00044         
                      (  /dd/defs/coco.d):00045         
                      (  /dd/defs/coco.d):00046         ******************************
                      (  /dd/defs/coco.d):00047         * Clock Speed Type Definitions
                      (  /dd/defs/coco.d):00048         *
     0001             (  /dd/defs/coco.d):00049         OneMHz         EQU       1
     0002             (  /dd/defs/coco.d):00050         TwoMHz         EQU       2
     0002             (  /dd/defs/coco.d):00051         CPUSpeed       SET       TwoMHz
                      (  /dd/defs/coco.d):00052         
                      (  /dd/defs/coco.d):00053         
                      (  /dd/defs/coco.d):00054         **********************************
                      (  /dd/defs/coco.d):00055         * Power Line Frequency Definitions
                      (  /dd/defs/coco.d):00056         *
     0001             (  /dd/defs/coco.d):00057         Hz50           EQU       1                   Assemble clock for 50 hz power
     0002             (  /dd/defs/coco.d):00058         Hz60           EQU       2                   Assemble clock for 60 hz power
     0002             (  /dd/defs/coco.d):00059         PwrLnFrq       SET       Hz60                Set to Appropriate freq
                      (  /dd/defs/coco.d):00060         
                      (  /dd/defs/coco.d):00061         
                      (  /dd/defs/coco.d):00062         **********************************
                      (  /dd/defs/coco.d):00063         * Ticks per second
                      (  /dd/defs/coco.d):00064         *
     003C             (  /dd/defs/coco.d):00065         TkPerSec       SET       60
                      (  /dd/defs/coco.d):00066         
                      (  /dd/defs/coco.d):00067         
                      (  /dd/defs/coco.d):00068         ******************
                      (  /dd/defs/coco.d):00069         * ACIA type set up
                      (  /dd/defs/coco.d):00070         *
                      (  /dd/defs/coco.d):00071                        ORG       1
0001                  (  /dd/defs/coco.d):00072         ACIA6850       RMB       1                   MC6850 acia.
0002                  (  /dd/defs/coco.d):00073         ACIA6551       RMB       1                   SY6551 acia.
0003                  (  /dd/defs/coco.d):00074         ACIA2661       RMB       1                   SC2661 acia.
     0002             (  /dd/defs/coco.d):00075         ACIATYPE       SET       ACIA6551
                      (  /dd/defs/coco.d):00076         
                      (  /dd/defs/coco.d):00077         
                      (  /dd/defs/coco.d):00078         ****************************************
                      (  /dd/defs/coco.d):00079         * Special character Bit position equates
                      (  /dd/defs/coco.d):00080         *
     0001             (  /dd/defs/coco.d):00081         SHIFTBIT       EQU       %00000001
     0002             (  /dd/defs/coco.d):00082         CNTRLBIT       EQU       %00000010
     0004             (  /dd/defs/coco.d):00083         ALTERBIT       EQU       %00000100
     0008             (  /dd/defs/coco.d):00084         UPBIT          EQU       %00001000
     0010             (  /dd/defs/coco.d):00085         DOWNBIT        EQU       %00010000
     0020             (  /dd/defs/coco.d):00086         LEFTBIT        EQU       %00100000
     0040             (  /dd/defs/coco.d):00087         RIGHTBIT       EQU       %01000000
     0080             (  /dd/defs/coco.d):00088         SPACEBIT       EQU       %10000000
                      (  /dd/defs/coco.d):00089         
                      (  /dd/defs/coco.d):00090         
                      (  /dd/defs/coco.d):00091         ******************
                      (  /dd/defs/coco.d):00092         * Device addresses for miscellaneous hardware
                      (  /dd/defs/coco.d):00093         *
     FF68             (  /dd/defs/coco.d):00094         A.AciaP        SET       $FF68               Aciapak Address
     FF6C             (  /dd/defs/coco.d):00095         A.ModP         SET       $FF6C               ModPak Address
     FF40             (  /dd/defs/coco.d):00096         DPort          SET       $FF40               Disk controller base address
     FF7F             (  /dd/defs/coco.d):00097         MPI.Slct       SET       $FF7F               Multi-Pak slot select
     0003             (  /dd/defs/coco.d):00098         MPI.Slot       SET       $03                 Multi-Pak default slot
     FF00             (  /dd/defs/coco.d):00099         PIA0Base       EQU       $FF00
     FF20             (  /dd/defs/coco.d):00100         PIA1Base       EQU       $FF20
                      (  /dd/defs/coco.d):00101         
                      (  /dd/defs/coco.d):00102         
                      (  /dd/defs/coco.d):00103         ******************
                      (  /dd/defs/coco.d):00104         * VDG Devices
                      (  /dd/defs/coco.d):00105         *
     FFC0             (  /dd/defs/coco.d):00106         A.TermV        SET       $FFC0               VDG Term
     FFC1             (  /dd/defs/coco.d):00107         A.V1           SET       $FFC1               Possible additional VDG Devices
     FFC2             (  /dd/defs/coco.d):00108         A.V2           SET       $FFC2
     FFC3             (  /dd/defs/coco.d):00109         A.V3           SET       $FFC3
     FFC4             (  /dd/defs/coco.d):00110         A.V4           SET       $FFC4
     FFC5             (  /dd/defs/coco.d):00111         A.V5           SET       $FFC5
     FFC6             (  /dd/defs/coco.d):00112         A.V6           SET       $FFC6
     FFC7             (  /dd/defs/coco.d):00113         A.V7           SET       $FFC7
                      (  /dd/defs/coco.d):00114         
                      (  /dd/defs/coco.d):00115         
                      (  /dd/defs/coco.d):00116         
                      (  /dd/defs/coco.d):00117         ********************************
                      (  /dd/defs/coco.d):00118         * Boot defs for NitrOS-9 Level 1
                      (  /dd/defs/coco.d):00119         *
                      (  /dd/defs/coco.d):00120         * These defs are not strictly for 'Boot', but are for booting the
                      (  /dd/defs/coco.d):00121         * system.
                      (  /dd/defs/coco.d):00122         *
                      (  /dd/defs/coco.d):00123         
                      (  /dd/defs/coco.d):00124         
                      (  /dd/defs/coco.d):00125         ******************************************
                      (  /dd/defs/coco.d):00126         * Boot defs for NitrOS-9 Level 2 and above
                      (  /dd/defs/coco.d):00127         *
                      (  /dd/defs/coco.d):00128         * These defs are not strictly for 'Boot', but are for booting the
                      (  /dd/defs/coco.d):00129         * system.
                      (  /dd/defs/coco.d):00130         *
     ED00             (  /dd/defs/coco.d):00131         Bt.Start       SET       $ED00               Start address of the boot track in memory
     003B             (  /dd/defs/coco.d):00132         Bt.Block       EQU       $3B                 Block to map in for the 'OS9BOOT' screen
     8A34             (  /dd/defs/coco.d):00133         Bt.Flag        EQU       $8A34               Flag in Bt.Block to verify that it's unchanged
     0002             (  /dd/defs/coco.d):00134         Bt.Offst       EQU       2                   Offset into the screen where the current ptr is
                      (  /dd/defs/coco.d):00135         
                      (  /dd/defs/coco.d):00136         
                      (  /dd/defs/coco.d):00137         * On the CoCo, the boot track is all of track 34
                      (  /dd/defs/coco.d):00138         
     0022             (  /dd/defs/coco.d):00139         Bt.Track       EQU       34                  Boot track
     0000             (  /dd/defs/coco.d):00140         Bt.Sec         EQU       0                   Start LSN of boot area on boot track
                      (  /dd/defs/coco.d):00141         
                      (  /dd/defs/coco.d):00142         
     1080             (  /dd/defs/coco.d):00143         Bt.Size        EQU       $1080               Maximum size of bootfile
                      (  /dd/defs/coco.d):00144         
                      (  /dd/defs/coco.d):00145         
                      (  /dd/defs/coco.d):00146         
                      (  /dd/defs/coco.d):00147         *************************************************
                      (  /dd/defs/coco.d):00148         *
                      (  /dd/defs/coco.d):00149         * NitrOS-9 Level 1 Section
                      (  /dd/defs/coco.d):00150         *
                      (  /dd/defs/coco.d):00151         *************************************************
                      (  /dd/defs/coco.d):00152         
                      (  /dd/defs/coco.d):00153         
                      (  /dd/defs/coco.d):00154         
                      (  /dd/defs/coco.d):00155         *************************************************
                      (  /dd/defs/coco.d):00156         *
                      (  /dd/defs/coco.d):00157         * NitrOS-9 Level 2 Section
                      (  /dd/defs/coco.d):00158         *
                      (  /dd/defs/coco.d):00159         *************************************************
                      (  /dd/defs/coco.d):00160         
                      (  /dd/defs/coco.d):00161         ****************************************
                      (  /dd/defs/coco.d):00162         * Dynamic Address Translator Definitions
                      (  /dd/defs/coco.d):00163         *
     0008             (  /dd/defs/coco.d):00164         DAT.BlCt       EQU       8                   D.A.T. blocks/address space
     2000             (  /dd/defs/coco.d):00165         DAT.BlSz       EQU       (256/DAT.BlCt)*256  D.A.T. block size
     0010             (  /dd/defs/coco.d):00166         DAT.ImSz       EQU       DAT.BlCt*2          D.A.T. Image size
     FFE0             (  /dd/defs/coco.d):00167         DAT.Addr       EQU       -(DAT.BlSz/256)     D.A.T. MSB Address bits
     FF91             (  /dd/defs/coco.d):00168         DAT.Task       EQU       $FF91               Task Register address
     0020             (  /dd/defs/coco.d):00169         DAT.TkCt       EQU       32                  Number of DAT Tasks
     FFA0             (  /dd/defs/coco.d):00170         DAT.Regs       EQU       $FFA0               DAT Block Registers base address
     333E             (  /dd/defs/coco.d):00171         DAT.Free       EQU       $333E               Free Block Number
     003F             (  /dd/defs/coco.d):00172         DAT.BlMx       EQU       $3F                 Maximum Block number
     0040             (  /dd/defs/coco.d):00173         DAT.BMSz       EQU       $40                 Memory Block Map size
     0000             (  /dd/defs/coco.d):00174         DAT.WrPr       EQU       0                   no write protect
     0000             (  /dd/defs/coco.d):00175         DAT.WrEn       EQU       0                   no write enable
     0000             (  /dd/defs/coco.d):00176         SysTask        EQU       0                   Coco System Task number
     003F             (  /dd/defs/coco.d):00177         IOBlock        EQU       $3F
     003F             (  /dd/defs/coco.d):00178         ROMBlock       EQU       $3F
     007F             (  /dd/defs/coco.d):00179         IOAddr         EQU       $7F
     0001             (  /dd/defs/coco.d):00180         ROMCount       EQU       1                   number of blocks of ROM (High RAM Block)
     0001             (  /dd/defs/coco.d):00181         RAMCount       EQU       1                   initial blocks of RAM
     0005             (  /dd/defs/coco.d):00182         MoveBlks       EQU       DAT.BlCt-ROMCount-2 Block numbers used for copies
     0001             (  /dd/defs/coco.d):00183         BlockTyp       EQU       1                   chk only first bytes of RAM block
     0002             (  /dd/defs/coco.d):00184         ByteType       EQU       2                   chk entire block of RAM
     0001             (  /dd/defs/coco.d):00185         Limited        EQU       1                   chk only upper memory for ROM modules
     0002             (  /dd/defs/coco.d):00186         UnLimitd       EQU       2                   chk all NotRAM for modules
                      (  /dd/defs/coco.d):00187         * NOTE: this check assumes any NotRAM with a module will
                      (  /dd/defs/coco.d):00188         *       always start with $87CD in first two bytes of block
     0001             (  /dd/defs/coco.d):00189         RAMCheck       EQU       BlockTyp            chk only beg bytes of block
     0001             (  /dd/defs/coco.d):00190         ROMCheck       EQU       Limited             chk only upper few blocks for ROM
     003F             (  /dd/defs/coco.d):00191         LastRAM        EQU       IOBlock             maximum RAM block number
                      (  /dd/defs/coco.d):00192         
                      (  /dd/defs/coco.d):00193         ***************************
                      (  /dd/defs/coco.d):00194         * Color Computer 3 Specific
                      (  /dd/defs/coco.d):00195         *
     0001             (  /dd/defs/coco.d):00196         MappedIO       EQU       true                (Actually False but it works better this way)
                      (  /dd/defs/coco.d):00197         
                      (  /dd/defs/coco.d):00198         ********************
                      (  /dd/defs/coco.d):00199         * Hardware addresses
                      (  /dd/defs/coco.d):00200         *
     FF00             (  /dd/defs/coco.d):00201         GIMERegs       EQU       $FF00               Base address of GIME registers
     FF92             (  /dd/defs/coco.d):00202         IrqEnR         EQU       $FF92               GIME IRQ enable/status register
     FF9A             (  /dd/defs/coco.d):00203         BordReg        EQU       $FF9A               Border color register
     FFB0             (  /dd/defs/coco.d):00204         PalAdr         EQU       $FFB0               Palette registers
                      (  /dd/defs/coco.d):00205         
     0007             (  /dd/defs/coco.d):00206         HW.Page        SET       $07                 Device descriptor hardware page
                      (  /dd/defs/coco.d):00207         
                      (  /dd/defs/coco.d):00208         * KrnBlk defines the block number of the 8K RAM block that is mapped to
                      (  /dd/defs/coco.d):00209         * the top of CPU address space ($E000-$FFFF) for the system process, and
                      (  /dd/defs/coco.d):00210         * which holds the Kernel. The top 2 pages of this CPU address space ($FFE0-
                      (  /dd/defs/coco.d):00211         * $FFFF) has two special properties. Firstly, it contains the I/O space.
                      (  /dd/defs/coco.d):00212         * Secondly, the parts that contain RAM map are not affected by the DAT
                      (  /dd/defs/coco.d):00213         * mappings but, instead, *always* map that RAM to a fixed RAM block
                      (  /dd/defs/coco.d):00214         * (KrnBlk). When a user process is mapped in, and requests enough memory,
                      (  /dd/defs/coco.d):00215         * it will end up with its own block assigned for CPU address space $E000-
                      (  /dd/defs/coco.d):00216         * $FFFF but the top of the address space is unusable by the user process:
                      (  /dd/defs/coco.d):00217         * it still contains the I/O and the bit of RAM that's mapped to KrnBlk.
                      (  /dd/defs/coco.d):00218         * Usually, the value of KrnBlk is fixed for a particular hardware design;
                      (  /dd/defs/coco.d):00219         * For the COCO GIME, it's always $3F.
     003F             (  /dd/defs/coco.d):00220         KrnBlk         SET       $3F
                      (  /dd/defs/coco.d):00221         
                      (  /dd/defs/coco.d):00222         
                      ( /dd/defs/deffile):00010                  use   /dd/defs/cocovtio.d
                      (/dd/defs/cocovtio):00001         ********************************************************************
                      (/dd/defs/cocovtio):00002         * VTIODefs - Video Terminal I/O Definitions for CoCo 3
                      (/dd/defs/cocovtio):00003         *
                      (/dd/defs/cocovtio):00004         * $Id$
                      (/dd/defs/cocovtio):00005         *
                      (/dd/defs/cocovtio):00006         * Edt/Rev  YYYY/MM/DD  Modified by
                      (/dd/defs/cocovtio):00007         * Comment
                      (/dd/defs/cocovtio):00008         * ------------------------------------------------------------------
                      (/dd/defs/cocovtio):00009         *          2004/07/18  Boisy G. Pitre
                      (/dd/defs/cocovtio):00010         * Started from systype
                      (/dd/defs/cocovtio):00011         
                      (/dd/defs/cocovtio):00012                        NAM       VTIODefs
                      (/dd/defs/cocovtio):00013                        TTL       Video Terminal I/O Definitions for CoCo 3
                      (/dd/defs/cocovtio):00014         
                      (/dd/defs/cocovtio):00015         * Max size of Get/Put buffer to copy between user and grfdrv. There is room for up to 128, but
                      (/dd/defs/cocovtio):00016         *   we may use some of that for other things. Leaving at OS-9 Level II default (72) for now.
                      (/dd/defs/cocovtio):00017         * May try increasing to higher (maybe 96?) to see if it makes a noticable difference GPLoading
                      (/dd/defs/cocovtio):00018         * fonts, etc. in EOU bootup.
                      (/dd/defs/cocovtio):00019         
     0048             (/dd/defs/cocovtio):00020         gb0000         EQU       72                  Size of get/put buffer ($48)
                      (/dd/defs/cocovtio):00021         
                      (/dd/defs/cocovtio):00022         ****************
                      (/dd/defs/cocovtio):00023         * Window Devices
                      (/dd/defs/cocovtio):00024         *
                      (/dd/defs/cocovtio):00025                        ORG       $FF9F
FF9F                  (/dd/defs/cocovtio):00026         A.W            RMB       1                   $FF9F Generic Window Descriptor
FFA0                  (/dd/defs/cocovtio):00027         A.TermW        RMB       1                   $FFA0 Windowing Term
FFA1                  (/dd/defs/cocovtio):00028         A.W1           RMB       1                   $FFA1
FFA2                  (/dd/defs/cocovtio):00029         A.W2           RMB       1                   $FFA2
FFA3                  (/dd/defs/cocovtio):00030         A.W3           RMB       1                   $FFA3
FFA4                  (/dd/defs/cocovtio):00031         A.W4           RMB       1                   $FFA4
FFA5                  (/dd/defs/cocovtio):00032         A.W5           RMB       1                   $FFA5
FFA6                  (/dd/defs/cocovtio):00033         A.W6           RMB       1                   $FFA6
FFA7                  (/dd/defs/cocovtio):00034         A.W7           RMB       1                   $FFA7
FFA8                  (/dd/defs/cocovtio):00035         A.W8           RMB       1                   $FFA8
FFA9                  (/dd/defs/cocovtio):00036         A.W9           RMB       1                   $FFA9
FFAA                  (/dd/defs/cocovtio):00037         A.W10          RMB       1                   $FFAA
FFAB                  (/dd/defs/cocovtio):00038         A.W11          RMB       1                   $FFAB
FFAC                  (/dd/defs/cocovtio):00039         A.W12          RMB       1                   $FFAC
FFAD                  (/dd/defs/cocovtio):00040         A.W13          RMB       1                   $FFAD
FFAE                  (/dd/defs/cocovtio):00041         A.W14          RMB       1                   $FFAE
FFAF                  (/dd/defs/cocovtio):00042         A.W15          RMB       1                   $FFAF
                      (/dd/defs/cocovtio):00043         
                      (/dd/defs/cocovtio):00044         **********************************
                      (/dd/defs/cocovtio):00045         * Pointer Device Packet Definition
                      (/dd/defs/cocovtio):00046         *
                      (/dd/defs/cocovtio):00047                        ORG       0
0000                  (/dd/defs/cocovtio):00048         Pt.Valid       RMB       1                   Is returned info valid (0=no/1=yes)
0001                  (/dd/defs/cocovtio):00049         Pt.Actv        RMB       1                   Active Side 0=off/1=Right/2=left
0002                  (/dd/defs/cocovtio):00050         Pt.ToTm        RMB       1                   Time out Initial value
0003                  (/dd/defs/cocovtio):00051                        RMB       2                   reserved
0005                  (/dd/defs/cocovtio):00052         Pt.TTTo        RMB       1                   Time Till Timeout
0006                  (/dd/defs/cocovtio):00053         Pt.TSSt        RMB       2                   Time Since Start Counter
0008                  (/dd/defs/cocovtio):00054         Pt.CBSA        RMB       1                   Current Button State Button A
0009                  (/dd/defs/cocovtio):00055         Pt.CBSB        RMB       1                   Current Button State Button B
000A                  (/dd/defs/cocovtio):00056         Pt.CCtA        RMB       1                   Click Count Button A
000B                  (/dd/defs/cocovtio):00057         Pt.CCtB        RMB       1                   Click Count Button B
000C                  (/dd/defs/cocovtio):00058         Pt.TTSA        RMB       1                   Time This State Counter Button A
000D                  (/dd/defs/cocovtio):00059         Pt.TTSB        RMB       1                   Time This State Counter Button B
000E                  (/dd/defs/cocovtio):00060         Pt.TLSA        RMB       1                   Time Last State Counter Button A
000F                  (/dd/defs/cocovtio):00061         Pt.TLSB        RMB       1                   Time Last State Counter Button B
0010                  (/dd/defs/cocovtio):00062                        RMB       2                   Reserved
0012                  (/dd/defs/cocovtio):00063         Pt.BDX         RMB       2                   Button down X value EXPERIMENTAL
0014                  (/dd/defs/cocovtio):00064         Pt.BDY         RMB       2                   Button down Y value
0016                  (/dd/defs/cocovtio):00065         Pt.Stat        RMB       1                   Window Pointer type location
0017                  (/dd/defs/cocovtio):00066         Pt.Res         RMB       1                   Resolution (0..640 by: 0=ten/1=one)
0018                  (/dd/defs/cocovtio):00067         Pt.AcX         RMB       2                   Actual X Value
001A                  (/dd/defs/cocovtio):00068         Pt.AcY         RMB       2                   Actual Y Value
001C                  (/dd/defs/cocovtio):00069         Pt.WRX         RMB       2                   Window Relative X
001E                  (/dd/defs/cocovtio):00070         Pt.WRY         RMB       2                   Window Relative Y
     0020             (/dd/defs/cocovtio):00071         Pt.Siz         EQU       .                   Packet Size 32 bytes
                      (/dd/defs/cocovtio):00072         
                      (/dd/defs/cocovtio):00073         **************************
                      (/dd/defs/cocovtio):00074         * window regions for mouse
                      (/dd/defs/cocovtio):00075         *
     0000             (/dd/defs/cocovtio):00076         WR.Cntnt       EQU       0                   content region
     0001             (/dd/defs/cocovtio):00077         WR.Cntrl       EQU       1                   control region
     0002             (/dd/defs/cocovtio):00078         WR.OfWin       EQU       2                   off window
                      (/dd/defs/cocovtio):00079         
                      (/dd/defs/cocovtio):00080         *************************************
                      (/dd/defs/cocovtio):00081         * Standard system get/put buffer defs
                      (/dd/defs/cocovtio):00082         *
                      (/dd/defs/cocovtio):00083         *
                      (/dd/defs/cocovtio):00084         * system group numbers
                      (/dd/defs/cocovtio):00085         *
                      (/dd/defs/cocovtio):00086                        ORG       200
00C8                  (/dd/defs/cocovtio):00087         Grp.Fnt        RMB       1                   font group
00C9                  (/dd/defs/cocovtio):00088         Grp.Clip       RMB       1                   clipboard group
00CA                  (/dd/defs/cocovtio):00089         Grp.Ptr        RMB       1                   pointer group
00CB                  (/dd/defs/cocovtio):00090         Grp.Pat2       RMB       1                   pattern group 2 color
00CC                  (/dd/defs/cocovtio):00091         Grp.Pat4       RMB       1                   pattern group 4 color
00CD                  (/dd/defs/cocovtio):00092         Grp.Pat6       RMB       1                   pattern group 16 color
                      (/dd/defs/cocovtio):00093         *
                      (/dd/defs/cocovtio):00094         * font buffer numbers
                      (/dd/defs/cocovtio):00095         *
                      (/dd/defs/cocovtio):00096                        ORG       1
0001                  (/dd/defs/cocovtio):00097         Fnt.S8x8       RMB       1                   standard 8x8 font
0002                  (/dd/defs/cocovtio):00098         Fnt.S6x8       RMB       1                   standard 6x8 font
0003                  (/dd/defs/cocovtio):00099         Fnt.G8x8       RMB       1                   standard graphics 8x8 font
                      (/dd/defs/cocovtio):00100         *
                      (/dd/defs/cocovtio):00101         * pattern buffer numbers
                      (/dd/defs/cocovtio):00102         *
                      (/dd/defs/cocovtio):00103                        ORG       1
0001                  (/dd/defs/cocovtio):00104         Pat.Dot        RMB       1
0002                  (/dd/defs/cocovtio):00105         Pat.Vrt        RMB       1
0003                  (/dd/defs/cocovtio):00106         Pat.Hrz        RMB       1
0004                  (/dd/defs/cocovtio):00107         Pat.XHtc       RMB       1
0005                  (/dd/defs/cocovtio):00108         Pat.LSnt       RMB       1
0006                  (/dd/defs/cocovtio):00109         Pat.RSnt       RMB       1
0007                  (/dd/defs/cocovtio):00110         Pat.SDot       RMB       1
0008                  (/dd/defs/cocovtio):00111         Pat.BDot       RMB       1
                      (/dd/defs/cocovtio):00112         *
                      (/dd/defs/cocovtio):00113         * pointer buffer numbers
                      (/dd/defs/cocovtio):00114         *
                      (/dd/defs/cocovtio):00115                        ORG       1
0001                  (/dd/defs/cocovtio):00116         Ptr.Arr        RMB       1                   Arrow pointer
0002                  (/dd/defs/cocovtio):00117         Ptr.Pen        RMB       1                   Pencil pointer
0003                  (/dd/defs/cocovtio):00118         Ptr.LCH        RMB       1                   Large cross hair pointer
0004                  (/dd/defs/cocovtio):00119         Ptr.Slp        RMB       1                   Wait timer pointer
0005                  (/dd/defs/cocovtio):00120         Ptr.Ill        RMB       1                   Illegal action pointer
0006                  (/dd/defs/cocovtio):00121         Ptr.Txt        RMB       1                   Text pointer
0007                  (/dd/defs/cocovtio):00122         Ptr.SCH        RMB       1                   Small cross hair pointer
                      (/dd/defs/cocovtio):00123         
                      (/dd/defs/cocovtio):00124         **********************
                      (/dd/defs/cocovtio):00125         * KeyDrv Entry Points
                      (/dd/defs/cocovtio):00126                        ORG       0
0000                  (/dd/defs/cocovtio):00127         K$Init         RMB       3                   joystick initialization
0003                  (/dd/defs/cocovtio):00128         K$Term         RMB       3                   joystick termination
0006                  (/dd/defs/cocovtio):00129         K$FnKey        RMB       3                   get function key states
0009                  (/dd/defs/cocovtio):00130         K$RdKey        RMB       3                   get key states
                      (/dd/defs/cocovtio):00131         
                      (/dd/defs/cocovtio):00132         **********************
                      (/dd/defs/cocovtio):00133         * JoyDrv Entry Points
                      (/dd/defs/cocovtio):00134                        ORG       0
0000                  (/dd/defs/cocovtio):00135         J$Init         RMB       3                   joystick initialization
0003                  (/dd/defs/cocovtio):00136         J$Term         RMB       3                   joystick termination
0006                  (/dd/defs/cocovtio):00137         J$MsBtn        RMB       3                   get mouse button states
0009                  (/dd/defs/cocovtio):00138         J$MsXY         RMB       3                   get mouse X/Y coordinates
000C                  (/dd/defs/cocovtio):00139         J$JyBtn        RMB       3                   get joystick button states
000F                  (/dd/defs/cocovtio):00140         J$JyXY         RMB       3                   get joystick X/Y coordinates
                      (/dd/defs/cocovtio):00141         
                      (/dd/defs/cocovtio):00142         **********************
                      (/dd/defs/cocovtio):00143         * SndDrv Entry Points
                      (/dd/defs/cocovtio):00144                        ORG       0
0000                  (/dd/defs/cocovtio):00145         S$Init         RMB       3                   joystick initialization
0003                  (/dd/defs/cocovtio):00146         S$GetStt       RMB       3                   joystick termination
0006                  (/dd/defs/cocovtio):00147         S$SetStt       RMB       3                   joystick termination
0009                  (/dd/defs/cocovtio):00148         S$Term         RMB       3                   get joystick X/Y coordinates
                      (/dd/defs/cocovtio):00149         
                      (/dd/defs/cocovtio):00150         ********************************
                      (/dd/defs/cocovtio):00151         * Window/Menu Bar Data Structure
                      (/dd/defs/cocovtio):00152         *
                      (/dd/defs/cocovtio):00153         * To be used in SS.WnSet SETSTAT to set up a Framed Window
                      (/dd/defs/cocovtio):00154         * for use in the high level windowing package.
                      (/dd/defs/cocovtio):00155         *
     000A             (/dd/defs/cocovtio):00156         NUMMENS        EQU       10                  maximum number of menus on menu bar
     0014             (/dd/defs/cocovtio):00157         NUMITMS        EQU       20                  maximum number of items in a menu
     000F             (/dd/defs/cocovtio):00158         MXTTLEN        EQU       15                  max chars for menu and item names
     C0C0             (/dd/defs/cocovtio):00159         WINSYNC        EQU       $C0C0               synch bytes for window validation
                      (/dd/defs/cocovtio):00160         *
                      (/dd/defs/cocovtio):00161         * Menu Item Descriptor : (MN.ITEMS)
                      (/dd/defs/cocovtio):00162         * one required for each item within the menu
                      (/dd/defs/cocovtio):00163         *
                      (/dd/defs/cocovtio):00164                        ORG       0
0000                  (/dd/defs/cocovtio):00165         MI.TTL         RMB       MXTTLEN             item name
000F                  (/dd/defs/cocovtio):00166         MI.ENBL        RMB       1                   enable flag
0010                  (/dd/defs/cocovtio):00167         MI.RES         RMB       5                   reserved bytes
     0015             (/dd/defs/cocovtio):00168         MI.SIZ         EQU       .                   size of menu item descriptor
                      (/dd/defs/cocovtio):00169         *
                      (/dd/defs/cocovtio):00170         * Menu Descriptor :
                      (/dd/defs/cocovtio):00171         * one for each menu on the manu bar
                      (/dd/defs/cocovtio):00172         * each is pointed to by MB.MPTR below
                      (/dd/defs/cocovtio):00173         *
                      (/dd/defs/cocovtio):00174                        ORG       0
0000                  (/dd/defs/cocovtio):00175         MN.TTL         RMB       MXTTLEN             menu title
000F                  (/dd/defs/cocovtio):00176         MN.ID          RMB       1                   menu id number (1-255)
0010                  (/dd/defs/cocovtio):00177         MN.XSIZ        RMB       1                   horiz. size of desired pull down
0011                  (/dd/defs/cocovtio):00178         MN.NITS        RMB       1                   number of items in menu
0012                  (/dd/defs/cocovtio):00179         MN.ENBL        RMB       1                   enable flag
0013                  (/dd/defs/cocovtio):00180         MN.RES         RMB       2                   reserved bytes
0015                  (/dd/defs/cocovtio):00181         MN.ITEMS       RMB       2                   pointer to array of menu items
     0017             (/dd/defs/cocovtio):00182         MN.SIZ         EQU       .                   size of menu descriptor
                      (/dd/defs/cocovtio):00183         *
                      (/dd/defs/cocovtio):00184         * Window Descriptor:
                      (/dd/defs/cocovtio):00185         * one required for each application in a framed window
                      (/dd/defs/cocovtio):00186         *
                      (/dd/defs/cocovtio):00187                        ORG       0
0000                  (/dd/defs/cocovtio):00188         WN.TTL         RMB       20                  title of window for title bar
0014                  (/dd/defs/cocovtio):00189         WN.NMNS        RMB       1                   number of menus in menu bar
0015                  (/dd/defs/cocovtio):00190         WN.XMIN        RMB       1                   minimal horiz. size for application to run
0016                  (/dd/defs/cocovtio):00191         WN.YMIN        RMB       1                   minimal vert. size for application to run
0017                  (/dd/defs/cocovtio):00192         WN.SYNC        RMB       2                   synch bytes ($C0C0)
0019                  (/dd/defs/cocovtio):00193         WN.RES         RMB       7                   reserved bytes
0020                  (/dd/defs/cocovtio):00194         WN.BAR         RMB       2                   pointer to arry of menu descriptors
     0022             (/dd/defs/cocovtio):00195         WN.SIZ         EQU       .                   size of window/menu bar descriptor
                      (/dd/defs/cocovtio):00196         
                      (/dd/defs/cocovtio):00197         *************************
                      (/dd/defs/cocovtio):00198         * Window Type Definitions
                      (/dd/defs/cocovtio):00199         *
                      (/dd/defs/cocovtio):00200         * To be used in setting up the border of the window in
                      (/dd/defs/cocovtio):00201         * the SS.WnSel SETSTAT
                      (/dd/defs/cocovtio):00202         *
                      (/dd/defs/cocovtio):00203                        ORG       0
0000                  (/dd/defs/cocovtio):00204         WT.NBox        RMB       1                   No Box
0001                  (/dd/defs/cocovtio):00205         WT.FWin        RMB       1                   Framed Window
0002                  (/dd/defs/cocovtio):00206         WT.FSWin       RMB       1                   Framed Window w/Scroll Bars
0003                  (/dd/defs/cocovtio):00207         WT.SBox        RMB       1                   Shadowed Box
0004                  (/dd/defs/cocovtio):00208         WT.DBox        RMB       1                   Double Box
0005                  (/dd/defs/cocovtio):00209         WT.PBox        RMB       1                   Plain Box
                      (/dd/defs/cocovtio):00210         
                      (/dd/defs/cocovtio):00211         *************************************
                      (/dd/defs/cocovtio):00212         * Pre-Defined Menu IDs for the system
                      (/dd/defs/cocovtio):00213         *
                      (/dd/defs/cocovtio):00214                        ORG       1
0001                  (/dd/defs/cocovtio):00215         MId.Mov        RMB       1                   move box
0002                  (/dd/defs/cocovtio):00216         MId.Cls        RMB       1                   close box
0003                  (/dd/defs/cocovtio):00217         MId.Grw        RMB       1                   grow box
0004                  (/dd/defs/cocovtio):00218         MId.SUp        RMB       1                   scroll up
0005                  (/dd/defs/cocovtio):00219         MId.SDn        RMB       1                   scroll down
0006                  (/dd/defs/cocovtio):00220         MId.SRt        RMB       1                   scroll right
0007                  (/dd/defs/cocovtio):00221         MId.SLt        RMB       1                   scroll left
0008                  (/dd/defs/cocovtio):00222         MId.Chr        RMB       1                   character was depressed
                      (/dd/defs/cocovtio):00223                        ORG       20
0014                  (/dd/defs/cocovtio):00224         MId.Tdy        RMB       1                   Tandy menu
0015                  (/dd/defs/cocovtio):00225         MId.Fil        RMB       1                   Files Menu
0016                  (/dd/defs/cocovtio):00226         MId.Edt        RMB       1                   Edit Menu
0017                  (/dd/defs/cocovtio):00227         MId.Sty        RMB       1                   Styles menu
0018                  (/dd/defs/cocovtio):00228         MId.Fnt        RMB       1                   Font menu
                      (/dd/defs/cocovtio):00229         
                      (/dd/defs/cocovtio):00230         
                      (/dd/defs/cocovtio):00231         ******************************************************************************
                      (/dd/defs/cocovtio):00232         ******************************************************************************
                      (/dd/defs/cocovtio):00233         **                                                                          **
                      (/dd/defs/cocovtio):00234         ** NitrOS-9 Windowing system Global data definitions                        **
                      (/dd/defs/cocovtio):00235         **                                                                          **
                      (/dd/defs/cocovtio):00236         ******************************************************************************
                      (/dd/defs/cocovtio):00237         ******************************************************************************
                      (/dd/defs/cocovtio):00238         **                                                                          **
                      (/dd/defs/cocovtio):00239         ** System memory block 0 layout:                                            **
                      (/dd/defs/cocovtio):00240         **                                                                          **
                      (/dd/defs/cocovtio):00241         ** $0000-$0001 : FHL/Isted WD 1002-05 - interface base address              **
                      (/dd/defs/cocovtio):00242         ** $0002       : FHL/Isted WD 1002-05 - boot device physical drive #        **
                      (/dd/defs/cocovtio):00243         ** $0008       : Bruce Isted Serial mouse - button counter & rx count       **
                      (/dd/defs/cocovtio):00244         ** $0009-$000B : Bruce Isted Serial mouse - RX buffer                       **
                      (/dd/defs/cocovtio):00245         ** $000C-$000D : Bruce Isted Serial mouse - Current X position              **
                      (/dd/defs/cocovtio):00246         ** $000E-$000F : Bruce Isted Serial mouse - Current Y position              **
                      (/dd/defs/cocovtio):00247         ** $0010-$001F : unused (User definable)                                    **
                      (/dd/defs/cocovtio):00248         ** $0020-$00FF : system direct page & some IRQ vectors                      **
                      (/dd/defs/cocovtio):00249         ** $0100-$011F : Task usage table                                           **
                      (/dd/defs/cocovtio):00250         ** $0120-$01FF : Virtual DAT tasks (pointed to by <D.TskIPt)                **
                      (/dd/defs/cocovtio):00251         ** $0200-$02FF : memory block usage map ($80=Not RAM,$01=in use,$02=module) **
                      (/dd/defs/cocovtio):00252         ** $0300-$03FF : system's system call dispatch table                        **
                      (/dd/defs/cocovtio):00253         ** $0400-$04FF : user's sysem call dispatch table                           **
                      (/dd/defs/cocovtio):00254         ** $0500-$05FF : process descriptor pointer table                           **
                      (/dd/defs/cocovtio):00255         ** $0600-$07FF : System task (Task 0, ID 1) process descriptor              **
                      (/dd/defs/cocovtio):00256         ** $0800-$08FF : System's stack space (initial ptr is $0900)                **
                      (/dd/defs/cocovtio):00257         ** $0900-$09FF : SMAP table ($01=in used, $80=NOT RAM)                      **
                      (/dd/defs/cocovtio):00258         ** $0A00-$0FFF : module directory DAT Images (8 bytes each)                 **
                      (/dd/defs/cocovtio):00259         ** $1000-$10FF : System Global memory (pointed to by D.CCMem)               **
                      (/dd/defs/cocovtio):00260         ** $1100-$11FF : GRFDRV global memory (DP=$11 in GRFDRV)                    **
                      (/dd/defs/cocovtio):00261         ** $1200-$1247 : shared buffer between Grf/WindInt & GRFDRV (GP buffers)    **
                      (/dd/defs/cocovtio):00262         ** $1248-$127F : ????  (unused)                                             **
                      (/dd/defs/cocovtio):00263         ** $1280-$1A7F : the window tables (32 of $40 bytes each)                   **
                      (/dd/defs/cocovtio):00264         ** $1A80-$1C7F : the screen tables (16 of $20 bytes each)                   **
                      (/dd/defs/cocovtio):00265         ** $1C80-$2000 : the CC3 global mem stack (for windowing)                   **
                      (/dd/defs/cocovtio):00266         **                                                                          **
                      (/dd/defs/cocovtio):00267         ******************************************************************************
                      (/dd/defs/cocovtio):00268         ******************************************************************************
                      (/dd/defs/cocovtio):00269         
                      (/dd/defs/cocovtio):00270         * User settable values for VTIO/TC9IO/GrfInt/WindInt & GrfDrv
     0019             (/dd/defs/cocovtio):00271         MaxLines       EQU       25                  Max. Y coord text value
     0000             (/dd/defs/cocovtio):00272         Meg            SET       false               "true" if 1 or 2 meg machine
                      (/dd/defs/cocovtio):00273         
     0000             (/dd/defs/cocovtio):00274         COMP           EQU       0                   composite monitor
     0001             (/dd/defs/cocovtio):00275         RGB            EQU       1                   RGB Analog monitor 
     0002             (/dd/defs/cocovtio):00276         MONO           EQU       2                   monochrome monitor
                      (/dd/defs/cocovtio):00277         
     0001             (/dd/defs/cocovtio):00278         Monitor        SET       RGB
                      (/dd/defs/cocovtio):00279         
                      (/dd/defs/cocovtio):00280         * Global definitions
     0001             (/dd/defs/cocovtio):00281         KeyMse         EQU       %00000001           keyboard mouse enabled
     0002             (/dd/defs/cocovtio):00282         NumLck         EQU       %00000010           Numlock enabled (TC-9 use only)
     0004             (/dd/defs/cocovtio):00283         CapsLck        EQU       %00000100           Capslock enabled
     0280             (/dd/defs/cocovtio):00284         MaxRows        EQU       640                 maximum X co-ordinate allowed on mouse
                      (/dd/defs/cocovtio):00285                      IFEQ      MaxLines-25
     00C6             (/dd/defs/cocovtio):00286         MaxLine        EQU       198                 maximum Y co-ordinate allowed on mouse
                      (/dd/defs/cocovtio):00287                      ELSE      
0019                  (/dd/defs/cocovtio):00288         MaxLine        EQU       191                 maximum Y co-ordinate allowed on mouse
                      (/dd/defs/cocovtio):00289                      ENDC      
                      (/dd/defs/cocovtio):00290         
                      (/dd/defs/cocovtio):00291         *****************************************************************************
                      (/dd/defs/cocovtio):00292         * Static memory area for each window (VTIO/TC9IO)
                      (/dd/defs/cocovtio):00293         * Should set up a write buffer (using parm area?) between SCF, VTIO & Grfdrv
                      (/dd/defs/cocovtio):00294         * so we can 'burst mode' text output (copy up to 48 chars to Grfdrv's parm
                      (/dd/defs/cocovtio):00295         * area, and have grfdrv loop through & write all 48 chars to screen in 1 loop
                      (/dd/defs/cocovtio):00296         * May have to have smaller limit for text to gfx screens, as it will run much
                      (/dd/defs/cocovtio):00297         * slower, unless GrfDrv is made Partially/Fully Re-Entrant
                      (/dd/defs/cocovtio):00298         *
                      (/dd/defs/cocovtio):00299         * STRONG CAUTION:  scfdefs MUST be included first before this file if
                      (/dd/defs/cocovtio):00300         * V.SCF is to be resolved properly in pass 1!!
                      (/dd/defs/cocovtio):00301                        ORG       V.SCF
001D                  (/dd/defs/cocovtio):00302         V.WinType      RMB       1                   window type (0=Windint/GrfInt,2=VDGInt)      $1D
001E                  (/dd/defs/cocovtio):00303         V.InfVld       RMB       1                   Rest of info here valid? (0=NO, >0 = YES)    $1E
001F                  (/dd/defs/cocovtio):00304         V.DevPar       RMB       2                   high bit=window device                       $1F
0021                  (/dd/defs/cocovtio):00305         V.ULCase       RMB       1                   special key flags (Capslck & keyboard mouse) $21
0022                  (/dd/defs/cocovtio):00306         V.KySnsFlg     RMB       1                   flag for key sense setstat                   $22
0023                  (/dd/defs/cocovtio):00307         V.ScrChg       RMB       1                   screen change flag                           $23
0024                  (/dd/defs/cocovtio):00308         V.SSigID       RMB       1                   data ready process ID                        $24
0025                  (/dd/defs/cocovtio):00309         V.SSigSg       RMB       1                   data ready signal code                       $25
0026                  (/dd/defs/cocovtio):00310         V.MSigID       RMB       1                   mouse signal process ID                      $26
0027                  (/dd/defs/cocovtio):00311         V.MSigSg       RMB       1                   mouse signal signal code                     $27
0028                  (/dd/defs/cocovtio):00312         V.MSmpl        RMB       1                   mouse sample rate                            $28
0029                  (/dd/defs/cocovtio):00313         V.MTime        RMB       1                   mouse timeout value                          $29
002A                  (/dd/defs/cocovtio):00314                        RMB       1                   unused                                       $2A
002B                  (/dd/defs/cocovtio):00315         V.MAutoF       RMB       1                   auto follow mouse flag                       $2B
002C                  (/dd/defs/cocovtio):00316         V.ParmCnt      RMB       1                   parameter count                              $2C
002D                  (/dd/defs/cocovtio):00317         V.ParmVct      RMB       2                   parameter vector                             $2D
002F                  (/dd/defs/cocovtio):00318         V.PrmStrt      RMB       2                   pointer to params start                      $2F
0031                  (/dd/defs/cocovtio):00319         V.NxtPrm       RMB       2                   pointer to next param storage                $31
0033                  (/dd/defs/cocovtio):00320         V.EndPtr       RMB       1                   last character read offset                   $33
0034                  (/dd/defs/cocovtio):00321         V.InpPtr       RMB       1                   next character read offset                   $34
0035                  (/dd/defs/cocovtio):00322         V.WinNum       RMB       1                   window table entry #                         $35
0036                  (/dd/defs/cocovtio):00323         V.DWNum        RMB       1                   dwnum from descriptor                        $36
0037                  (/dd/defs/cocovtio):00324         V.CallCde      RMB       1                   internal comod call code #                   $37
0038                  (/dd/defs/cocovtio):00325         CC3Parm        RMB       128-.               global parameter area
0080                  (/dd/defs/cocovtio):00326         ReadBuf        RMB       256-.               read input buffer (keyboard)
     0100             (/dd/defs/cocovtio):00327         CC3DSiz        EQU       .
                      (/dd/defs/cocovtio):00328         
                      (/dd/defs/cocovtio):00329         *****************************************************************************
                      (/dd/defs/cocovtio):00330         * GrfInt/WindInt global memory area
                      (/dd/defs/cocovtio):00331         * This area sits in system block 0 from $1000 to $10ff
     1000             (/dd/defs/cocovtio):00332         WGlobal        EQU       $1000               useful value (points to address starting below)
                      (/dd/defs/cocovtio):00333                        ORG       0
0000                  (/dd/defs/cocovtio):00334         G.CurTik       RMB       1                   Constant - # Clock ticks/cursor updates (2)
0001                  (/dd/defs/cocovtio):00335         G.CntTik       RMB       1                   Current tick count for cursor updates
0002                  (/dd/defs/cocovtio):00336         G.GfBusy       RMB       1                   Grfdrv is busy flag (1=busy)
0003                  (/dd/defs/cocovtio):00337         G.OrgAlt       RMB       2                   Place to store D.AltIRQ before altering
                      (/dd/defs/cocovtio):00338         *g0003    rmb   2          NEW: UNUSED
0005                  (/dd/defs/cocovtio):00339         g0005          RMB       2                   Temp save in Windint RG
0007                  (/dd/defs/cocovtio):00340         G.GrfStk       RMB       2                   grfdrv stack pointer ($07)
0009                  (/dd/defs/cocovtio):00341         G.MonTyp       RMB       1                   monitor type
     000A             (/dd/defs/cocovtio):00342         g000A          EQU       .                   Old label for compatibility
000A                  (/dd/defs/cocovtio):00343         G.CrDvFl       RMB       1                   Are we current device flag (only set when all
                      (/dd/defs/cocovtio):00344         *                           Parms have been moved to Dev Mem)
                      (/dd/defs/cocovtio):00345         *                           0=We are not on our device
                      (/dd/defs/cocovtio):00346         *                           1=We are the current device
                      (/dd/defs/cocovtio):00347         *                           (Used by comod (GRF/WIND/VDGInt) to determine
                      (/dd/defs/cocovtio):00348         *                            whether or not to update GIME regs themselves
                      (/dd/defs/cocovtio):00349         *                            If not current device, they don't.)
000B                  (/dd/defs/cocovtio):00350         G.WinType      RMB       1                   current device's V.TYPE
000C                  (/dd/defs/cocovtio):00351         G.CurDvM       RMB       2                   current device memory pointer for co-module use
000E                  (/dd/defs/cocovtio):00352         G.WIBusy       RMB       1                   WindInt is busy flag (1=busy)
000F                  (/dd/defs/cocovtio):00353         G.AlPckt       RMB       6                   F$Alarm time packet
0015                  (/dd/defs/cocovtio):00354         G.AlPID        RMB       1                   F$Alarm proc ID ($15)
0016                  (/dd/defs/cocovtio):00355         G.AlSig        RMB       1                   F$Alarm signal code ($16)
0017                  (/dd/defs/cocovtio):00356         G.BelVec       RMB       2                   BELL routine vector
0019                  (/dd/defs/cocovtio):00357         G.DefPal       RMB       2                   pointer to default palette data in global mem
001B                  (/dd/defs/cocovtio):00358         G.TnCnt        RMB       1                   SS.Tone duration counter
001C                  (/dd/defs/cocovtio):00359         G.BelTnF       RMB       1                   BELL tone flag
001D                  (/dd/defs/cocovtio):00360         g001D          RMB       3
0020                  (/dd/defs/cocovtio):00361         G.CurDev       RMB       2                   current device's static memory pointer ($20)
0022                  (/dd/defs/cocovtio):00362         G.PrWMPt       RMB       2                   previous window static mem pointer $(22)
0024                  (/dd/defs/cocovtio):00363         G.BCFFlg       RMB       1                   bit coded co-module found flags ($24)
                      (/dd/defs/cocovtio):00364         *                           00000010 : VDGInt found
                      (/dd/defs/cocovtio):00365         *                           10000000 : GrfDrv found
0025                  (/dd/defs/cocovtio):00366         g0025          RMB       1
0026                  (/dd/defs/cocovtio):00367         G.KTblLC       RMB       1                   Key table entry# last checked (1-3)
                      (/dd/defs/cocovtio):00368         *         IFEQ  TC9-true
                      (/dd/defs/cocovtio):00369         *CurLght  rmb   1          current keyboard light settings
                      (/dd/defs/cocovtio):00370         *         ELSE  
0027                  (/dd/defs/cocovtio):00371         G.LastCh       RMB       1                   last keyboard character (ASCII value)
                      (/dd/defs/cocovtio):00372         *         ENDC  
0028                  (/dd/defs/cocovtio):00373         G.LKeyCd       RMB       1                   last keyboard code
0029                  (/dd/defs/cocovtio):00374         G.KyRept       RMB       1                   key repeat counter
                      (/dd/defs/cocovtio):00375         * A secondary 3 key table (same format as g002D below)
002A                  (/dd/defs/cocovtio):00376         G.2Key1        RMB       1                   $2A
002B                  (/dd/defs/cocovtio):00377         G.2Key2        RMB       1                   $2B
002C                  (/dd/defs/cocovtio):00378         G.2Key3        RMB       1
                      (/dd/defs/cocovtio):00379         * Up to 3 keys can be registerd at once, and they are stored here. If more
                      (/dd/defs/cocovtio):00380         * than 3 are hit, the last key is overwritten with the very last key down that
                      (/dd/defs/cocovtio):00381         * was checked. Format for all three is the same as the PIA column/row byte @
                      (/dd/defs/cocovtio):00382         * KeyFlag below.
002D                  (/dd/defs/cocovtio):00383         G.Key1         RMB       1                   Key 1 being held down (Row/Column #)
002E                  (/dd/defs/cocovtio):00384         G.Key2         RMB       1                   Key 2 being held down (Row/Column #)
002F                  (/dd/defs/cocovtio):00385         G.Key3         RMB       1                   Key 3 being held down (Row/Column #)
0030                  (/dd/defs/cocovtio):00386         G.ShftDn       RMB       1                   SHIFT key down flag (COM'd) ($30)
0031                  (/dd/defs/cocovtio):00387         G.CntlDn       RMB       1                   CTRL key down flag (0=NO)
0032                  (/dd/defs/cocovtio):00388         G.KeyFlg       RMB       1                   Keyboard PIA bit #'s for columns/rows
                      (/dd/defs/cocovtio):00389         *                           %00000111-Column # (Output, 0-7)
                      (/dd/defs/cocovtio):00390         *                           %00111000-Row # (Input, 0-6)
0033                  (/dd/defs/cocovtio):00391         G.AltDwn       RMB       1                   ALT key down flag (0=NO)
0034                  (/dd/defs/cocovtio):00392         G.KySns        RMB       1                   key sense byte
0035                  (/dd/defs/cocovtio):00393         G.KySame       RMB       1                   same key flag
0036                  (/dd/defs/cocovtio):00394         G.CapLok       RMB       1                   CapsLock/SysRq key down flag
0037                  (/dd/defs/cocovtio):00395                        RMB       1
0038                  (/dd/defs/cocovtio):00396         g0038          RMB       1                   grfdrv initialized flag
0039                  (/dd/defs/cocovtio):00397                        RMB       2
003B                  (/dd/defs/cocovtio):00398         G.MSmpRt       RMB       1                   Current mouse sample # (# ticks till next read)
003C                  (/dd/defs/cocovtio):00399         G.Mouse        RMB       Pt.Siz              mouse packet ($3C)
005C                  (/dd/defs/cocovtio):00400         g005C          RMB       2                   Temp for relative mouse X coord calculation
005E                  (/dd/defs/cocovtio):00401         g005E          RMB       2                   Temp for relative mouse Y coord calculation
0060                  (/dd/defs/cocovtio):00402         G.MSmpRV       RMB       1                   Mouse sample reset value (# ticks till next read)
0061                  (/dd/defs/cocovtio):00403         G.KyDly        RMB       1                   initial key repeat delay constant ($61)
0062                  (/dd/defs/cocovtio):00404         G.KySpd        RMB       1                   secondary key repeat delay constant
                      (/dd/defs/cocovtio):00405         *         IFEQ  TC9-true
                      (/dd/defs/cocovtio):00406         *KeyParm  rmb   1          keyboard command parameter byte
                      (/dd/defs/cocovtio):00407         *         ELSE  
0063                  (/dd/defs/cocovtio):00408         G.KyMse        RMB       1                   keyboard mouse flag ($63)
                      (/dd/defs/cocovtio):00409         *         ENDC  
0064                  (/dd/defs/cocovtio):00410         G.Clear        RMB       1                   "one-shot" CapsLock/SysRq key flag ($64)
0065                  (/dd/defs/cocovtio):00411         G.KyButt       RMB       1                   keyboard F1 and F2 "fire" button info ($65)
0066                  (/dd/defs/cocovtio):00412         G.AutoMs       RMB       1                   Auto-follow mouse flag for current device (0=NO)
0067                  (/dd/defs/cocovtio):00413         G.MseMv        RMB       1                   mouse moved flag ($67)
0068                  (/dd/defs/cocovtio):00414         G.CoTble       RMB       6                   co-module table ($68)
006E                  (/dd/defs/cocovtio):00415         G.GrfEnt       RMB       2                   GRFDRV Entry address ($6E)
0070                  (/dd/defs/cocovtio):00416         g0070          RMB       1                   # bytes to move in 1 block (1-72)
0071                  (/dd/defs/cocovtio):00417         G.WUseTb       RMB       4                   windows in use bit table (0=unused, 32 windows) ($71)
0075                  (/dd/defs/cocovtio):00418         G.GfxTbl       RMB       2                   Pointer to GFX tables ($75)
0077                  (/dd/defs/cocovtio):00419         G.WrkWTb       RMB       $40                 Work window table. WindInt only ($77)
00B7                  (/dd/defs/cocovtio):00420         g00B7          RMB       2                   Current Device static mem ptr for WindInt
00B9                  (/dd/defs/cocovtio):00421         g00B9          RMB       2                   Current window table ptr for WindInt
00BB                  (/dd/defs/cocovtio):00422         g00BB          RMB       2                   Pointer to work window table (g0077+$10)
00BD                  (/dd/defs/cocovtio):00423         g00BD          RMB       1                   Current screen type for work window table
00BE                  (/dd/defs/cocovtio):00424         g00BE          RMB       1                   Topmost overlay window # when check for title bars
00BF                  (/dd/defs/cocovtio):00425         g00BF          RMB       1                   Flag for keypress while processing menu select
00C0                  (/dd/defs/cocovtio):00426         g00C0          RMB       2                   Ptr to current path descriptor
00C2                  (/dd/defs/cocovtio):00427         G.WindBk       RMB       2                   shift-clear routine vector
00C4                  (/dd/defs/cocovtio):00428         G.MsInit       RMB       2                   set mouse routine vector
00C6                  (/dd/defs/cocovtio):00429         G.MsSig        RMB       1                   mouse signal flag
00C7                  (/dd/defs/cocovtio):00430         G.DefPls       RMB       16                  Default palettes (2 repeats of 8 is default) ($C7)
00D7                  (/dd/defs/cocovtio):00431         g00D7          RMB       9
00E0                  (/dd/defs/cocovtio):00432         G.KeyEnt       RMB       2                   entry to keydrv subroutine module ($E0)
00E2                  (/dd/defs/cocovtio):00433         G.KeyMem       RMB       8                   static memory for keydrv subroutine module
00EA                  (/dd/defs/cocovtio):00434         G.JoyEnt       RMB       2                   entry to joydrv subroutine module ($EA)
00EC                  (/dd/defs/cocovtio):00435         G.JoyMem       RMB       8                   static memory for joydrv subroutine module
00F4                  (/dd/defs/cocovtio):00436         G.SndEnt       RMB       2                   entry to snddrv subroutine module ($F4)
00F6                  (/dd/defs/cocovtio):00437         G.SndMem       RMB       8                   static memory for snddrv subroutine module
                      (/dd/defs/cocovtio):00438         
                      (/dd/defs/cocovtio):00439         *****************************************************************************
                      (/dd/defs/cocovtio):00440         * GrfDrv global memory data definitions
                      (/dd/defs/cocovtio):00441         * This area sits in system block 0 from $1100 to $119E
     1100             (/dd/defs/cocovtio):00442         GrfMem         EQU       $1100               useful label used to point to mem starting below
                      (/dd/defs/cocovtio):00443                        ORG       0
0000                  (/dd/defs/cocovtio):00444         gr0000         RMB       1                   Pixel mask for 1st byte of GP line
0001                  (/dd/defs/cocovtio):00445         gr0001         RMB       1                   Pixel mask for last byte of a GP line
0002                  (/dd/defs/cocovtio):00446         gr0002         RMB       2                   Ptr to table of bit masks for colors
0004                  (/dd/defs/cocovtio):00447         gr0004         RMB       1                   # of bytes wide GP buffer is (including partials)
0005                  (/dd/defs/cocovtio):00448         gr0005         RMB       1                   # pixels per byte in GP Buffer
0006                  (/dd/defs/cocovtio):00449         gr0006         RMB       1                   # of pixels used in 1st byte of GP buffer line
0007                  (/dd/defs/cocovtio):00450         gr0007         RMB       1                   # of pixels used in last byte of GP buffer line
0008                  (/dd/defs/cocovtio):00451         gr0008         RMB       1                   Bit mask that is common to both screen & GP buffer
0009                  (/dd/defs/cocovtio):00452         gr0009         RMB       1                   # bytes for width of overlay window
000A                  (/dd/defs/cocovtio):00453         gr000A         RMB       1                   # bytes to offset to get to next line after
                      (/dd/defs/cocovtio):00454         *                                              overlay width has been copied
000B                  (/dd/defs/cocovtio):00455         gr000B         RMB       1
000C                  (/dd/defs/cocovtio):00456         gr000C         RMB       2                   Cursor address for proportional spacing?
000E                  (/dd/defs/cocovtio):00457         gr000E         RMB       1
000F                  (/dd/defs/cocovtio):00458         gr000F         RMB       1                   Left-based bit mask for proportional spacing?
0010                  (/dd/defs/cocovtio):00459         gr0010         RMB       2                   Vector for text to gfx screen (either prop. or normal)
0012                  (/dd/defs/cocovtio):00460         gr0012         RMB       6
0018                  (/dd/defs/cocovtio):00461         gr0018         RMB       2                   Working Center X coord for Circle/Ellipse
001A                  (/dd/defs/cocovtio):00462         gr001A         RMB       2                   Working Center Y coord for Circle/Ellipse
001C                  (/dd/defs/cocovtio):00463         gr001C         RMB       2                   Some variable for Circle/Ellipse (initially 0)
001E                  (/dd/defs/cocovtio):00464         gr001E         RMB       2                   Working Y radius value for Circle/Ellipse
0020                  (/dd/defs/cocovtio):00465         gr0020         RMB       2                   Arc 'clip line' X01
0022                  (/dd/defs/cocovtio):00466         gr0022         RMB       2                   Arc 'clip line' Y01
0024                  (/dd/defs/cocovtio):00467         gr0024         RMB       2                   Arc 'clip line' X02
0026                  (/dd/defs/cocovtio):00468         gr0026         RMB       2                   Arc 'clip line' Y02
0028                  (/dd/defs/cocovtio):00469         gr0028         RMB       1                   full-byte background color to FFILL on mask
0029                  (/dd/defs/cocovtio):00470         gr0029         RMB       1                   pixels per byte: set up by FFILL
002A                  (/dd/defs/cocovtio):00471         gr002A         RMB       1                   Flag for FFill: 1=no error, 0=Stack overflow error
002B                  (/dd/defs/cocovtio):00472         gr002B         RMB       1                   current Y-direction to travel in FFILL
002C                  (/dd/defs/cocovtio):00473         gr002C         RMB       2
002E                  (/dd/defs/cocovtio):00474         gr002E         RMB       2                   current window table entry
0030                  (/dd/defs/cocovtio):00475         gr0030         RMB       2                   current screen table ptr
0032                  (/dd/defs/cocovtio):00476         gr0032         RMB       1                   Last block # we used for buffers
0033                  (/dd/defs/cocovtio):00477         gr0033         RMB       2                   Last offset we used for buffers
0035                  (/dd/defs/cocovtio):00478         gr0035         RMB       1                   group
0036                  (/dd/defs/cocovtio):00479         gr0036         RMB       2                   offset
0038                  (/dd/defs/cocovtio):00480         gr0038         RMB       1                   group returned (new)
0039                  (/dd/defs/cocovtio):00481         gr0039         RMB       1                   0=Text cursor inverted off, >0 is inverted on
003A                  (/dd/defs/cocovtio):00482         gr003A         RMB       1                   0=Graphics cursor XOR'd off,>0 is XOR'd on scrn
003B                  (/dd/defs/cocovtio):00483         gr003B         RMB       2                   end of vars ptr?
003D                  (/dd/defs/cocovtio):00484         gr003D         RMB       2                   Last X coordinate Graphics cursor was ON at
003F                  (/dd/defs/cocovtio):00485         gr003F         RMB       2                   Last Y coordinate Graphics cursor was ON at
0041                  (/dd/defs/cocovtio):00486         gr0041         RMB       2                   Screen address for start of current gfx cursor
0043                  (/dd/defs/cocovtio):00487         gr0043         RMB       1                   Pixel mask for start of gfx cursor
0044                  (/dd/defs/cocovtio):00488         gr0044         RMB       1                   Block # Graphics cursor is in
0045                  (/dd/defs/cocovtio):00489         gr0045         RMB       2                   Offset in block Graphics cursor is in
0047                  (/dd/defs/cocovtio):00490         gr0047         RMB       2                   'Working' X coordinate
0049                  (/dd/defs/cocovtio):00491         gr0049         RMB       2                   'Working' Y coordinate
004B                  (/dd/defs/cocovtio):00492         gr004B         RMB       2                   current X
004D                  (/dd/defs/cocovtio):00493         gr004D         RMB       2                   current Y
004F                  (/dd/defs/cocovtio):00494         gr004F         RMB       2                   X Size (in bytes)
0051                  (/dd/defs/cocovtio):00495         gr0051         RMB       2                   Y Size (in bytes)
0053                  (/dd/defs/cocovtio):00496         gr0053         RMB       2                   Horizontal radius (circle/ellipse/arc)
0055                  (/dd/defs/cocovtio):00497         gr0055         RMB       2                   Vertical radius (circle/ellipse/arc)
0057                  (/dd/defs/cocovtio):00498         gr0057         RMB       1                   group
0058                  (/dd/defs/cocovtio):00499         gr0058         RMB       1                   buffer #
0059                  (/dd/defs/cocovtio):00500         gr0059         RMB       1                   save switch for overlay
005A                  (/dd/defs/cocovtio):00501         gr005A         RMB       1                   PRN
005B                  (/dd/defs/cocovtio):00502         gr005B         RMB       2                   X coordinate of Graphics cursor
005D                  (/dd/defs/cocovtio):00503         gr005D         RMB       2                   Y coordinate of Graphics cursor
005F                  (/dd/defs/cocovtio):00504         gr005F         RMB       1                   ATD: new video mode for 24/25/28-line windows
0060                  (/dd/defs/cocovtio):00505         Gr.STYMk       RMB       1                   STY marker
0061                  (/dd/defs/cocovtio):00506         gr0061         RMB       1                   foreground RGB data
0062                  (/dd/defs/cocovtio):00507         gr0062         RMB       1                   background RGB data
0063                  (/dd/defs/cocovtio):00508         gr0063         RMB       1                   bytes/row (on current screen...not window)
0064                  (/dd/defs/cocovtio):00509         gr0064         RMB       2                   PSet vector
0066                  (/dd/defs/cocovtio):00510         gr0066         RMB       2                   pset offset
0068                  (/dd/defs/cocovtio):00511         gr0068         RMB       2                   LSet vector
006A                  (/dd/defs/cocovtio):00512         gr006A         RMB       2                   max X co-ordinate
006C                  (/dd/defs/cocovtio):00513         gr006C         RMB       2                   max Y co-ordinate
006E                  (/dd/defs/cocovtio):00514         gr006E         RMB       2                   X pixel count
0070                  (/dd/defs/cocovtio):00515         gr0070         RMB       2                   Y pixel count
0072                  (/dd/defs/cocovtio):00516         gr0072         RMB       2                   Screen address of pixel we are doing
0074                  (/dd/defs/cocovtio):00517         gr0074         RMB       1                   Pixel mask for pixel we are doing
0075                  (/dd/defs/cocovtio):00518         gr0075         RMB       2                   ??? Pixel mask for last byte of GP buffer?
0077                  (/dd/defs/cocovtio):00519         gr0077         RMB       2                   Vector for right direction FFill
0079                  (/dd/defs/cocovtio):00520         gr0079         RMB       1                   bit mask for 1st pixel in byte for right dir. FFill
007A                  (/dd/defs/cocovtio):00521         gr007A         RMB       2                   Vector for left direction FFill
007C                  (/dd/defs/cocovtio):00522         gr007C         RMB       1                   bit mask for last pixel in byte for left dir. FFill
007D                  (/dd/defs/cocovtio):00523         gr007D         RMB       1                   buffer block #
007E                  (/dd/defs/cocovtio):00524         gr007E         RMB       2                   buffer offset #
0080                  (/dd/defs/cocovtio):00525         gr0080         RMB       2                   Buffer length (in bytes)
0082                  (/dd/defs/cocovtio):00526         gr0082         RMB       3                   3 byte extended screen address
0085                  (/dd/defs/cocovtio):00527         gr0085         RMB       2                   temp
0087                  (/dd/defs/cocovtio):00528         gr0087         RMB       16                  grfdrv (sysmap 1) DAT image
0097                  (/dd/defs/cocovtio):00529         gr0097         RMB       1                   temp
0098                  (/dd/defs/cocovtio):00530         gr0098         RMB       1                   temp
                      (/dd/defs/cocovtio):00531         * In ARC, 97-98 is the width of the clip line in pixels (after scaling)
0099                  (/dd/defs/cocovtio):00532         gr0099         RMB       2                   temp
                      (/dd/defs/cocovtio):00533         * In ARC, 99-9A is the height of the clip line in pixels (after scaling)
009B                  (/dd/defs/cocovtio):00534         gr009B         RMB       1                   counter temp
009C                  (/dd/defs/cocovtio):00535         gr009C         RMB       1
009D                  (/dd/defs/cocovtio):00536         gr009D         RMB       2                   offset to buffer in block
009F                  (/dd/defs/cocovtio):00537         gr009F         RMB       1
00A0                  (/dd/defs/cocovtio):00538         gr00A0         RMB       1                   # lines left to do of GP buffer onto screen
00A1                  (/dd/defs/cocovtio):00539         gr00A1         RMB       2                   vector routine for (changes lots)
                      (/dd/defs/cocovtio):00540         * In ARC A1-A2 is the vector to the proper clipping routine
00A3                  (/dd/defs/cocovtio):00541         gr00A3         RMB       2                   Vector for shifting GP buffers
00A5                  (/dd/defs/cocovtio):00542         gr00A5         RMB       2                   Vector for shifting GP buffers (can dupe A1)
00A7                  (/dd/defs/cocovtio):00543         gr00A7         RMB       2
00A9                  (/dd/defs/cocovtio):00544         gr00A9         RMB       2                   NEW: Window tbl ptr for last window GRFDRV used
00AB                  (/dd/defs/cocovtio):00545         grBigFnt       RMB       2                   Flag for 224 char font/gfx mode on (0=No) V2.00a
00AD                  (/dd/defs/cocovtio):00546         gr00AD         RMB       2                   FFill:orig. start X coord|Circ/Ell saved start X
00AF                  (/dd/defs/cocovtio):00547         gr00AF         RMB       2                   FFill:orig. start Y coord|Circ/Ell saved end X
00B1                  (/dd/defs/cocovtio):00548         gr00B1         RMB       1                   Flag in FFill: 1=1st time through, 0=not 1st time
00B2                  (/dd/defs/cocovtio):00549         gr00B2         RMB       1                   Filled (circle,ellipse) flag 0=Not filled
                      (/dd/defs/cocovtio):00550         *gr00B3   rmb    256-.       ??? UNUSED
00B3                  (/dd/defs/cocovtio):00551         gr00B3         RMB       1                   temp veriable grfdrv
00B4                  (/dd/defs/cocovtio):00552         gr00B4         RMB       1                   temp veriable grfdrv
00B5                  (/dd/defs/cocovtio):00553         gr00B5         RMB       1                   regW for grfdrv
00B6                  (/dd/defs/cocovtio):00554         gr00B6         RMB       1
00B7                  (/dd/defs/cocovtio):00555         gr00B7         RMB       2
00B9                  (/dd/defs/cocovtio):00556         gr00B9         RMB       2                   previously used in grfdrv at $B2 but not for Filled Flag
00BB                  (/dd/defs/cocovtio):00557         gr00BB         RMB       2                   previously used in grfdrv at $B4
00BD                  (/dd/defs/cocovtio):00558         gr00BD         RMB       2                   previously used in grfdrv at $B6
                      (/dd/defs/cocovtio):00559         * EOU Beta 2 & up
00BF                  (/dd/defs/cocovtio):00560         grScrtch       RMB       2                   Scratch var for Grfdrv - use DP instead of stack for
                      (/dd/defs/cocovtio):00561         *                                            anything that does immediate calculations
00C1                  (/dd/defs/cocovtio):00562         gr00BF         RMB       256-.               Reserved for future use
                      (/dd/defs/cocovtio):00563         
                      (/dd/defs/cocovtio):00564         * GPLoad buffer - $1200 in system block    . Currently ends at $1247, and $1248-$127f is unused
     1200             (/dd/defs/cocovtio):00565         GPBuf          EQU       $1200               Usefull address (start of GP buffer copy memory)
0100                  (/dd/defs/cocovtio):00566         GPBufSz        RMB       gb0000              common move buffer for gpload/get/put (72 bytes default)
                      (/dd/defs/cocovtio):00567         
                      (/dd/defs/cocovtio):00568         *****************************************************************************
                      (/dd/defs/cocovtio):00569         * Window table entry structure
                      (/dd/defs/cocovtio):00570         * These tables sit in system block 0 and there is 1 for every window init'd
                      (/dd/defs/cocovtio):00571         * including any overlay windows.
     0020             (/dd/defs/cocovtio):00572         MaxWind        EQU       32                  maximum allowable window tables
     1290             (/dd/defs/cocovtio):00573         WinBase        EQU       $1290               base address to start of window tables
                      (/dd/defs/cocovtio):00574                        ORG       -$10
FFF0                  (/dd/defs/cocovtio):00575         Wt.STbl        RMB       2                   Screen table pointer ($FFFF=Not used)       -$10
FFF2                  (/dd/defs/cocovtio):00576         Wt.BLnk        RMB       1                   overlay window parent entry # ($FF=base)    -$0E
FFF3                  (/dd/defs/cocovtio):00577         Wt.LStrt       RMB       2                   screen logical start address                -$0D
FFF5                  (/dd/defs/cocovtio):00578         Wt.CPX         RMB       1                   current X coord. start                      -$0B
FFF6                  (/dd/defs/cocovtio):00579         Wt.CPY         RMB       1                   current Y coord. start                      -$0A
FFF7                  (/dd/defs/cocovtio):00580         Wt.SZX         RMB       1                   current X size (CWArea)                     -$09
FFF8                  (/dd/defs/cocovtio):00581         Wt.SZY         RMB       1                   current Y size (CWArea)                     -$08
FFF9                  (/dd/defs/cocovtio):00582         Wt.SXFct       RMB       1                   X scaling factor                            -$07
FFFA                  (/dd/defs/cocovtio):00583         Wt.SYFct       RMB       1                   Y scaling factor (0=no scaling)             -$06
FFFB                  (/dd/defs/cocovtio):00584         Wt.Cur         RMB       2                   cursor physical address on screen           -$05
FFFD                  (/dd/defs/cocovtio):00585         Wt.FMsk        RMB       1                   font bit mask (based from left)             -$03
FFFE                  (/dd/defs/cocovtio):00586         Wt.CurX        RMB       2                   X coord of cursor                           -$02
0000                  (/dd/defs/cocovtio):00587         Wt.CurY        RMB       2                   Y Coord of cursor                            $00
0002                  (/dd/defs/cocovtio):00588         Wt.XBCnt       RMB       1                   width of window (in bytes)                   $02
0003                  (/dd/defs/cocovtio):00589         Wt.CWTmp       RMB       1                   bytes wide each text chr (1,2,4)             $03
0004                  (/dd/defs/cocovtio):00590         Wt.BRow        RMB       2                   bytes/text row (8x width in gfx)             $04
0006                  (/dd/defs/cocovtio):00591         Wt.Fore        RMB       1                   foreground palette #                         $06
0007                  (/dd/defs/cocovtio):00592         Wt.Back        RMB       1                   background palette #                         $07
0008                  (/dd/defs/cocovtio):00593         Wt.Attr        RMB       1                   default attributes (FUTTTBBB)                $08
0009                  (/dd/defs/cocovtio):00594         Wt.BSW         RMB       1                   character BSW switches                       $09
000A                  (/dd/defs/cocovtio):00595         Wt.LSet        RMB       1                   LSet type                                    $0A
000B                  (/dd/defs/cocovtio):00596         Wt.FBlk        RMB       1                   Font memory block #                          $0B
000C                  (/dd/defs/cocovtio):00597         Wt.FOff        RMB       2                   Font offset in block                         $0C
000E                  (/dd/defs/cocovtio):00598         Wt.PBlk        RMB       1                   PSet memory block #                          $0E
000F                  (/dd/defs/cocovtio):00599         Wt.POff        RMB       2                   PSet offset in block                         $0F
0011                  (/dd/defs/cocovtio):00600         Wt.OBlk        RMB       1                   Overlay memory block #                       $11
0012                  (/dd/defs/cocovtio):00601         Wt.OOff        RMB       2                   Overlay offset in block                      $12
0014                  (/dd/defs/cocovtio):00602         Wt.LVec        RMB       2                   LSet vector                                  $14
0016                  (/dd/defs/cocovtio):00603         Wt.PVec        RMB       2                   PSet vector                                  $16
0018                  (/dd/defs/cocovtio):00604         Wt.GBlk        RMB       1                   GCursor memory block #                       $18
0019                  (/dd/defs/cocovtio):00605         Wt.GOff        RMB       2                   GCursor offset in block                      $19
001B                  (/dd/defs/cocovtio):00606         Wt.MaxX        RMB       2                   Maximum X cord. (0-79,0-639)                 $1B
001D                  (/dd/defs/cocovtio):00607         Wt.MaxY        RMB       2                   Maximum Y cord. (0-24/25,0-191/199)          $1D
001F                  (/dd/defs/cocovtio):00608         Wt.BLen        RMB       2                   bytes left in GPLoad block below             $1F
0021                  (/dd/defs/cocovtio):00609         Wt.NBlk        RMB       1                   memory block # for next GPLoad               $21
0022                  (/dd/defs/cocovtio):00610         Wt.NOff        RMB       2                   Offset in block for next GPLoad              $22
0024                  (/dd/defs/cocovtio):00611         Wt.LStDf       RMB       2                   screen logical start default                 $24
                      (/dd/defs/cocovtio):00612         * NOTE: The following default settings are what the window was initialized
                      (/dd/defs/cocovtio):00613         *       with, and thus are the MAXIMUM start/size the window can handle
                      (/dd/defs/cocovtio):00614         *       until it is restarted (DWEnd & DWSet)
                      (/dd/defs/cocovtio):00615         *       They also appear to be used in WindInt to determine the coords &
                      (/dd/defs/cocovtio):00616         *       sizes for control+content regions
0026                  (/dd/defs/cocovtio):00617         Wt.DfCPX       RMB       1                   default X cord. start                        $26
0027                  (/dd/defs/cocovtio):00618         Wt.DfCPY       RMB       1                   default Y cord. start                        $27
0028                  (/dd/defs/cocovtio):00619         Wt.DfSZX       RMB       1                   default X size                               $28
0029                  (/dd/defs/cocovtio):00620         Wt.DfSZY       RMB       1                   default Y size                               $29
002A                  (/dd/defs/cocovtio):00621         Wt.Res         RMB       6                   unused                                   $2A-$2F
     0040             (/dd/defs/cocovtio):00622         Wt.Siz         EQU       .+$10
                      (/dd/defs/cocovtio):00623         
                      (/dd/defs/cocovtio):00624         *****************************************************************************
                      (/dd/defs/cocovtio):00625         * Screen table entrys
                      (/dd/defs/cocovtio):00626         * These tables sit in system block 0 base=$1A80
                      (/dd/defs/cocovtio):00627         
     0010             (/dd/defs/cocovtio):00628         STblMax        EQU       16                  Maximum number of screen tables
     1A80             (/dd/defs/cocovtio):00629         STblBse        EQU       $1A80               base address of screen tables
                      (/dd/defs/cocovtio):00630                        ORG       0
0000                  (/dd/defs/cocovtio):00631         St.Sty         RMB       1                   Screen type                         $00
0001                  (/dd/defs/cocovtio):00632         St.SBlk        RMB       1                   Ram block start #                   $01
0002                  (/dd/defs/cocovtio):00633         St.LStrt       RMB       2                   Screen logical start (for GIME)     $02
0004                  (/dd/defs/cocovtio):00634         St.BRow        RMB       1                   Bytes per row                       $04
0005                  (/dd/defs/cocovtio):00635         St.Brdr        RMB       1                   Border palette register #           $05
0006                  (/dd/defs/cocovtio):00636         St.Fore        RMB       1                   Foreground palette register #       $06
0007                  (/dd/defs/cocovtio):00637         St.Back        RMB       1                   Background palette register #       $07
0008                  (/dd/defs/cocovtio):00638         St.ScSiz       RMB       1                   screen size: 24..28 lines           $08
0009                  (/dd/defs/cocovtio):00639         St.Res         RMB       7                   UNUSED???                           $09
                      (/dd/defs/cocovtio):00640         * NOTE: SHOULD USE ONE OF THESE UNUSED BYTES TO KEEP THE # OF DEVICE WINDOW
                      (/dd/defs/cocovtio):00641         * TABLES THAT ARE USING THIS SCREEN TABLE. DWSET & DWEND WOULD KEEP TRACK OF
                      (/dd/defs/cocovtio):00642         * THESE, AND THE WINDINT TITLE BAR ROUTINE WOULD CHECK IT. IF IT IS ONLY 1,
                      (/dd/defs/cocovtio):00643         * IT WON'T BOTHER CHANGING THE TITLE BAR WHEN SELECTING WINDOWS
                      (/dd/defs/cocovtio):00644         * Other possibilities: Offset into screen to display (if we enable screens taller than
                      (/dd/defs/cocovtio):00645         *   a single screen), etc.
0010                  (/dd/defs/cocovtio):00646         St.Pals        RMB       16                  Palette register contents           $10
     0020             (/dd/defs/cocovtio):00647         St.Siz         EQU       .
                      (/dd/defs/cocovtio):00648         
                      (/dd/defs/cocovtio):00649         *****************************************************************************
                      (/dd/defs/cocovtio):00650         * Graphics buffer tables
                      (/dd/defs/cocovtio):00651         * They contain a 20 byte header (shown below), followed by the raw pixel
                      (/dd/defs/cocovtio):00652         * data.
                      (/dd/defs/cocovtio):00653                        ORG       0
0000                  (/dd/defs/cocovtio):00654         Grf.Bck        RMB       1                   back block link #                   $00
0001                  (/dd/defs/cocovtio):00655         Grf.Off        RMB       2                   back block header offset            $01
0003                  (/dd/defs/cocovtio):00656         Grf.Grp        RMB       1                   group #                             $03
0004                  (/dd/defs/cocovtio):00657         Grf.Buff       RMB       1                   buffer #                            $04
0005                  (/dd/defs/cocovtio):00658         Grf.BSz        RMB       2                   buffer size (not including header)  $05
0007                  (/dd/defs/cocovtio):00659         Grf.XSz        RMB       2                   X size (in pixels)                  $07
0009                  (/dd/defs/cocovtio):00660         Grf.YSz        RMB       2                   Y size (in pixels/bytes)            $09
000B                  (/dd/defs/cocovtio):00661         Grf.XBSz       RMB       1                   X size in bytes                     $0B
000C                  (/dd/defs/cocovtio):00662         Grf.LfPx       RMB       1                   # pixels used in first byte of line $0C
000D                  (/dd/defs/cocovtio):00663         Grf.RtPx       RMB       1                   # pixels used in last byte of line  $0D
000E                  (/dd/defs/cocovtio):00664         Grf.STY        RMB       1                   Screen type buffer intended for     $0E
000F                  (/dd/defs/cocovtio):00665         Grf.NBlk       RMB       1                   number blocks used                  $0F
0010                  (/dd/defs/cocovtio):00666         Grf.Pal        RMB       16                  Copy of palette registers?          $10
     0020             (/dd/defs/cocovtio):00667         Grf.Siz        EQU       .                   $20
                      (/dd/defs/cocovtio):00668         
                      (/dd/defs/cocovtio):00669         *****************************************************************************
                      (/dd/defs/cocovtio):00670         * GFX tables (1 for each window, 18 ($12) bytes each) pointed to by
                      (/dd/defs/cocovtio):00671         * $1075-$0176
                      (/dd/defs/cocovtio):00672         * GRFINT only uses gt0001-gt0004, the rest is exclusive to WINDINT
                      (/dd/defs/cocovtio):00673                        ORG       0
0000                  (/dd/defs/cocovtio):00674         Gt.WTyp        RMB       1                   WindInt window type (Framed, Scroll Bar, etc.) $00
0001                  (/dd/defs/cocovtio):00675         Gt.GXCur       RMB       2                   X coord of graphics cursor                     $01
0003                  (/dd/defs/cocovtio):00676         Gt.GYCur       RMB       2                   Y coord of graphics cursor                     $03
0005                  (/dd/defs/cocovtio):00677         Gt.DPtr        RMB       2                   Ptr to WindInt window descriptor               $05
0007                  (/dd/defs/cocovtio):00678         Gt.FClr        RMB       1                   Foreground color                               $07
0008                  (/dd/defs/cocovtio):00679         Gt.BClr        RMB       1                   Background color                               $08
0009                  (/dd/defs/cocovtio):00680         Gt.FMsk        RMB       1                   Foreground mask                                $09
000A                  (/dd/defs/cocovtio):00681         Gt.BMsk        RMB       1                   Background mask                                $0A
000B                  (/dd/defs/cocovtio):00682         Gt.GBlk        RMB       1                   Block # of graphics cursor                     $0B
000C                  (/dd/defs/cocovtio):00683         Gt.GOff        RMB       2                   Offset into block of graphics cursor           $0C
000E                  (/dd/defs/cocovtio):00684         Gt.Proc        RMB       1                   Process # of window creator                    $0E
000F                  (/dd/defs/cocovtio):00685         Gt.PBlk        RMB       1                   Process descriptor block # of creator          $0F
0010                  (/dd/defs/cocovtio):00686         Gt.Res         RMB       2                   ??? RESERVED ???                               $10
     0012             (/dd/defs/cocovtio):00687         GTabSz         EQU       .
                      (/dd/defs/cocovtio):00688         
                      (/dd/defs/cocovtio):00689         *****************************************************************************
                      (/dd/defs/cocovtio):00690         * This table is located in the graphics table memory and is offset from
                      (/dd/defs/cocovtio):00691         * graphics table pointer stored at $1075-$1076. This is used exclusively by
                      (/dd/defs/cocovtio):00692         * WindInt.
                      (/dd/defs/cocovtio):00693         * NOTE: USING UNUSED BYTES IN CC3 GLOBAL MEM, SET UP SEPARATE PTRS FOR EACH
                      (/dd/defs/cocovtio):00694         *  OF THE BELOW SO WE CAN SPEED UP ACCESS BY NOT HAVING TO DO A LOAD/LEAx
                      (/dd/defs/cocovtio):00695         *  COMBINATION EVERY TIME
                      (/dd/defs/cocovtio):00696                        ORG       $0240
0240                  (/dd/defs/cocovtio):00697                        RMB       WN.SIZ              copy of last accessed window descriptor
0262                  (/dd/defs/cocovtio):00698                        RMB       MN.SIZ              copy of last accessed menu descriptor
0279                  (/dd/defs/cocovtio):00699                        RMB       MI.SIZ              copy of last accessed item descriptor
028E                  (/dd/defs/cocovtio):00700                        RMB       65                  menu handling table (16 entrys of 4 bytes)
                      (/dd/defs/cocovtio):00701         
                      (/dd/defs/cocovtio):00702         *****************************************************************************
                      (/dd/defs/cocovtio):00703         * WindInt menu handling table entry definition
                      (/dd/defs/cocovtio):00704                        ORG       0
0000                  (/dd/defs/cocovtio):00705         MnuXNum        RMB       1                   menu #
0001                  (/dd/defs/cocovtio):00706         MnuXStrt       RMB       1                   X start text co-ordinate
0002                  (/dd/defs/cocovtio):00707         MnuXEnd        RMB       1                   X end text co-ordinate
0003                  (/dd/defs/cocovtio):00708                        RMB       1                   unused?
     0004             (/dd/defs/cocovtio):00709         MnuHSiz        EQU       .
                      (/dd/defs/cocovtio):00710         
                      (/dd/defs/cocovtio):00711         *****************************************************************************
                      (/dd/defs/cocovtio):00712         * Character binary switches
     0080             (/dd/defs/cocovtio):00713         Blink          EQU       %10000000           Blink characters (hardware text only)
     0080             (/dd/defs/cocovtio):00714         TChr           EQU       %10000000           transparent characters (both currently)
     0040             (/dd/defs/cocovtio):00715         Under          EQU       %01000000           underline characters (both)
     0020             (/dd/defs/cocovtio):00716         Bold           EQU       %00100000           bold characters (gfx only, maybe txt with color changes?)
     0010             (/dd/defs/cocovtio):00717         Prop           EQU       %00010000           proportional spacing of characters (gfx only)
     0008             (/dd/defs/cocovtio):00718         Scale          EQU       %00001000           automatic window scaling (gfx only)
     0004             (/dd/defs/cocovtio):00719         Invers         EQU       %00000100           inverse characters (both)
     0002             (/dd/defs/cocovtio):00720         NoCurs         EQU       %00000010           no cursor display (both)
     0001             (/dd/defs/cocovtio):00721         Protect        EQU       %00000001           device window protection (both)
                      (/dd/defs/cocovtio):00722         
                      (/dd/defs/cocovtio):00723         *****************************************************************************
                      (/dd/defs/cocovtio):00724         * Screen types (high bit set=hardware text, else graphics) in GRFDRV
     00FF             (/dd/defs/cocovtio):00725         Current        EQU       $ff                 Current screen
                      (/dd/defs/cocovtio):00726         *         equ   1          640x200x2
                      (/dd/defs/cocovtio):00727         *         equ   2          320x200x4
                      (/dd/defs/cocovtio):00728         *         equ   3          640x200x4
                      (/dd/defs/cocovtio):00729         *         equ   4          320x200x16
                      (/dd/defs/cocovtio):00730         *         equ   $85        80 column text
                      (/dd/defs/cocovtio):00731         *         equ   $86        40 column text
                      (/dd/defs/cocovtio):00732         
                      (/dd/defs/cocovtio):00733         *************************************
                      (/dd/defs/cocovtio):00734         * Window default palette color codes
                      (/dd/defs/cocovtio):00735         *
                      (/dd/defs/cocovtio):00736                        ORG       0
0000                  (/dd/defs/cocovtio):00737         White.         RMB       1
0001                  (/dd/defs/cocovtio):00738         Blue.          RMB       1
0002                  (/dd/defs/cocovtio):00739         Black.         RMB       1
0003                  (/dd/defs/cocovtio):00740         Green.         RMB       1
0004                  (/dd/defs/cocovtio):00741         Red.           RMB       1
0005                  (/dd/defs/cocovtio):00742         Yellow.        RMB       1
0006                  (/dd/defs/cocovtio):00743         Magenta.       RMB       1
0007                  (/dd/defs/cocovtio):00744         Cyan.          RMB       1
                      (/dd/defs/cocovtio):00745         
                      ( /dd/defs/deffile):00011                  use   /dd/defs/cocosdc.d
                      (/dd/defs/cocosdc.):00001         ********************************************************************
                      (/dd/defs/cocosdc.):00002         * cocosdc.d - CoCo SDC definitions
                      (/dd/defs/cocosdc.):00003         *
                      (/dd/defs/cocosdc.):00004         * $Id$
                      (/dd/defs/cocosdc.):00005         *
                      (/dd/defs/cocosdc.):00006         * Edt/Rev  YYYY/MM/DD  Modified by
                      (/dd/defs/cocosdc.):00007         * Comment
                      (/dd/defs/cocosdc.):00008         * ------------------------------------------------------------------
                      (/dd/defs/cocosdc.):00009         *          2014/05/02  Boisy G. Pitre
                      (/dd/defs/cocosdc.):00010         * Created
                      (/dd/defs/cocosdc.):00011         
                      (/dd/defs/cocosdc.):00012         
     FF4A             (/dd/defs/cocosdc.):00013         SDAddr         SET       $FF4A
                      (/dd/defs/cocosdc.):00014         
                      ( /dd/defs/deffile):00012                  use   /dd/defs/vdgdefs
                      ( /dd/defs/vdgdefs):00001                        IFNE      VDGDEFS-1
                      ( /dd/defs/vdgdefs):00002         
     0001             ( /dd/defs/vdgdefs):00003         VDGDEFS        SET       1
                      ( /dd/defs/vdgdefs):00004         
                      ( /dd/defs/vdgdefs):00005         ********************************************************************
                      ( /dd/defs/vdgdefs):00006         * VDGDefs - VDG Interface Definititions
                      ( /dd/defs/vdgdefs):00007         *
                      ( /dd/defs/vdgdefs):00008         * $Id$
                      ( /dd/defs/vdgdefs):00009         *
                      ( /dd/defs/vdgdefs):00010         * Edt/Rev  YYYY/MM/DD  Modified by
                      ( /dd/defs/vdgdefs):00011         * Comment
                      ( /dd/defs/vdgdefs):00012         * ------------------------------------------------------------------
                      ( /dd/defs/vdgdefs):00013         *          1991/05/07  Alan DeKok
                      ( /dd/defs/vdgdefs):00014         * Wrote original from VDGInt source.
                      ( /dd/defs/vdgdefs):00015         
                      ( /dd/defs/vdgdefs):00016                        NAM       VDGDefs
                      ( /dd/defs/vdgdefs):00017                        TTL       VDG Interface Definitions
                      ( /dd/defs/vdgdefs):00018         
                      ( /dd/defs/vdgdefs):00019         * Notes:
                      ( /dd/defs/vdgdefs):00020         *
                      ( /dd/defs/vdgdefs):00021         * All offsets from 'U' (address of device memory area)
                      ( /dd/defs/vdgdefs):00022         * (see p. 6-9, technical reference: U=start of driver data memory
                      ( /dd/defs/vdgdefs):00023         * NOTE: There is LOTS of stuff which is only used once, and some which
                      ( /dd/defs/vdgdefs):00024         * is not needed.  Here's a list of the un-needed, and un-used (other than
                      ( /dd/defs/vdgdefs):00025         * once)
                      ( /dd/defs/vdgdefs):00026         *
                      ( /dd/defs/vdgdefs):00027         * It would probably be benificial to patch VDGint to fix these problems,
                      ( /dd/defs/vdgdefs):00028         * unless anyone else has ideas as to why VDGint is doing things this way.
                      ( /dd/defs/vdgdefs):00029         *
                      ( /dd/defs/vdgdefs):00030         * Un-needed
                      ( /dd/defs/vdgdefs):00031         * VD.EPlt1  - (2) set to VD.NChar, and then read only
                      ( /dd/defs/vdgdefs):00032         * VD.EPlt2  - (2) set to same as VD.EPlt1, and then unused
                      ( /dd/defs/vdgdefs):00033         * VD.Chr1   - (1) set to same as VD.CChar, and then unused
                      ( /dd/defs/vdgdefs):00034         * VD.PlFlg  - (1) initialized to $08, and unused
                      ( /dd/defs/vdgdefs):00035         *
                      ( /dd/defs/vdgdefs):00036         * Un-used
                      ( /dd/defs/vdgdefs):00037         *
                      ( /dd/defs/vdgdefs):00038         * $1D       - (1) end of SCF memory requirements
                      ( /dd/defs/vdgdefs):00039         * VD.Strt1  - (2) CLRed, and then read (LDD) - left as $0000
                      ( /dd/defs/vdgdefs):00040         * $24-$2B   - (8)
                      ( /dd/defs/vdgdefs):00041         * $33-$34   - (2)
                      ( /dd/defs/vdgdefs):00042         * $7E-$FF   - (130)
                      ( /dd/defs/vdgdefs):00043         *
                      ( /dd/defs/vdgdefs):00044         * Total of 22 (150 in whole page) bytes unneeded or unused.
                      ( /dd/defs/vdgdefs):00045         
                      ( /dd/defs/vdgdefs):00046                        ORG       $1E
001E                  ( /dd/defs/vdgdefs):00047         VD.Start       RMB       1                   start of VD.XXXX data: number of VDG screens in use
001F                  ( /dd/defs/vdgdefs):00048         VD.Strt1       RMB       2                   (2) and another start
0021                  ( /dd/defs/vdgdefs):00049         VD.Caps        RMB       2                   caps lock info: $00=lower $FF=upper
0023                  ( /dd/defs/vdgdefs):00050         VD.DFlag       RMB       1                   0=current screen is valid, $01-$FF = update video
                      ( /dd/defs/vdgdefs):00051         * $24-$2B unused
0024                  ( /dd/defs/vdgdefs):00052                        RMB       8
002C                  ( /dd/defs/vdgdefs):00053         VD.NGChr       RMB       1                   number of additional characters to get
002D                  ( /dd/defs/vdgdefs):00054         VD.RTAdd       RMB       2                   (2) return address after getting characters
002F                  ( /dd/defs/vdgdefs):00055         VD.EPlt1       RMB       2                   (2) pointer to where to put next character
0031                  ( /dd/defs/vdgdefs):00056         VD.EPlt2       RMB       2                   (2) as above.
                      ( /dd/defs/vdgdefs):00057         * $33-$34 unused
0033                  ( /dd/defs/vdgdefs):00058                        RMB       2
0035                  ( /dd/defs/vdgdefs):00059         VD.CFlag       RMB       1                   true lowercase flag $10=true, $00=false
0036                  ( /dd/defs/vdgdefs):00060         VD.CFlg1       RMB       1                   VDG display code values
0037                  ( /dd/defs/vdgdefs):00061         VD.DGBuf       RMB       1                   number of currently displayed buffer
0038                  ( /dd/defs/vdgdefs):00062         VD.ScrnA       RMB       2                   (2) screen start address in system memory
003A                  ( /dd/defs/vdgdefs):00063         VD.ScrnE       RMB       2                   (2) address of end of screen
003C                  ( /dd/defs/vdgdefs):00064         VD.CrsrA       RMB       1                   (2) cursor address
003D                  ( /dd/defs/vdgdefs):00065         VD.CrsAL       RMB       1                   cursor address low
003E                  ( /dd/defs/vdgdefs):00066         VD.CChar       RMB       1                   value of character under cursor
003F                  ( /dd/defs/vdgdefs):00067         VD.Mode        RMB       1                   mode: 0=256x192 x2, 1=128x192 x4
0040                  ( /dd/defs/vdgdefs):00068         VD.Chr1        RMB       1                   same as under cursor character
0041                  ( /dd/defs/vdgdefs):00069         VD.CColr       RMB       1                   cursor color
0042                  ( /dd/defs/vdgdefs):00070         VD.Col         RMB       1                   number of columns for this screen
0043                  ( /dd/defs/vdgdefs):00071         VD.Row         RMB       1                   number of rows
0044                  ( /dd/defs/vdgdefs):00072         VD.TFlg1       RMB       1                   see WRITE ($0E)
0045                  ( /dd/defs/vdgdefs):00073         VD.Alpha       RMB       1                   0 when in alpha mode
0046                  ( /dd/defs/vdgdefs):00074         VD.Rdy         RMB       1                   device ready (see SS.DStat 0=not ready)
0047                  ( /dd/defs/vdgdefs):00075         VD.SBAdd       RMB       2                   (2) address of block screen is in
0049                  ( /dd/defs/vdgdefs):00076         VD.Blk         RMB       1                   Block number of screen
004A                  ( /dd/defs/vdgdefs):00077         VD.GBuff       RMB       1                   allocation for graphics buffers (block#)
004B                  ( /dd/defs/vdgdefs):00078         VD.AGBuf       RMB       2                   (2) additional graphics buffer
004D                  ( /dd/defs/vdgdefs):00079         VD.HiRes       RMB       1                   hi-res screen table (block value)
004E                  ( /dd/defs/vdgdefs):00080         VD.NBlk        RMB       1                   number of blocks in this screen
004F                  ( /dd/defs/vdgdefs):00081         VD.SType       RMB       1                   screen type -4
0050                  ( /dd/defs/vdgdefs):00082         VD.HR2         RMB       3                   (3) for screen number 2
0053                  ( /dd/defs/vdgdefs):00083         VD.HR3         RMB       3                   (3) for screen 3 (same 3 bytes as above)
0056                  ( /dd/defs/vdgdefs):00084         VD.FFMem       RMB       2                   (2) bottom of stack for flood fill
0058                  ( /dd/defs/vdgdefs):00085         VD.FFSPt       RMB       2                   (2) flood fill stack pointer
005A                  ( /dd/defs/vdgdefs):00086         VD.FFSTp       RMB       2                   (2) flood fill stack top pointer
005C                  ( /dd/defs/vdgdefs):00087         VD.FF6         RMB       1                   flood fill flag
005D                  ( /dd/defs/vdgdefs):00088         VD.MTabl       RMB       2                   (2) address of mask table for pixels in byte
005F                  ( /dd/defs/vdgdefs):00089         VD.PixBt       RMB       1                   bit mask for modes (0=$07, 1=$03 )#pixels/byte
0060                  ( /dd/defs/vdgdefs):00090         VD.GCrsX       RMB       1                   graphics cursor X value
0061                  ( /dd/defs/vdgdefs):00091         VD.GCrsY       RMB       1                   graphics cursor Y
0062                  ( /dd/defs/vdgdefs):00092         VD.Msk1        RMB       1                   mask byte 1
0063                  ( /dd/defs/vdgdefs):00093         VD.Msk2        RMB       1                   mask byte 2 (00,55,AA,FF)
0064                  ( /dd/defs/vdgdefs):00094         VD.MCol        RMB       1                   color? (C003,8001)
0065                  ( /dd/defs/vdgdefs):00095         VD.MCol2       RMB       1                   color
0066                  ( /dd/defs/vdgdefs):00096         VD.PMask       RMB       1                   pixel mask for colors (i.e. $55, $CC etc)
0067                  ( /dd/defs/vdgdefs):00097         VD.FF1         RMB       1                   data for flood fill
0068                  ( /dd/defs/vdgdefs):00098         VD.FF2         RMB       1                   data for flood fill
0069                  ( /dd/defs/vdgdefs):00099         VD.FFMsk       RMB       1                   flood fill mask
006A                  ( /dd/defs/vdgdefs):00100         VD.FFFlg       RMB       1                   flood fill flag
006B                  ( /dd/defs/vdgdefs):00101         VD.Palet       RMB       16                  (16) current palette values
007B                  ( /dd/defs/vdgdefs):00102         VD.PlFlg       RMB       1                   initialized to $08 by L00DB, and then unused!
007C                  ( /dd/defs/vdgdefs):00103         VD.NChar       RMB       1                   character to process
007D                  ( /dd/defs/vdgdefs):00104         VD.NChr2       RMB       1                   and the next one
                      ( /dd/defs/vdgdefs):00105         
                      ( /dd/defs/vdgdefs):00106         * and RMB until we get 256 bytes reserved
                      ( /dd/defs/vdgdefs):00107         
                      ( /dd/defs/vdgdefs):00108                        ENDC      
                      ( /dd/defs/vdgdefs):00109         
                      (    krn_beta5.asm):00046                 ENDC
                      (    krn_beta5.asm):00047         
                      (    krn_beta5.asm):00048         * defines for customizations
     000A             (    krn_beta5.asm):00049         Revision  set   10            module revision
     0013             (    krn_beta5.asm):00050         Edition   set   19            module Edition
     F000             (    krn_beta5.asm):00051         Where     equ   $F000         absolute address of where Kernel starts in memory
                      (    krn_beta5.asm):00052         
0000 87CD0EDF000DC08A (    krn_beta5.asm):00053                   mod   eom,MName,Systm,ReEnt+Revision,entry,0
     2300530000
                      (    krn_beta5.asm):00054         
000D 4B72EE           (    krn_beta5.asm):00055         MName     fcs   /Krn/
0010 13               (    krn_beta5.asm):00056                   fcb   Edition
                      (    krn_beta5.asm):00057         
                      (    krn_beta5.asm):00058         * FILL - all unused bytes are now here
0011 7777772E6E697472 (    krn_beta5.asm):00059                   fcc   /www.nitros9.org /
     6F73392E6F726720
                      (    krn_beta5.asm):00060                 IFNE H6309
                      (    krn_beta5.asm):00061                   fcc   /www.nitros9.org /
                      (    krn_beta5.asm):00062                   fcc   /www.nitros9.org /
                      (    krn_beta5.asm):00063                   fcc   /www.nitros9.org /
                      (    krn_beta5.asm):00064                   fcc   /www.nitros9.org /
                      (    krn_beta5.asm):00065                   fcc   /www.nitros9.org /
                      (    krn_beta5.asm):00066                   fcc   /www.nitros9.org /
                      (    krn_beta5.asm):00067                   fcc   /www.nitros9.org /
                      (    krn_beta5.asm):00068                   fcc   /www.nitros9./
                      (    krn_beta5.asm):00069                 ELSE
0021 7777772E6E697472 (    krn_beta5.asm):00070                   fcc   /www.nitro/
     6F
                      (    krn_beta5.asm):00071                 ENDC
                      (    krn_beta5.asm):00072         
                      (    krn_beta5.asm):00073         * Might as well have this here as just past the end of Kernel...
002A FC97             (    krn_beta5.asm):00074         DisTable  fdb   L0CD2+Where   D.Clock absolute address at the start
002C F231             (    krn_beta5.asm):00075                   fdb   XSWI3+Where   D.XSWI3
002E F23F             (    krn_beta5.asm):00076                   fdb   XSWI2+Where   D.XSWI2
0030 006B             (    krn_beta5.asm):00077                   fdb   D.Crash       D.XFIRQ crash on an FIRQ
0032 FCFC             (    krn_beta5.asm):00078                   fdb   XIRQ+Where    D.XIRQ
0034 F234             (    krn_beta5.asm):00079                   fdb   XSWI+Where    D.XSWI
0036 006B             (    krn_beta5.asm):00080                   fdb   D.Crash       D.XNMI crash on an NMI
0038 0055             (    krn_beta5.asm):00081                   fdb   $0055         D.ErrRst ??? Not used as far as I can tell
003A F30B             (    krn_beta5.asm):00082                   fdb   Sys.Vec+Where Initial Kernel system call vector
     0012             (    krn_beta5.asm):00083         DisSize   equ   *-DisTable
                      (    krn_beta5.asm):00084         
                      (    krn_beta5.asm):00085         * DO NOT ADD ANYTHING BETWEEN THESE 2 TABLES: see code using 'SubSiz', below
     0160             (    krn_beta5.asm):00086         LowSub    equ   $0160       start of low memory subroutines
     003C             (    krn_beta5.asm):00087         SubStrt   equ   *
                      (    krn_beta5.asm):00088         * D.Flip0 - switch to system task 0
     003C             (    krn_beta5.asm):00089         R.Flip0   equ   *
                      (    krn_beta5.asm):00090                 IFNE H6309
                      (    krn_beta5.asm):00091                   aim   #$FE,<D.TINIT    map type 0
                      (    krn_beta5.asm):00092                   lde   <D.TINIT    another 2 bytes saved if GRFDRV does: tfr cc,e
                      (    krn_beta5.asm):00093                   ste   >DAT.Task   and we can use A here, instead of E
                      (    krn_beta5.asm):00094                 ELSE
003C 3402             (    krn_beta5.asm):00095                   pshs  a
003E 9691             (    krn_beta5.asm):00096                   lda   <D.TINIT
0040 84FE             (    krn_beta5.asm):00097                   anda  #$FE
0042 9791             (    krn_beta5.asm):00098                   sta   <D.TINIT
0044 B7FF91           (    krn_beta5.asm):00099                   sta   >DAT.Task
0047 3502             (    krn_beta5.asm):00100                   puls  a
                      (    krn_beta5.asm):00101                 ENDC
0049 0FA4             (    krn_beta5.asm):00102                   clr   <D.SSTskN
004B 1F14             (    krn_beta5.asm):00103                   tfr   x,s
004D 1F8A             (    krn_beta5.asm):00104                   tfr   a,cc
004F 39               (    krn_beta5.asm):00105                   rts
                      (    krn_beta5.asm):00106         
                      (    krn_beta5.asm):00107         * Don't add any code here: See L0065, below.
     0014             (    krn_beta5.asm):00108         SubSiz    equ   *-SubStrt
                      (    krn_beta5.asm):00109         * Interrupt service routine
0050 6E98F0           (    krn_beta5.asm):00110         Vectors   jmp   [<-(D.SWI3-D.XSWI3),x]    (-$10) (Jmp to 2ndary vector)
                      (    krn_beta5.asm):00111         * Let's start by initializing system page
     0053             (    krn_beta5.asm):00112         entry     equ    *
                      (    krn_beta5.asm):00113                 IFNE    H6309
                      (    krn_beta5.asm):00114                   ldq   #$01001f00  start address to clear & # bytes to clear
                      (    krn_beta5.asm):00115                   leay   <entry+2,pc  point to a 0
                      (    krn_beta5.asm):00116                   tfm   y,d+
                      (    krn_beta5.asm):00117                   std   <D.CCStk    set pointer to top of global memory to $2000
                      (    krn_beta5.asm):00118                   lda   #$01        set task user table to $0100
                      (    krn_beta5.asm):00119                 ELSE
0053 8E0100           (    krn_beta5.asm):00120                   ldx   #$100       start address
0056 108E1F00         (    krn_beta5.asm):00121                   ldy   #$2000-$100 # bytes to clear
005A 4F               (    krn_beta5.asm):00122                   clra
005B 5F               (    krn_beta5.asm):00123                   clrb
005C ED81             (    krn_beta5.asm):00124         L001C     std   ,x++
005E 313E             (    krn_beta5.asm):00125                   leay  -2,y
0060 26FA             (    krn_beta5.asm):00126                   bne   L001C
0062 9FA7             (    krn_beta5.asm):00127                   stx   <D.CCStk    Set pointer to top of global memory to $2000
0064 4C               (    krn_beta5.asm):00128                   inca              D=$0100
                      (    krn_beta5.asm):00129                 ENDC
                      (    krn_beta5.asm):00130         * Setup system direct page variables
0065 DD20             (    krn_beta5.asm):00131                   std   <D.Tasks
0067 CB20             (    krn_beta5.asm):00132                   addb  #$20        set Task image table to $0120
0069 DDA1             (    krn_beta5.asm):00133                   std   <D.TskIPt
006B 5F               (    krn_beta5.asm):00134                   clrb              set memory block map to $0200
006C 4C               (    krn_beta5.asm):00135                   inca
006D DD40             (    krn_beta5.asm):00136                   std   <D.BlkMap
006F CB40             (    krn_beta5.asm):00137                   addb   #$40       set second block map to $0240
0071 DD42             (    krn_beta5.asm):00138                   std   <D.BlkMap+2
0073 5F               (    krn_beta5.asm):00139                   clrb              set system service dispatch table to $0300
0074 4C               (    krn_beta5.asm):00140                   inca
0075 DDC2             (    krn_beta5.asm):00141                   std   <D.SysDis
0077 4C               (    krn_beta5.asm):00142                   inca              set user dispatch table to $0400
0078 DDC8             (    krn_beta5.asm):00143                   std   <D.UsrDis
007A 4C               (    krn_beta5.asm):00144                   inca              set process descriptor block to $0500
007B DD48             (    krn_beta5.asm):00145                   std   <D.PrcDBT
007D 4C               (    krn_beta5.asm):00146                   inca              set system process descriptor to $0600
007E DD4A             (    krn_beta5.asm):00147                   std   <D.SysPrc
0080 DD50             (    krn_beta5.asm):00148                   std   <D.Proc     set user process descriptor to $0600
0082 8B02             (    krn_beta5.asm):00149                   adda   #$02       set stack pointer to $0800
0084 1F04             (    krn_beta5.asm):00150                   tfr   d,s
0086 4C               (    krn_beta5.asm):00151                   inca              set system stack to $0900
0087 DDCC             (    krn_beta5.asm):00152                   std   <D.SysStk
0089 DD4E             (    krn_beta5.asm):00153                   std   <D.SysMem   set system memory map ptr $0900
008B 4C               (    krn_beta5.asm):00154                   inca              set module directory start to $0a00
008C DD44             (    krn_beta5.asm):00155                   std   <D.ModDir
008E DD58             (    krn_beta5.asm):00156                   std   <D.ModEnd   set module directory end to $0a00
0090 8B06             (    krn_beta5.asm):00157                   adda  #$06        set secondary module directory start to $1000
0092 DD46             (    krn_beta5.asm):00158                   std   <D.ModDir+2
0094 DD5A             (    krn_beta5.asm):00159                   std   <D.ModDAT   set module directory DAT pointer to $1000
0096 DDA5             (    krn_beta5.asm):00160                   std   <D.CCMem    set pointer to beginning of global memory to $1000
                      (    krn_beta5.asm):00161         * In following line, CRC=ON if it is STA <D.CRC, CRC=OFF if it is a STB <D.CRC
0098 D73B             (    krn_beta5.asm):00162                   stb   <D.CRC      set CRC checking flag to off
                      (    krn_beta5.asm):00163         * Initialize interrupt vector tables
009A 318C8D           (    krn_beta5.asm):00164                   leay  <DisTable,pcr    point to table of absolute vector addresses
009D 8E00E0           (    krn_beta5.asm):00165                   ldx   #D.Clock    where to put it in memory
                      (    krn_beta5.asm):00166                 IFNE    H6309
                      (    krn_beta5.asm):00167                   ldf   #DisSize    size of the table - E=0 from TFM, above
                      (    krn_beta5.asm):00168                   tfm   y+,x+       move it over
                      (    krn_beta5.asm):00169                 ELSE    
00A0 C612             (    krn_beta5.asm):00170                   ldb   #DisSize    Size of table
00A2 A6A0             (    krn_beta5.asm):00171         l@        lda   ,y+         Copy it over
00A4 A780             (    krn_beta5.asm):00172                   sta   ,x+
00A6 5A               (    krn_beta5.asm):00173                   decb
00A7 26F9             (    krn_beta5.asm):00174                   bne   l@
                      (    krn_beta5.asm):00175                 ENDC
                      (    krn_beta5.asm):00176         * initialize D.Flip0 routine in low memory
                      (    krn_beta5.asm):00177         * Y=ptr to R.Flip0 already
00A9 CE0160           (    krn_beta5.asm):00178                   ldu   #LowSub     somewhere in block 0 that's never modified
00AC DFA9             (    krn_beta5.asm):00179                   stu   <D.Flip0    switch to system task 0
                      (    krn_beta5.asm):00180                 IFNE    H6309
                      (    krn_beta5.asm):00181                   ldf   #SubSiz     size of it
                      (    krn_beta5.asm):00182                   tfm   y+,u+       copy it over
                      (    krn_beta5.asm):00183                 ELSE    
00AE C614             (    krn_beta5.asm):00184                   ldb   #SubSiz     Size of copy
00B0 A6A0             (    krn_beta5.asm):00185         Loop2     lda   ,y+         Copy it over
00B2 A7C0             (    krn_beta5.asm):00186                   sta   ,u+
00B4 5A               (    krn_beta5.asm):00187                   decb
00B5 26F9             (    krn_beta5.asm):00188                   bne   Loop2
                      (    krn_beta5.asm):00189                 ENDC
00B7 33A4             (    krn_beta5.asm):00190                   leau  ,y          move the pointer to a faster register
00B9 EF81             (    krn_beta5.asm):00191         L0065     stu   ,x++        Set all IRQ vectors to go to Vectors for now
00BB 8C00FC           (    krn_beta5.asm):00192                   cmpx  #D.NMI
00BE 23F9             (    krn_beta5.asm):00193                   bls   L0065
                      (    krn_beta5.asm):00194         * Initialize user interupt vectors
00C0 9EE4             (    krn_beta5.asm):00195                   ldx   <D.XSWI2    Get SWI2 (os9 command) service routine pointer
00C2 9FC6             (    krn_beta5.asm):00196                   stx   <D.UsrSvc   Save it as user service routine pointer
00C4 9EE8             (    krn_beta5.asm):00197                   ldx   <D.XIRQ     Get IRQ service routine pointer
00C6 9FCA             (    krn_beta5.asm):00198                   stx   <D.UsrIRQ   Save it as user IRQ routine pointer
00C8 308D0223         (    krn_beta5.asm):00199                   leax  >SysCall,pc  Setup System service routine entry vector
00CC 9FC0             (    krn_beta5.asm):00200                   stx   <D.SysSvc
00CE 9FE4             (    krn_beta5.asm):00201                   stx   <D.XSWI2
00D0 308D0D1D         (    krn_beta5.asm):00202                   leax  >S.SysIRQ,pc  Setup system IRQ service vector
00D4 9FC4             (    krn_beta5.asm):00203                   stx   <D.SysIRQ
00D6 9FE8             (    krn_beta5.asm):00204                   stx   <D.XIRQ
00D8 308D0D11         (    krn_beta5.asm):00205                   leax  >S.SvcIRQ,pc  Setup in system IRQ service vector
00DC 9FCE             (    krn_beta5.asm):00206                   stx   <D.SvcIRQ
00DE 308D046D         (    krn_beta5.asm):00207                   leax  >S.Poll,pc    Setup interrupt polling vector
00E2 9F26             (    krn_beta5.asm):00208                   stx   <D.Poll       ORCC #$01;RTS
00E4 308D00D5         (    krn_beta5.asm):00209                   leax  >S.AltIRQ,pc  Setup alternate IRQ vector: pts to an RTS
00E8 9FB2             (    krn_beta5.asm):00210                   stx   <D.AltIRQ
00EA 864B             (    krn_beta5.asm):00211                   lda   #'K         'K' for 'in Kernel'
00EC 9D5E             (    krn_beta5.asm):00212                   jsr   <D.BtBug
00EE 308D0D5F         (    krn_beta5.asm):00213                   leax  >S.Flip1,pc   Setup change to task 1 vector
00F2 9FAB             (    krn_beta5.asm):00214                   stx   <D.Flip1
                      (    krn_beta5.asm):00215         * Setup System calls
00F4 318D00D5         (    krn_beta5.asm):00216                   leay  >SysCalls,pc
00F8 170255           (    krn_beta5.asm):00217                   lbsr  SysSvc
                      (    krn_beta5.asm):00218         * Initialize system process descriptor
00FB DE48             (    krn_beta5.asm):00219                   ldu   <D.PrcDBT   get process table pointer
00FD 9E4A             (    krn_beta5.asm):00220                   ldx   <D.SysPrc   get system process pointer
                      (    krn_beta5.asm):00221         * These overlap because it is quicker than trying to strip hi byte from X
00FF AFC4             (    krn_beta5.asm):00222                   stx   ,u          save it as first process in table
0101 AF41             (    krn_beta5.asm):00223                   stx   1,u         save it as the second as well
                      (    krn_beta5.asm):00224                 IFNE H6309
                      (    krn_beta5.asm):00225                   oim   #$01,P$ID,x  Set process ID to 1 (inited to 0)
                      (    krn_beta5.asm):00226                   oim   #SysState,P$State,x    Set to system state (inited to 0)
                      (    krn_beta5.asm):00227                 ELSE
0103 CC0180           (    krn_beta5.asm):00228                   ldd    #$01*256+SysState
0106 A784             (    krn_beta5.asm):00229                   sta    P$ID,x     Set process ID to 1
0108 E70C             (    krn_beta5.asm):00230                   stb    P$State,x  Set to system state
                      (    krn_beta5.asm):00231                 ENDC
010A 4F               (    krn_beta5.asm):00232                   clra              System task is task #0
010B 97D0             (    krn_beta5.asm):00233                   sta    <D.SysTsk
010D A706             (    krn_beta5.asm):00234                   sta    P$Task,x
010F 43               (    krn_beta5.asm):00235                   coma              Setup its priority & age ($FF)
0110 A70A             (    krn_beta5.asm):00236                   sta    P$Prior,x
0112 A70B             (    krn_beta5.asm):00237                   sta    P$Age,x
0114 308840           (    krn_beta5.asm):00238                   leax   <P$DATImg,x  point to DAT image
0117 9F4C             (    krn_beta5.asm):00239                   stx    <D.SysDAT  save it as a pointer in DP
                      (    krn_beta5.asm):00240         * 6809/6309: actually, since block 0 is tfm'd to be zero, we can skip CLRx & std here
                      (    krn_beta5.asm):00241                 IFNE    H6309
                      (    krn_beta5.asm):00242                   clrd
                      (    krn_beta5.asm):00243                 ELSE
0119 4F               (    krn_beta5.asm):00244                   clra
011A 5F               (    krn_beta5.asm):00245                   clrb
                      (    krn_beta5.asm):00246                 ENDC    
011B ED81             (    krn_beta5.asm):00247                   std   ,x++        initialize 1st block to 0 (for this DP)
                      (    krn_beta5.asm):00248         * Dat.BlCt-ROMCount-RAMCount
011D 8606             (    krn_beta5.asm):00249                   lda   #$06        initialize the rest of the blocks to be free
011F CE333E           (    krn_beta5.asm):00250                   ldu   #DAT.Free
0122 EF81             (    krn_beta5.asm):00251         L00EF     stu   ,x++
0124 4A               (    krn_beta5.asm):00252                   deca
0125 26FB             (    krn_beta5.asm):00253                   bne   L00EF
0127 CE003F           (    krn_beta5.asm):00254                   ldu   #$003F      Block $3F in use, at the top of system DAT image
012A EF84             (    krn_beta5.asm):00255                   stu   ,x
012C 9E20             (    krn_beta5.asm):00256                   ldx   <D.Tasks    Point to task user table
012E 6C84             (    krn_beta5.asm):00257                   inc   ,x          mark first 2 in use (system & GrfDrv)
0130 6C01             (    krn_beta5.asm):00258                   inc   1,x
                      (    krn_beta5.asm):00259         * Setup system memory map
0132 9E4E             (    krn_beta5.asm):00260                   ldx   <D.SysMem   Get system memory map pointer
0134 D6A7             (    krn_beta5.asm):00261                   ldb   <D.CCStk    Get MSB of top of CC memory
0136 6C80             (    krn_beta5.asm):00262         L0104     inc   ,x+         Mark it as used
0138 5A               (    krn_beta5.asm):00263                   decb              Done?
0139 26FB             (    krn_beta5.asm):00264                   bne   L0104       No, go back till done
                      (    krn_beta5.asm):00265         * Calculate memory size
013B 9E40             (    krn_beta5.asm):00266                   ldx   <D.BlkMap   get ptr to 8k block map
013D 6C883F           (    krn_beta5.asm):00267                   inc   <$3F,x      mark block $3F as used (kernel)
                      (    krn_beta5.asm):00268                 IFNE H6309
                      (    krn_beta5.asm):00269                   ldq   #$00080100  E=Marker, D=Block # to check
0140                  (    krn_beta5.asm):00270         L0111     asld              get next block #
                      (    krn_beta5.asm):00271                   stb   >$FFA5      Map block into block 6 of my task
                      (    krn_beta5.asm):00272                   ste   >-$6000,x   save marker to that block
                      (    krn_beta5.asm):00273                   cmpe  ,x          did it ghost to block 0?
                      (    krn_beta5.asm):00274                   bne   L0111       No, keep going untill ghost is found
                      (    krn_beta5.asm):00275                   stb   <D.MemSz    Save # 8k mem blocks that exist
                      (    krn_beta5.asm):00276                   addr  x,d         add # of blocks to block map start
                      (    krn_beta5.asm):00277                 ELSE
0140 CC0008           (    krn_beta5.asm):00278                   ldd   #$0008      Marker
0143 58               (    krn_beta5.asm):00279         L0111     aslb              Get next block marker
0144 49               (    krn_beta5.asm):00280                   rola
0145 F7FFA5           (    krn_beta5.asm):00281                   stb   >$FFA5      Map block into block 6 of my task
0148 3402             (    krn_beta5.asm):00282                   pshs  a
014A 8601             (    krn_beta5.asm):00283                   lda   #$01        Save marker into that block
014C A789A000         (    krn_beta5.asm):00284                   sta   >-$6000,x
0150 A184             (    krn_beta5.asm):00285                   cmpa  ,x          Did it ghost to block 0?
0152 3502             (    krn_beta5.asm):00286                   puls  a
0154 26ED             (    krn_beta5.asm):00287                   bne   L0111       No, keep going until ghost block is found
0156 D7A3             (    krn_beta5.asm):00288                   stb   <D.MemSz    Save # 8K mem blocks that exist
0158 3410             (    krn_beta5.asm):00289                   pshs  x           Add # of blocks to block map start
015A E3E1             (    krn_beta5.asm):00290                   addd  ,s++
                      (    krn_beta5.asm):00291                 ENDC
015C DD42             (    krn_beta5.asm):00292                   std   <D.BlkMap+2 Save block map end pointer
                      (    krn_beta5.asm):00293                       
                      (    krn_beta5.asm):00294         * [D] at this point will contain 1 of the following:
                      (    krn_beta5.asm):00295         * $0210 - 128k
                      (    krn_beta5.asm):00296         * $0220 - 256k
                      (    krn_beta5.asm):00297         * $0240 - 512k
                      (    krn_beta5.asm):00298         * $0280 - 1024k
                      (    krn_beta5.asm):00299         * $0300 - 2048k
015E C530             (    krn_beta5.asm):00300                   bitb  #%00110000  block above 128K-256K?
0160 270F             (    krn_beta5.asm):00301                   beq   L0170       yes, no need to mark block map
0162 5D               (    krn_beta5.asm):00302                   tstb              2 meg?
0163 270C             (    krn_beta5.asm):00303                   beq   L0170       yes, skip this
                      (    krn_beta5.asm):00304         * Mark blocks from 128k-256K to block $3F as NOT RAM
0165 3A               (    krn_beta5.asm):00305                   abx               add maximum block number to block map start
0166 301F             (    krn_beta5.asm):00306                   leax  -1,x        Skip good blocks that are RAM
0168 8680             (    krn_beta5.asm):00307                   lda   #NotRAM     Not RAM flag
016A C03F             (    krn_beta5.asm):00308                   subb  #$3F        Calculate # blocks to mark as not RAM
016C A780             (    krn_beta5.asm):00309         L0127     sta   ,x+         Mark them all
016E 5A               (    krn_beta5.asm):00310                   decb
016F 26FB             (    krn_beta5.asm):00311                   bne   L0127
0171 8EED00           (    krn_beta5.asm):00312         L0170     ldx   #Bt.Start   start address of the boot track in memory
0174 8612             (    krn_beta5.asm):00313                   lda   #18         size of boot track: B=0 from L0127 loop, above
0176 170776           (    krn_beta5.asm):00314                   lbsr  I.VBlock    go verify it
0179 8D2D             (    krn_beta5.asm):00315                   bsr   L01D2       go mark system map
                      (    krn_beta5.asm):00316         * See if init module is in memory already
017B 308C46           (    krn_beta5.asm):00317         L01B0     leax  <init,pc    point to 'Init' module name
017E 8D3E             (    krn_beta5.asm):00318                   bsr   link        try & link it
0180 2407             (    krn_beta5.asm):00319                   bcc   L01BF       no error, go on
0182 103F35           (    krn_beta5.asm):00320         L01B8     os9   F$Boot      error linking init, try & load boot file
0185 24F4             (    krn_beta5.asm):00321                   bcc   L01B0       got it, try init again
0187 201B             (    krn_beta5.asm):00322                   bra   L01CE       error, re-booting do D.Crash
                      (    krn_beta5.asm):00323         
                      (    krn_beta5.asm):00324         * Save pointer to init module and execute krnp2
0189 DF24             (    krn_beta5.asm):00325         L01BF     stu   <D.Init     Save init module pointer
018B A6C81B           (    krn_beta5.asm):00326                   lda   Feature1,u  Get feature byte #1 from init module
018E 8501             (    krn_beta5.asm):00327                   bita  #CRCOn      CRC feature on?
0190 2702             (    krn_beta5.asm):00328                   beq   ShowI       if not, continue
0192 0C3B             (    krn_beta5.asm):00329                   inc   <D.CRC      else inc. CRC flag
0194 8669             (    krn_beta5.asm):00330         ShowI     lda   #'i         found init module
0196 9D5E             (    krn_beta5.asm):00331                   jsr   <D.BtBug
0198 308C2D           (    krn_beta5.asm):00332         L01C1     leax  <krnp2,pc   Point to it's name
019B 8D21             (    krn_beta5.asm):00333                   bsr   link        Try to link it
019D 2407             (    krn_beta5.asm):00334                   bcc   L01D0       It worked, execute it
019F 103F35           (    krn_beta5.asm):00335                   os9   F$Boot      It doesn't exist try re-booting
01A2 24F4             (    krn_beta5.asm):00336                   bcc   L01C1       No error's, let's try to link it again
01A4 0E6B             (    krn_beta5.asm):00337         L01CE     jmp   <D.Crash    obviously can't do it, crash machine
                      (    krn_beta5.asm):00338         
01A6 6EA4             (    krn_beta5.asm):00339         L01D0     jmp   ,y          execute krnp2
                      (    krn_beta5.asm):00340         
                      (    krn_beta5.asm):00341         * Mark kernel in system memory map as used memory (256 byte blocks)
01A8 9E4E             (    krn_beta5.asm):00342         L01D2     ldx   <D.SysMem   Get system mem ptr
01AA CC80ED           (    krn_beta5.asm):00343                   ldd   #NotRAM*256+(Bt.Start/256)    B = MSB of start of the boot
01AD 3A               (    krn_beta5.asm):00344                   abx               point to Bt.Start - start of boot track
01AE 53               (    krn_beta5.asm):00345                   comb              we have $FF-$ED pages to mark as used
01AF A785             (    krn_beta5.asm):00346                   sta   b,x         Mark I/O as not RAM
01B1 8601             (    krn_beta5.asm):00347         L01DF     lda   #RAMinUse   get in use flag
01B3 A780             (    krn_beta5.asm):00348         L01E1     sta   ,x+         save it
01B5 5A               (    krn_beta5.asm):00349                   decb              done?
01B6 26FB             (    krn_beta5.asm):00350                   bne   L01E1       no, keep going
01B8 9E40             (    krn_beta5.asm):00351                   ldx   <D.BlkMap   get pointer to start of block map
01BA A7883F           (    krn_beta5.asm):00352                   sta   <$3f,x      mark kernel block as RAMinUse, instead of ModInBlk
01BD 39               (    krn_beta5.asm):00353         S.AltIRQ  rts               return
                      (    krn_beta5.asm):00354         
                      (    krn_beta5.asm):00355         * Link module pointed to by X
01BE 86C0             (    krn_beta5.asm):00356         link      lda   #Systm      Attempt to link system module
01C0 103F00           (    krn_beta5.asm):00357                   os9   F$Link
01C3 39               (    krn_beta5.asm):00358                   rts
                      (    krn_beta5.asm):00359         
01C4 496E69F4         (    krn_beta5.asm):00360         init      fcs   'Init'
01C8 6B726E70B2       (    krn_beta5.asm):00361         krnp2     fcs   'krnp2'
                      (    krn_beta5.asm):00362         
                      (    krn_beta5.asm):00363         * Service vector call pointers
01CD 00               (    krn_beta5.asm):00364         SysCalls  fcb   F$Link
01CE 0194             (    krn_beta5.asm):00365                   fdb   FLink-*-2
01D0 10               (    krn_beta5.asm):00366                   fcb   F$PrsNam
01D1 052B             (    krn_beta5.asm):00367                   fdb   FPrsNam-*-2
01D3 11               (    krn_beta5.asm):00368                   fcb   F$CmpNam
01D4 05B8             (    krn_beta5.asm):00369                   fdb   FCmpNam-*-2
01D6 91               (    krn_beta5.asm):00370                   fcb   F$CmpNam+SysState
01D7 05C0             (    krn_beta5.asm):00371                   fdb   FSCmpNam-*-2
01D9 17               (    krn_beta5.asm):00372                   fcb   F$CRC
01DA 042C             (    krn_beta5.asm):00373                   fdb   FCRC-*-2
01DC A8               (    krn_beta5.asm):00374                   fcb   F$SRqMem+SysState
01DD 0617             (    krn_beta5.asm):00375                   fdb   FSRqMem-*-2
01DF A9               (    krn_beta5.asm):00376                   fcb   F$SRtMem+SysState
01E0 0668             (    krn_beta5.asm):00377                   fdb   FSRtMem-*-2
01E2 AC               (    krn_beta5.asm):00378                   fcb   F$AProc+SysState
01E3 0AEF             (    krn_beta5.asm):00379                   fdb   FAProc-*-2
01E5 AD               (    krn_beta5.asm):00380                   fcb   F$NProc+SysState
01E6 0B6B             (    krn_beta5.asm):00381                   fdb   FNProc-*-2
01E8 AE               (    krn_beta5.asm):00382                   fcb   F$VModul+SysState
01E9 0238             (    krn_beta5.asm):00383                   fdb   FVModul-*-2
01EB B2               (    krn_beta5.asm):00384                   fcb   F$SSvc+SysState
01EC 014B             (    krn_beta5.asm):00385                   fdb   FSSvc-*-2
01EE B4               (    krn_beta5.asm):00386                   fcb   F$SLink+SysState
01EF 0166             (    krn_beta5.asm):00387                   fdb   FSLink-*-2
01F1 B5               (    krn_beta5.asm):00388                   fcb   F$Boot+SysState
01F2 06B3             (    krn_beta5.asm):00389                   fdb   FBoot-*-2
01F4 B6               (    krn_beta5.asm):00390                   fcb   F$BtMem+SysState
01F5 05FF             (    krn_beta5.asm):00391                   fdb   FSRqMem-*-2
01F7 1B               (    krn_beta5.asm):00392                   fcb   F$CpyMem
01F8 08A9             (    krn_beta5.asm):00393                   fdb   FCpyMem-*-2
01FA B8               (    krn_beta5.asm):00394                   fcb   F$Move+SysState
01FB 08F6             (    krn_beta5.asm):00395                   fdb   FMove-*-2
01FD BA               (    krn_beta5.asm):00396                   fcb   F$AllImg+SysState
01FE 0743             (    krn_beta5.asm):00397                   fdb   FAllImg-*-2
0200 BC               (    krn_beta5.asm):00398                   fcb   F$SetImg+SysState
0201 0804             (    krn_beta5.asm):00399                   fdb   FFreeLB-*-2
0203 BD               (    krn_beta5.asm):00400                   fcb   F$FreeLB+SysState
0204 07EE             (    krn_beta5.asm):00401                   fdb   FSFreeLB-*-2
0206 BE               (    krn_beta5.asm):00402                   fcb   F$FreeHB+SysState
0207 07A5             (    krn_beta5.asm):00403                   fdb   FFreeHB-*-2
0209 BF               (    krn_beta5.asm):00404                   fcb   F$AllTsk+SysState
020A 0A1B             (    krn_beta5.asm):00405                   fdb   FAllTsk-*-2
020C C0               (    krn_beta5.asm):00406                   fcb   F$DelTsk+SysState
020D 0A28             (    krn_beta5.asm):00407                   fdb   FDelTsk-*-2
020F C1               (    krn_beta5.asm):00408                   fcb   F$SetTsk+SysState
0210 0A36             (    krn_beta5.asm):00409                   fdb   FSetTsk-*-2
0212 C2               (    krn_beta5.asm):00410                   fcb   F$ResTsk+SysState
0213 0A57             (    krn_beta5.asm):00411                   fdb   FResTsk-*-2
0215 C3               (    krn_beta5.asm):00412                   fcb   F$RelTsk+SysState
0216 0A72             (    krn_beta5.asm):00413                   fdb   FRelTsk-*-2
0218 C4               (    krn_beta5.asm):00414                   fcb   F$DATLog+SysState
0219 080B             (    krn_beta5.asm):00415                   fdb   FDATLog-*-2
021B C6               (    krn_beta5.asm):00416                   fcb   F$LDAXY+SysState
021C 0820             (    krn_beta5.asm):00417                   fdb   FLDAXY-*-2
021E C8               (    krn_beta5.asm):00418                   fcb   F$LDDDXY+SysState
021F 0857             (    krn_beta5.asm):00419                   fdb   FLDDDXY-*-2
0221 C9               (    krn_beta5.asm):00420                   fcb   F$LDABX+SysState
0222 09CF             (    krn_beta5.asm):00421                   fdb   FLDABX-*-2
0224 CA               (    krn_beta5.asm):00422                   fcb   F$STABX+SysState
0225 09E6             (    krn_beta5.asm):00423                   fdb   FSTABX-*-2
0227 CD               (    krn_beta5.asm):00424                   fcb   F$ELink+SysState
0228 0132             (    krn_beta5.asm):00425                   fdb   FELink-*-2
022A CE               (    krn_beta5.asm):00426                   fcb   F$FModul+SysState
022B 041D             (    krn_beta5.asm):00427                   fdb   FFModul-*-2
022D D7               (    krn_beta5.asm):00428                   fcb   F$VBlock+SysState
022E 06BB             (    krn_beta5.asm):00429                   fdb   FVBlock-*-2
                      (    krn_beta5.asm):00430                 IFNE  H6309
                      (    krn_beta5.asm):00431                   fcb   F$DelRAM
                      (    krn_beta5.asm):00432                   fdb   FDelRAM-*-2
                      (    krn_beta5.asm):00433                 ENDC
0230 80               (    krn_beta5.asm):00434                   fcb   $80         End of table marker
                      (    krn_beta5.asm):00435         
                      (    krn_beta5.asm):00436         * SWI3 vector entry
0231 8617             (    krn_beta5.asm):00437         XSWI3     lda   #P$SWI3     point to SWI3 vector
0233 8C               (    krn_beta5.asm):00438                   fcb   $8C         skip 2 bytes
                      (    krn_beta5.asm):00439         * SWI vector entry
0234 8613             (    krn_beta5.asm):00440         XSWI      lda   #P$SWI      point to SWI vector
0236 9E50             (    krn_beta5.asm):00441                   ldx   <D.Proc     get process pointer
0238 EE86             (    krn_beta5.asm):00442                   ldu   a,x         user defined SWI[x]?
023A 270A             (    krn_beta5.asm):00443                   beq   L028E       no, go get option byte
023C 160C07           (    krn_beta5.asm):00444         GoUser    lbra  L0E5E       Yes, go call users's routine
                      (    krn_beta5.asm):00445         
                      (    krn_beta5.asm):00446         * SWI2 vector entry
023F 9E50             (    krn_beta5.asm):00447         XSWI2     ldx   <D.Proc     get current process descriptor
0241 EE8815           (    krn_beta5.asm):00448                   ldu   P$SWI2,x    any SWI vector?
0244 26F6             (    krn_beta5.asm):00449                   bne   GoUser      yes, go execute it
                      (    krn_beta5.asm):00450         * Process software interupts from a user state
                      (    krn_beta5.asm):00451         * Entry: X=Process descriptor pointer of process that made system call
                      (    krn_beta5.asm):00452         *        U=Register stack pointer
0246 DEC0             (    krn_beta5.asm):00453         L028E     ldu   <D.SysSvc    set system call processor to system side
0248 DFE4             (    krn_beta5.asm):00454                   stu   <D.XSWI2
024A DEC4             (    krn_beta5.asm):00455                   ldu   <D.SysIRQ    do the same thing for IRQ's
024C DFE8             (    krn_beta5.asm):00456                   stu   <D.XIRQ
                      (    krn_beta5.asm):00457                 IFNE  H6309
                      (    krn_beta5.asm):00458                   oim   #SysState,P$State,x    mark process as in system state
                      (    krn_beta5.asm):00459                 ELSE
024E A60C             (    krn_beta5.asm):00460                   lda   P$State,x   mark process as in system state
0250 8A80             (    krn_beta5.asm):00461                   ora   #SysState
0252 A70C             (    krn_beta5.asm):00462                   sta   P$State,x
                      (    krn_beta5.asm):00463                 ENDC
                      (    krn_beta5.asm):00464         * copy register stack to process descriptor
0254 10EF04           (    krn_beta5.asm):00465                   sts   P$SP,x      save stack pointer
0257 328901F4         (    krn_beta5.asm):00466                   leas  (P$Stack-R$Size),x    point S to register stack destination
                      (    krn_beta5.asm):00467                 IFNE  H6309
                      (    krn_beta5.asm):00468                   leau  R$Size-1,s  point to last byte of destination register stack
                      (    krn_beta5.asm):00469                   leay  -1,y        point to caller's register stack in $FEE1
                      (    krn_beta5.asm):00470                   ldw   #R$Size     size of the register stack
                      (    krn_beta5.asm):00471                   tfm   y-,u-
                      (    krn_beta5.asm):00472                   leau  ,s          needed because the TFM is u-, not -u (post, not pre)
                      (    krn_beta5.asm):00473                 ELSE
                      (    krn_beta5.asm):00474         * Note!  R$Size MUST BE an EVEN number of bytes for this to work!
025B 336C             (    krn_beta5.asm):00475                   leau  R$Size,s    point to last byte of destination register stack
025D 8606             (    krn_beta5.asm):00476                   lda   #R$Size/2   Copy stack contents
025F AEA3             (    krn_beta5.asm):00477         Loop3     ldx   ,--y
0261 AFC3             (    krn_beta5.asm):00478                   stx   ,--u
0263 4A               (    krn_beta5.asm):00479                   deca
0264 26F9             (    krn_beta5.asm):00480                   bne   Loop3
                      (    krn_beta5.asm):00481                 ENDC
0266 1CAF             (    krn_beta5.asm):00482                   andcc    #^IntMasks  Turn IRQ's back on
                      (    krn_beta5.asm):00483         * B=function code already from calling process: DON'T USE IT!
0268 AE4A             (    krn_beta5.asm):00484                   ldx   R$PC,u      get where PC was from process
026A 3001             (    krn_beta5.asm):00485                   leax  1,x         move PC past option
026C AF4A             (    krn_beta5.asm):00486                   stx   R$PC,u      save updated PC to process
                      (    krn_beta5.asm):00487         * execute function call
026E 109EC8           (    krn_beta5.asm):00488                   ldy   <D.UsrDis   get user dispatch table pointer
0271 170099           (    krn_beta5.asm):00489                   lbsr  L033B       go execute option
                      (    krn_beta5.asm):00490                 IFNE  H6309
                      (    krn_beta5.asm):00491                   aim   #^IntMasks,R$CC,u  Clear interrupt flags in caller's CC
                      (    krn_beta5.asm):00492                 ELSE
0274 A6C4             (    krn_beta5.asm):00493                   lda   R$CC,u      Clear interrupt flags in caller's CC
0276 84AF             (    krn_beta5.asm):00494                   anda  #^IntMasks
0278 A7C4             (    krn_beta5.asm):00495                   sta   R$CC,u
                      (    krn_beta5.asm):00496                 ENDC
027A 9E50             (    krn_beta5.asm):00497                   ldx   <D.Proc     get current process ptr
                      (    krn_beta5.asm):00498                 IFNE  H6309
                      (    krn_beta5.asm):00499                   aim   #^(SysState+TimOut),P$State,x    Clear system & timeout flags
                      (    krn_beta5.asm):00500                 ELSE
027C A60C             (    krn_beta5.asm):00501                   lda   P$State,x   Clear system & timeout flags
027E 845F             (    krn_beta5.asm):00502                   anda  #^(SysState+TimOut)
0280 A70C             (    krn_beta5.asm):00503                   sta   P$State,x
                      (    krn_beta5.asm):00504                 ENDC
                      (    krn_beta5.asm):00505         * Check for image change now, which lets stuff like F$MapBlk and F$ClrBlk
                      (    krn_beta5.asm):00506         * do the short-circuit thing, too.  Adds about 20 cycles to each system call.
0282 1709BC           (    krn_beta5.asm):00507                   lbsr  TstImg      it doesn't hurt to call this twice
0285 A60C             (    krn_beta5.asm):00508                   lda   P$State,x   get current state of the process
0287 AA8819           (    krn_beta5.asm):00509                   ora   <P$Signal,x is there a pending signal?
028A 973E             (    krn_beta5.asm):00510                   sta   <D.Quick    save quick return flag
028C 2705             (    krn_beta5.asm):00511                   beq   AllClr      if nothing's changed, do full checks
028E 8D31             (    krn_beta5.asm):00512         DoFull    bsr   L02DA       move the stack frame back to user state
0290 160ABE           (    krn_beta5.asm):00513                   lbra  L0D80       go back to the process
                      (    krn_beta5.asm):00514         
                      (    krn_beta5.asm):00515         * add ldu P$SP,x, etc...
     0293             (    krn_beta5.asm):00516         AllClr    equ   *
                      (    krn_beta5.asm):00517                 IFNE  H6309
                      (    krn_beta5.asm):00518                   inc   <D.QCnt
                      (    krn_beta5.asm):00519                   aim   #$1F,<D.QCnt
                      (    krn_beta5.asm):00520                   beq   DoFull      every 32 system calls, do the full check
                      (    krn_beta5.asm):00521                   ldw   #R$Size     size of the register stack
                      (    krn_beta5.asm):00522                   ldy   #Where+SWIStack  to stack at top of memory
                      (    krn_beta5.asm):00523                   orcc  #IntMasks
                      (    krn_beta5.asm):00524                   tfm   u+,y+       move the stack to the top of memory
                      (    krn_beta5.asm):00525                 ELSE
0293 967C             (    krn_beta5.asm):00526                   lda   <D.QCnt     Every 32 system calls, do the full check
0295 4C               (    krn_beta5.asm):00527                   inca
0296 841F             (    krn_beta5.asm):00528                   anda  #$1F
0298 977C             (    krn_beta5.asm):00529                   sta   <D.QCnt
029A 27F2             (    krn_beta5.asm):00530                   beq   DoFull
                      (    krn_beta5.asm):00531         * NOTE: Need to preserve X here - needed for BackTo1 routine
                      (    krn_beta5.asm):00532         *   (Currently in fnproc.asm). 145 cycles vs. original 213 cycles
029C C606             (    krn_beta5.asm):00533                   ldb   #R$Size/2   Move stack to top of memory
029E 108EFEDF         (    krn_beta5.asm):00534                   ldy   #Where+SWIStack
02A2 1A50             (    krn_beta5.asm):00535                   orcc  #IntMasks
02A4 9F11             (    krn_beta5.asm):00536                   stx   <D.IRQTmp   Save X
02A6 AEC1             (    krn_beta5.asm):00537         Loop4     ldx   ,u++
02A8 AFA1             (    krn_beta5.asm):00538                   stx   ,y++
02AA 5A               (    krn_beta5.asm):00539                   decb
02AB 26F9             (    krn_beta5.asm):00540                   bne   Loop4
02AD 9E11             (    krn_beta5.asm):00541                   ldx   <D.IRQTmp   Restore X
                      (    krn_beta5.asm):00542                 ENDC
02AF 160B11           (    krn_beta5.asm):00543                   lbra    BackTo1   otherwise simply return to the user (NOTE: immediately loads U)
                      (    krn_beta5.asm):00544         
                      (    krn_beta5.asm):00545         * Copy register stack from user to system
                      (    krn_beta5.asm):00546         * Entry: U=Ptr to Register stack in process dsc
02B2 3471             (    krn_beta5.asm):00547         L02CB     pshs  cc,x,y,u    preserve registers
02B4 E606             (    krn_beta5.asm):00548                   ldb   P$Task,x    get task #
02B6 AE04             (    krn_beta5.asm):00549                   ldx   P$SP,x      get stack pointer
02B8 17091B           (    krn_beta5.asm):00550                   lbsr  L0BF3       calculate block offset (only affects A&X)
02BB 3089A000         (    krn_beta5.asm):00551                   leax  -$6000,x    adjust pointer to where memory map will be
02BF 200F             (    krn_beta5.asm):00552                   bra   L02E9       go copy it
                      (    krn_beta5.asm):00553         
                      (    krn_beta5.asm):00554         * Copy register stack from system to user
                      (    krn_beta5.asm):00555         * Entry: U=Ptr to Register stack in process dsc
02C1 3471             (    krn_beta5.asm):00556         L02DA     pshs  cc,x,y,u    preserve registers
02C3 E606             (    krn_beta5.asm):00557                   ldb   P$Task,x    get task # of destination
02C5 AE04             (    krn_beta5.asm):00558                   ldx   P$SP,x      get stack pointer
02C7 17090C           (    krn_beta5.asm):00559                   lbsr  L0BF3       calculate block offset (only affects A&X)
02CA 3089A000         (    krn_beta5.asm):00560                   leax  -$6000,x    adjust pointer to where memory map will be
02CE 1E12             (    krn_beta5.asm):00561                   exg   x,y         swap pointers & copy
                      (    krn_beta5.asm):00562         * Copy a register stack
                      (    krn_beta5.asm):00563         * Entry: X=Source
                      (    krn_beta5.asm):00564         *        Y=Destination
                      (    krn_beta5.asm):00565         *        A=Offset into DAT image of stack
                      (    krn_beta5.asm):00566         *        B=Task #
02D0 33C6             (    krn_beta5.asm):00567         L02E9     leau  a,u         point to block # of where stack is
02D2 A641             (    krn_beta5.asm):00568                   lda   1,u         get first block
02D4 E643             (    krn_beta5.asm):00569                   ldb   3,u         get a second just in case of overlap
02D6 1A50             (    krn_beta5.asm):00570                   orcc  #IntMasks   shutdown interrupts while we do this
02D8 FDFFA5           (    krn_beta5.asm):00571                   std   >$FFA5      map blocks in
                      (    krn_beta5.asm):00572                 IFNE  H6309
                      (    krn_beta5.asm):00573                   ldw   #R$Size     get size of register stack
                      (    krn_beta5.asm):00574                   tfm   x+,y+       copy it
                      (    krn_beta5.asm):00575                 ELSE
02DB C606             (    krn_beta5.asm):00576                   ldb   #R$Size/2   # of 16 bit words to copy
02DD EE81             (    krn_beta5.asm):00577         Loop5     ldu   ,x++        Copy register stack over
02DF EFA1             (    krn_beta5.asm):00578                   stu   ,y++
02E1 5A               (    krn_beta5.asm):00579                   decb
02E2 26F9             (    krn_beta5.asm):00580                   bne   Loop5
                      (    krn_beta5.asm):00581                 ENDC
02E4 9E4C             (    krn_beta5.asm):00582                   ldx   <D.SysDAT   remap the blocks we took out
02E6 A60B             (    krn_beta5.asm):00583                   lda   $0B,x
02E8 E60D             (    krn_beta5.asm):00584                   ldb   $0D,x
02EA FDFFA5           (    krn_beta5.asm):00585                   std   >$FFA5
02ED 35F1             (    krn_beta5.asm):00586                   puls  cc,x,y,u,pc Restore & return
                      (    krn_beta5.asm):00587         
                      (    krn_beta5.asm):00588         * Process software interrupts from system state
                      (    krn_beta5.asm):00589         * Entry: U=Register stack pointer
02EF 33E4             (    krn_beta5.asm):00590         SysCall   leau  ,s          get pointer to register stack
02F1 96A4             (    krn_beta5.asm):00591                   lda   <D.SSTskN   Get system task # (0=SYSTEM, 1=GRFDRV)
02F3 0FA4             (    krn_beta5.asm):00592                   clr   <D.SSTskN   Force to System Process
02F5 3402             (    krn_beta5.asm):00593                   pshs  a           Save the system task number
02F7 A6C4             (    krn_beta5.asm):00594                   lda   ,u          Restore callers CC register (R$CC=$00)
02F9 1F8A             (    krn_beta5.asm):00595                   tfr   a,cc        make it current
02FB AE4A             (    krn_beta5.asm):00596                   ldx   R$PC,u      Get my caller's PC register
02FD 3001             (    krn_beta5.asm):00597                   leax  1,x         move PC to next position
02FF AF4A             (    krn_beta5.asm):00598                   stx   R$PC,u      Save my caller's updated PC register
0301 109EC2           (    krn_beta5.asm):00599                   ldy   <D.SysDis   get system dispatch table pointer
0304 8D07             (    krn_beta5.asm):00600                   bsr   L033B       execute system call
0306 3502             (    krn_beta5.asm):00601                   puls  a           restore system state task number
0308 160B0B           (    krn_beta5.asm):00602                   lbra  L0E2B       return to process
                      (    krn_beta5.asm):00603         
                      (    krn_beta5.asm):00604         * Entry: X = system call vector to jump to
030B 6E84             (    krn_beta5.asm):00605         Sys.Vec   jmp   ,x          execute service call
                      (    krn_beta5.asm):00606         
                      (    krn_beta5.asm):00607         * Execute system call
                      (    krn_beta5.asm):00608         * Entry: B=Function call #
                      (    krn_beta5.asm):00609         *        Y=Function dispatch table pointer (D.SysDis or D.UsrDis)
030D 58               (    krn_beta5.asm):00610         L033B     lslb              is it an I/O call? (Also x2 for offset)
030E 241F             (    krn_beta5.asm):00611                   bcc   L0345       no, go get normal vector
                      (    krn_beta5.asm):00612         * Execute I/O system calls
0310 AEA900FE         (    krn_beta5.asm):00613                   ldx   IOEntry,y   get IOMan vector
                      (    krn_beta5.asm):00614         * Execute the system call
0314 3440             (    krn_beta5.asm):00615         L034F     pshs  u           preserve register stack pointer
0316 AD9F00F0         (    krn_beta5.asm):00616                   jsr   [D.SysVec]  perform a vectored system call
031A 3540             (    krn_beta5.asm):00617                   puls  u           restore pointer
031C 1FA8             (    krn_beta5.asm):00618         L0355     tfr   cc,a        move CC to A for stack update
031E 2402             (    krn_beta5.asm):00619                   bcc   L035B       go update it if no error from call
0320 E742             (    krn_beta5.asm):00620                   stb   R$B,u       save error code to caller's B
0322 E6C4             (    krn_beta5.asm):00621         L035B     ldb   R$CC,u      get callers CC, R$CC=$00
                      (    krn_beta5.asm):00622                 IFNE  H6309
                      (    krn_beta5.asm):00623                   andd    #$2FD0    [A]=H,N,Z,V,C [B]=E,F,I
                      (    krn_beta5.asm):00624                   orr    b,a        merge them together
                      (    krn_beta5.asm):00625                 ELSE
0324 842F             (    krn_beta5.asm):00626                   anda    #$2F      [A]=H,N,Z,V,C
0326 C4D0             (    krn_beta5.asm):00627                   andb    #$D0      [B]=E,F,I
0328 3404             (    krn_beta5.asm):00628                   pshs    b         Merge them together
032A AAE0             (    krn_beta5.asm):00629                   ora    ,s+
                      (    krn_beta5.asm):00630                 ENDC
032C A7C4             (    krn_beta5.asm):00631                   sta    R$CC,u     return it to caller, R$CC=$00
032E 39               (    krn_beta5.asm):00632                   rts
                      (    krn_beta5.asm):00633         
                      (    krn_beta5.asm):00634         * Execute regular system calls
032F 4F               (    krn_beta5.asm):00635         L0345     clra              clear MSB of offset
0330 AEAB             (    krn_beta5.asm):00636                   ldx   d,y         get vector to call
0332 26E0             (    krn_beta5.asm):00637                   bne   L034F       it's initialized, go execute it
0334 53               (    krn_beta5.asm):00638                   comb              set carry for error
0335 C6D0             (    krn_beta5.asm):00639                   ldb   #E$UnkSvc   get error code
0337 20E3             (    krn_beta5.asm):00640                   bra   L0355       return with it
                      (    krn_beta5.asm):00641         
                      (    krn_beta5.asm):00642                   use   fssvc.asm
                      (        fssvc.asm):00001         **************************************************
                      (        fssvc.asm):00002         * System Call: F$SSVC
                      (        fssvc.asm):00003         *
                      (        fssvc.asm):00004         * Function: Install system calls
                      (        fssvc.asm):00005         *
                      (        fssvc.asm):00006         * Input:  Y = Address of service request init table
                      (        fssvc.asm):00007         *
                      (        fssvc.asm):00008         * Output: None
                      (        fssvc.asm):00009         *
                      (        fssvc.asm):00010         * Error:  CC = C bit set; B = error code
                      (        fssvc.asm):00011         *
0339 10AE46           (        fssvc.asm):00012         FSSvc    ldy    R$Y,u       get pointer to table
033C 2012             (        fssvc.asm):00013                  bra    SysSvc      start moving
                      (        fssvc.asm):00014         
                      (        fssvc.asm):00015         * Main move loop
033E 4F               (        fssvc.asm):00016         L036D    clra               clear MSB of table offset
033F 58               (        fssvc.asm):00017                  lslb               multiply function # by 2 to get offset into table
0340 1F03             (        fssvc.asm):00018                  tfr    d,u         copy it to U
0342 ECA1             (        fssvc.asm):00019                  ldd    ,y++        get vector to function handler
0344 30AB             (        fssvc.asm):00020                  leax   d,y         offset X from current Y
0346 DCC2             (        fssvc.asm):00021                  ldd    <D.SysDis   get system dispatch table pointer
0348 AFCB             (        fssvc.asm):00022                  stx    d,u         save vector into place
034A 2504             (        fssvc.asm):00023                  bcs    SysSvc      it was a privliged call, skip ahead
034C DCC8             (        fssvc.asm):00024                  ldd    <D.UsrDis   get user dispatch table pointer
034E AFCB             (        fssvc.asm):00025                  stx    d,u         save vector into place
0350 E6A0             (        fssvc.asm):00026         SysSvc   ldb    ,y+         get callcode
0352 C180             (        fssvc.asm):00027                  cmpb   #$80        done?
0354 26E8             (        fssvc.asm):00028                  bne    L036D       no, keep going
0356 39               (        fssvc.asm):00029                  rts                return
                      (    krn_beta5.asm):00643                   use   flink.asm
                      (        flink.asm):00001                  IFGT   Level-1
                      (        flink.asm):00002         
                      (        flink.asm):00003         **************************************************
                      (        flink.asm):00004         * System Call: F$SLink
                      (        flink.asm):00005         *
                      (        flink.asm):00006         * Function: System Link
                      (        flink.asm):00007         *
                      (        flink.asm):00008         * Input:  A = Module type
                      (        flink.asm):00009         *         X = Module name string pointer
                      (        flink.asm):00010         *         Y = Name string DAT image pointer
                      (        flink.asm):00011         *
                      (        flink.asm):00012         * Output: A = Module type
                      (        flink.asm):00013         *         B = Module revision
                      (        flink.asm):00014         *         X = Updated name string pointer
                      (        flink.asm):00015         *         Y = Module entry point
                      (        flink.asm):00016         *         U = Module pointer
                      (        flink.asm):00017         *
                      (        flink.asm):00018         * Error:  CC = C bit set; B = error code
                      (        flink.asm):00019         *
0357 10AE46           (        flink.asm):00020         FSLink   ldy    R$Y,u       get DAT image pointer of name
035A 200D             (        flink.asm):00021                  bra    L0398       skip ahead
                      (        flink.asm):00022         
                      (        flink.asm):00023         **************************************************
                      (        flink.asm):00024         * System Call: F$ELink
                      (        flink.asm):00025         *
                      (        flink.asm):00026         * Function: Link using module directory entry
                      (        flink.asm):00027         *
                      (        flink.asm):00028         * Input:  B = Module type
                      (        flink.asm):00029         *         X = Pointer to module directory entry
                      (        flink.asm):00030         *
                      (        flink.asm):00031         * Output: None
                      (        flink.asm):00032         *
                      (        flink.asm):00033         * Error:  CC = C bit set; B = error code
                      (        flink.asm):00034         *
035C 3440             (        flink.asm):00035         FELink   pshs   u           preserve register stack pointer
035E E642             (        flink.asm):00036                  ldb    R$B,u       get module type
0360 AE44             (        flink.asm):00037                  ldx    R$X,u       get pointer to module directory entry
0362 201A             (        flink.asm):00038                  bra    L03AF       skip ahead
                      (        flink.asm):00039         
                      (        flink.asm):00040                  ENDC
                      (        flink.asm):00041         
                      (        flink.asm):00042         **************************************************
                      (        flink.asm):00043         * System Call: F$Link
                      (        flink.asm):00044         *
                      (        flink.asm):00045         * Function: Link to a memory module
                      (        flink.asm):00046         *
                      (        flink.asm):00047         * Input:  X = Address of module name
                      (        flink.asm):00048         *         A = Type/Language byte
                      (        flink.asm):00049         *
                      (        flink.asm):00050         * Output: X = Advanced past module name
                      (        flink.asm):00051         *         Y = Module entry point address
                      (        flink.asm):00052         *         U = Module header address
                      (        flink.asm):00053         *         A = Module type/language byte
                      (        flink.asm):00054         *         B = Module attributes/revision byte
                      (        flink.asm):00055         *
                      (        flink.asm):00056         * Error:  CC = C bit set; B = error code
                      (        flink.asm):00057         *
     0364             (        flink.asm):00058         FLink    equ    *
                      (        flink.asm):00059                IFGT   Level-1
0364 9E50             (        flink.asm):00060                  ldx    <D.Proc     get pointer to DAT image
0366 318840           (        flink.asm):00061                  leay   P$DATImg,x  point to process DAT image
                      (        flink.asm):00062                ENDC
0369 3440             (        flink.asm):00063         L0398    pshs   u           preserve register stack pointer
036B AE44             (        flink.asm):00064                  ldx    R$X,u       get pointer to path name
036D A641             (        flink.asm):00065                  lda    R$A,u       get module type
036F 1702EC           (        flink.asm):00066                  lbsr   L068D       search module directory
0372 2579             (        flink.asm):00067                  bcs    LinkErr     not there, exit with error
0374 31C4             (        flink.asm):00068                  leay   ,u          point to module directory entry
0376 EEE4             (        flink.asm):00069                  ldu    ,s          get register stack pointer
0378 AF44             (        flink.asm):00070                  stx    R$X,u       save updated module name pointer
037A ED41             (        flink.asm):00071                  std    R$D,u       save type/language
037C 30A4             (        flink.asm):00072                  leax   ,y          point to directory entry
037E C580             (        flink.asm):00073         L03AF    bitb   #ReEnt      is it re-entrant?
0380 2608             (        flink.asm):00074                  bne    L03BB       yes, skip ahead
0382 EC06             (        flink.asm):00075                  ldd    MD$Link,x   is module busy?
0384 2704             (        flink.asm):00076                  beq    L03BB       no, go link it
0386 C6D1             (        flink.asm):00077                  ldb    #E$ModBsy   return module busy error
0388 2063             (        flink.asm):00078                  bra    LinkErr     return
                      (        flink.asm):00079         
038A EC04             (        flink.asm):00080         L03BB    ldd    MD$MPtr,x   get module pointer
038C 3416             (        flink.asm):00081                  pshs   d,x         preserve that & directory pointer
038E 10AE84           (        flink.asm):00082                  ldy    MD$MPDAT,x  get module DAT image pointer
0391 EC02             (        flink.asm):00083                  ldd    MD$MBSiz,x  get block size
0393 C31FFF           (        flink.asm):00084                  addd   #$1FFF      round it up
0396 1F89             (        flink.asm):00085                  tfr    a,b
0398 54               (        flink.asm):00086                  lsrb
0399 54               (        flink.asm):00087                  lsrb
039A 54               (        flink.asm):00088                  lsrb
039B 54               (        flink.asm):00089                  lsrb
039C 54               (        flink.asm):00090                  lsrb
                      (        flink.asm):00091         *         adda   #$02
039D 44               (        flink.asm):00092                  lsra
039E 4C               (        flink.asm):00093                  inca             instead of adda #2, above
039F 44               (        flink.asm):00094                  lsra
03A0 44               (        flink.asm):00095                  lsra
03A1 44               (        flink.asm):00096                  lsra
03A2 44               (        flink.asm):00097                  lsra
03A3 3402             (        flink.asm):00098                  pshs   a
03A5 33A4             (        flink.asm):00099                  leau   ,y          point to module DAT image
03A7 8D48             (        flink.asm):00100                  bsr    L0422       is it already linked in process space?
03A9 240E             (        flink.asm):00101                  bcc    L03EB       yes, skip ahead
03AB A6E4             (        flink.asm):00102                  lda    ,s
03AD 17060C           (        flink.asm):00103                  lbsr   L0A33       find free low block in process DAT image
03B0 2404             (        flink.asm):00104                  bcc    L03E8       found some, skip ahead
03B2 3265             (        flink.asm):00105                  leas   5,s         purge stack
03B4 2037             (        flink.asm):00106                  bra    LinkErr     return error
                      (        flink.asm):00107         
03B6 170654           (        flink.asm):00108         L03E8    lbsr   L0A8C       copy memory blocks into process DAT image
03B9 C680             (        flink.asm):00109         L03EB    ldb    #P$Links    point to memory block link counts
03BB 3A               (        flink.asm):00110                  abx                smaller and faster than leax P$Links,x
03BC A7E4             (        flink.asm):00111                  sta    ,s          save block # on stack
03BE 48               (        flink.asm):00112                  lsla               account for 2 bytes/entry
03BF 3386             (        flink.asm):00113                  leau   a,x         point to block # we want
03C1 ECC4             (        flink.asm):00114                  ldd    ,u          get link count for that block
                      (        flink.asm):00115                IFNE   H6309
                      (        flink.asm):00116                  incd               bump up by 1
                      (        flink.asm):00117                ELSE
03C3 C30001           (        flink.asm):00118                  addd   #$0001
                      (        flink.asm):00119                ENDC
03C6 2702             (        flink.asm):00120                  beq    L03FC       If wraps to 0, leave at $FFFF
03C8 EDC4             (        flink.asm):00121                  std    ,u          Otherwise, store new link count
03CA EE63             (        flink.asm):00122         L03FC    ldu    $03,s
03CC EC46             (        flink.asm):00123                  ldd    MD$Link,u
                      (        flink.asm):00124                IFNE   H6309
                      (        flink.asm):00125                  incd
                      (        flink.asm):00126                ELSE
03CE C30001           (        flink.asm):00127                  addd   #$0001
                      (        flink.asm):00128                ENDC
03D1 2702             (        flink.asm):00129                  beq    L0406
03D3 ED46             (        flink.asm):00130                  std    MD$Link,u
03D5 3574             (        flink.asm):00131         L0406    puls   b,x,y,u
03D7 170656           (        flink.asm):00132                  lbsr   CmpLBlk
03DA AF48             (        flink.asm):00133                  stx    R$U,u
03DC AE24             (        flink.asm):00134                  ldx    MD$MPtr,y
03DE 10AEA4           (        flink.asm):00135                  ldy    ,y
03E1 CC0009           (        flink.asm):00136                  ldd    #M$Exec     get offset to execution address
03E4 17069D           (        flink.asm):00137                  lbsr   L0B02       get execution offset
03E7 E348             (        flink.asm):00138                  addd   R$U,u       add it to start of module
03E9 ED46             (        flink.asm):00139                  std    R$Y,u       set execution entry point
03EB 5F               (        flink.asm):00140                  clrb               No error & return
03EC 39               (        flink.asm):00141                  rts
                      (        flink.asm):00142         
03ED 1A01             (        flink.asm):00143         LinkErr  orcc   #Carry      Error & return
03EF 35C0             (        flink.asm):00144                  puls   u,pc
                      (        flink.asm):00145         
03F1 9E50             (        flink.asm):00146         L0422    ldx    <D.Proc     get pointer to current process
03F3 318840           (        flink.asm):00147                  leay   P$DATImg,x  point to process DAT image
03F6 4F               (        flink.asm):00148                  clra
03F7 3436             (        flink.asm):00149                  pshs   d,x,y
03F9 C008             (        flink.asm):00150                  subb   #DAT.BlCt
03FB 50               (        flink.asm):00151                  negb
03FC 58               (        flink.asm):00152                  lslb
03FD 31A5             (        flink.asm):00153                  leay   b,y
                      (        flink.asm):00154                IFNE   H6309
03FF                  (        flink.asm):00155         L0430    ldw    ,s          Get counter
                      (        flink.asm):00156                ELSE
03FF AEE4             (        flink.asm):00157         L0430    ldx    ,s
                      (        flink.asm):00158                ENDC
0401 3460             (        flink.asm):00159                  pshs   u,y
0403 ECA1             (        flink.asm):00160         L0434    ldd    ,y++
0405 10A3C1           (        flink.asm):00161                  cmpd   ,u++
0408 260E             (        flink.asm):00162                  bne    L0449
                      (        flink.asm):00163                IFNE   H6309
                      (        flink.asm):00164                  decw               Dec counter
                      (        flink.asm):00165                ELSE
040A 301F             (        flink.asm):00166                  leax   -1,x
                      (        flink.asm):00167                ENDC
040C 26F5             (        flink.asm):00168                  bne    L0434       If not done, keep going
040E 3546             (        flink.asm):00169                  puls   d,u
0410 A364             (        flink.asm):00170                  subd   4,s
0412 54               (        flink.asm):00171                  lsrb
0413 E7E4             (        flink.asm):00172                  stb    ,s
0415 5F               (        flink.asm):00173                  clrb
0416 35B6             (        flink.asm):00174                  puls   d,x,y,pc    Restore regs & return
                      (        flink.asm):00175         
0418 3560             (        flink.asm):00176         L0449    puls   u,y
041A 313E             (        flink.asm):00177                  leay   -2,y
041C 10AC64           (        flink.asm):00178                  cmpy   4,s
041F 24DE             (        flink.asm):00179                  bcc    L0430
0421 35B6             (        flink.asm):00180                  puls   d,x,y,pc
                      (    krn_beta5.asm):00644                   use   fvmodul.asm
                      (      fvmodul.asm):00001         **************************************************
                      (      fvmodul.asm):00002         * System Call: F$VModul
                      (      fvmodul.asm):00003         *
                      (      fvmodul.asm):00004         * Function: Verify a module
                      (      fvmodul.asm):00005         *
                      (      fvmodul.asm):00006         * Input:  X = Address of module to verify
                      (      fvmodul.asm):00007         *
                      (      fvmodul.asm):00008         * Output: U = Address of module directory entry
                      (      fvmodul.asm):00009         *
                      (      fvmodul.asm):00010         * Error:  CC = C bit set; B = error code
                      (      fvmodul.asm):00011         *
0423 3440             (      fvmodul.asm):00012         FVModul  pshs   u           preserve register stack pointer
0425 AE44             (      fvmodul.asm):00013                  ldx    R$X,u       get block offset
0427 10AE41           (      fvmodul.asm):00014                  ldy    R$D,u       get DAT image pointer
042A 8D06             (      fvmodul.asm):00015                  bsr    L0463       validate it
042C AEE4             (      fvmodul.asm):00016                  ldx    ,s          get register stack pointer
042E EF08             (      fvmodul.asm):00017                  stu    R$U,x       save address of module directory entry
0430 35C0             (      fvmodul.asm):00018                  puls   u,pc        restore & return
                      (      fvmodul.asm):00019         
                      (      fvmodul.asm):00020         * Validate module - shortcut for calls within OS9p1 go here (ex. OS9Boot)
                      (      fvmodul.asm):00021         * Entry: X=Module block offset
                      (      fvmodul.asm):00022         *        Y=Module DAT image pointer
0432 3430             (      fvmodul.asm):00023         L0463    pshs   x,y         save block offset & DAT Image ptr
0434 17011B           (      fvmodul.asm):00024                  lbsr   L0586       Go check module ID & header parity
0437 252A             (      fvmodul.asm):00025                  bcs    L0495       Error, exit
0439 CC0006           (      fvmodul.asm):00026                  ldd    #M$Type     Get offset to module type
043C 170645           (      fvmodul.asm):00027                  lbsr   L0B02       get it
043F C40F             (      fvmodul.asm):00028                  andb   #LangMask   Just keep language mask
0441 3406             (      fvmodul.asm):00029                  pshs   d           Preserve ??? & language
0443 CC0004           (      fvmodul.asm):00030                  ldd    #M$Name     get offset to module name
0446 17063B           (      fvmodul.asm):00031                  lbsr   L0B02       Get it
0449 308B             (      fvmodul.asm):00032                  leax   d,x         Point X to module name
044B 3502             (      fvmodul.asm):00033                  puls   a           Restore type/language
044D 17020E           (      fvmodul.asm):00034                  lbsr   L068D
0450 3502             (      fvmodul.asm):00035                  puls   a
0452 2511             (      fvmodul.asm):00036                  bcs    L0497
0454 C40F             (      fvmodul.asm):00037                  andb   #$0F
                      (      fvmodul.asm):00038                IFNE   H6309
                      (      fvmodul.asm):00039                  subr   a,b
                      (      fvmodul.asm):00040                ELSE
0456 3402             (      fvmodul.asm):00041                  pshs   a
0458 E0E0             (      fvmodul.asm):00042                  subb   ,s+
                      (      fvmodul.asm):00043                ENDC
045A 2509             (      fvmodul.asm):00044                  blo    L0497         If wrapped, skip ahead
045C C6E7             (      fvmodul.asm):00045                  ldb    #E$KwnMod
045E 8C               (      fvmodul.asm):00046                  fcb    $8C        skip 2 bytes
045F C6CE             (      fvmodul.asm):00047         L0491    ldb    #E$DirFul
0461 1A01             (      fvmodul.asm):00048         L0493    orcc   #Carry
0463 35B0             (      fvmodul.asm):00049         L0495    puls   x,y,pc
                      (      fvmodul.asm):00050         
0465 AEE4             (      fvmodul.asm):00051         L0497    ldx    ,s
                      (      fvmodul.asm):00052                IFNE   H6309
                      (      fvmodul.asm):00053                  bsr    L0524
                      (      fvmodul.asm):00054                ELSE
0467 170087           (      fvmodul.asm):00055                  lbsr   L0524
                      (      fvmodul.asm):00056                ENDC
046A 25F3             (      fvmodul.asm):00057                  bcs    L0491
046C 10AFC4           (      fvmodul.asm):00058                  sty    ,u
046F AF44             (      fvmodul.asm):00059                  stx    MD$MPtr,u
                      (      fvmodul.asm):00060                IFNE   H6309
                      (      fvmodul.asm):00061                  clrd
                      (      fvmodul.asm):00062                ELSE
0471 4F               (      fvmodul.asm):00063                  clra
0472 5F               (      fvmodul.asm):00064                  clrb
                      (      fvmodul.asm):00065                ENDC
0473 ED46             (      fvmodul.asm):00066                  std    MD$Link,u
0475 CC0002           (      fvmodul.asm):00067                  ldd    #M$Size     Get offset to size of module
0478 170609           (      fvmodul.asm):00068                  lbsr   L0B02       Get it
                      (      fvmodul.asm):00069                IFNE   H6309
                      (      fvmodul.asm):00070                  addr   x,d         Add it to module ptr
                      (      fvmodul.asm):00071                ELSE
047B 3410             (      fvmodul.asm):00072                  pshs   x
047D E3E1             (      fvmodul.asm):00073                  addd   ,s++
                      (      fvmodul.asm):00074                ENDC
047F ED42             (      fvmodul.asm):00075                  std    MD$MBSiz,u
0481 10AED4           (      fvmodul.asm):00076                  ldy    [MD$MPDAT,u] get pointer to module DAT
0484 9E44             (      fvmodul.asm):00077                  ldx    <D.ModDir   get module directory pointer
0486 3440             (      fvmodul.asm):00078                  pshs   u           save module pointer
0488 8C               (      fvmodul.asm):00079                  fcb    $8C         skip 2 bytes
0489 3008             (      fvmodul.asm):00080         L04BC    leax   MD$ESize,x  move to next entry
048B 9C58             (      fvmodul.asm):00081         L04BE    cmpx   <D.ModEnd
048D 240B             (      fvmodul.asm):00082                  bcc    L04CD
048F ACE4             (      fvmodul.asm):00083                  cmpx   ,s          match?
0491 27F6             (      fvmodul.asm):00084                  beq    L04BC       no, keep looking
0493 10AC94           (      fvmodul.asm):00085                  cmpy   [MD$MPDAT,x] DAT match?
0496 26F1             (      fvmodul.asm):00086                  bne    L04BC       no, keep looking
0498 8D25             (      fvmodul.asm):00087                  bsr    L04F2
049A 3540             (      fvmodul.asm):00088         L04CD    puls   u
049C 9E40             (      fvmodul.asm):00089                  ldx    <D.BlkMap   Get ptr to block map
049E EC42             (      fvmodul.asm):00090                  ldd    MD$MBSiz,u  Get size of module
04A0 C31FFF           (      fvmodul.asm):00091                  addd   #$1FFF      Round up to nearest 8K block
04A3 44               (      fvmodul.asm):00092                  lsra               Divide by 32
04A4 44               (      fvmodul.asm):00093                  lsra
04A5 44               (      fvmodul.asm):00094                  lsra
04A6 44               (      fvmodul.asm):00095                  lsra
04A7 44               (      fvmodul.asm):00096                  lsra
04A8 10AEC4           (      fvmodul.asm):00097                  ldy    MD$MPDAT,u
                      (      fvmodul.asm):00098                IFNE   H6309
                      (      fvmodul.asm):00099                  tfr    a,e
04AB                  (      fvmodul.asm):00100         L04DE    ldd    ,y++
                      (      fvmodul.asm):00101                  oim    #ModBlock,d,x
                      (      fvmodul.asm):00102                  dece
                      (      fvmodul.asm):00103                ELSE
04AB 3412             (      fvmodul.asm):00104         L04DE    pshs   a,x         save block size, blkmap
04AD ECA1             (      fvmodul.asm):00105                  ldd    ,y++        D = image block #
04AF 308B             (      fvmodul.asm):00106                  leax   d,x         X = blkmap ptr
04B1 E684             (      fvmodul.asm):00107                  ldb    ,x          get block marker
04B3 CA02             (      fvmodul.asm):00108                  orb    #ModBlock   set module in block
04B5 E784             (      fvmodul.asm):00109                  stb    ,x          marker
04B7 3512             (      fvmodul.asm):00110                  puls   x,a
04B9 4A               (      fvmodul.asm):00111                  deca               count--
                      (      fvmodul.asm):00112                ENDC
04BA 26EF             (      fvmodul.asm):00113                  bne    L04DE       no, keep going
04BC 5F               (      fvmodul.asm):00114                  clrb               clear carry
04BD 35B0             (      fvmodul.asm):00115                  puls   x,y,pc      return
                      (      fvmodul.asm):00116         
04BF 3476             (      fvmodul.asm):00117         L04F2    pshs   d,x,y,u
                      (      fvmodul.asm):00118         * LCB - 6809 - this can be slightly sped up by swapping roles
                      (      fvmodul.asm):00119         *   of X and Y
04C1 AE84             (      fvmodul.asm):00120                  ldx    ,x
                      (      fvmodul.asm):00121                IFNE   H6309
                      (      fvmodul.asm):00122                  tfr    x,w         Dupe to faster index register
                      (      fvmodul.asm):00123                  clrd
04C3                  (      fvmodul.asm):00124         L04FA    ldy    ,w
                      (      fvmodul.asm):00125                  beq    L0503
                      (      fvmodul.asm):00126                  std    ,w++
                      (      fvmodul.asm):00127                  bra    L04FA
                      (      fvmodul.asm):00128         
04C3                  (      fvmodul.asm):00129         L0503    ldy    2,s
                      (      fvmodul.asm):00130                ELSE
04C3 3410             (      fvmodul.asm):00131                  pshs   x
04C5 4F               (      fvmodul.asm):00132                  clra               D=0000
04C6 5F               (      fvmodul.asm):00133                  clrb
04C7 10AE84           (      fvmodul.asm):00134         L04FA    ldy   ,x           last entry?
04CA 2704             (      fvmodul.asm):00135                  beq   L0503        ..yes
04CC ED81             (      fvmodul.asm):00136                  std   ,x++         no, clear
04CE 20F7             (      fvmodul.asm):00137                  bra   L04FA        and loop
                      (      fvmodul.asm):00138         
                      (      fvmodul.asm):00139         * Entry: U=Ptr to current entry in module directory
                      (      fvmodul.asm):00140         *        Y=Ptr to entry in module directory we are comparing to
04D0 3510             (      fvmodul.asm):00141         L0503    puls  x
04D2 10AE62           (      fvmodul.asm):00142                  ldy    2,s         Get ptr to module dir entry we are comparing with
                      (      fvmodul.asm):00143                ENDC
04D5 EEC4             (      fvmodul.asm):00144                  ldu    MD$MPDAT,u  Get DAT img ptr for module
04D7 3506             (      fvmodul.asm):00145                  puls   d
04D9 ACA4             (      fvmodul.asm):00146         L050C    cmpx   MD$MPDAT,y  Same as DAT img ptr for other module?
04DB 260B             (      fvmodul.asm):00147                  bne    L051B       No, check next one
04DD EFA4             (      fvmodul.asm):00148                  stu    MD$MPDAT,y  Match; save current entry ptr here
04DF 10A322           (      fvmodul.asm):00149                  cmpd   MD$MBSiz,y  >memory block size already here?
                      (      fvmodul.asm):00150         * 6809/6309 LCB - couldn't we change next 2 lines to blo L051B
04E2 2402             (      fvmodul.asm):00151                  bhs    L0519       Yes, use new one
04E4 EC22             (      fvmodul.asm):00152                  ldd    MD$MBSiz,y  No, get original and use that size instead
04E6 ED22             (      fvmodul.asm):00153         L0519    std    MD$MBSiz,y
04E8 3128             (      fvmodul.asm):00154         L051B    leay   MD$ESize,y  Bump ptr to next module dir entry
04EA 109C58           (      fvmodul.asm):00155                  cmpy   <D.ModEnd   Are we at end of module dir?
04ED 26EA             (      fvmodul.asm):00156                  bne    L050C       No,keep checking
04EF 35F0             (      fvmodul.asm):00157                  puls   x,y,u,pc
                      (      fvmodul.asm):00158         
                      (      fvmodul.asm):00159         * Exit: B=MMU block # of some sort
04F1 3470             (      fvmodul.asm):00160         L0524    pshs   x,y,u
04F3 CC0002           (      fvmodul.asm):00161                  ldd    #M$Size     Offset to module size
04F6 17058B           (      fvmodul.asm):00162                  lbsr   L0B02       Go get module size
04F9 E3E4             (      fvmodul.asm):00163                  addd   ,s          Add to value
04FB C31FFF           (      fvmodul.asm):00164                  addd   #$1FFF      Calc MMU block #
04FE 44               (      fvmodul.asm):00165                  lsra
04FF 44               (      fvmodul.asm):00166                  lsra
0500 44               (      fvmodul.asm):00167                  lsra
0501 44               (      fvmodul.asm):00168                  lsra
0502 44               (      fvmodul.asm):00169                  lsra
0503 1F89             (      fvmodul.asm):00170                  tfr    a,b         Move block # to B
0505 3404             (      fvmodul.asm):00171                  pshs   b           Save it as well
0507 53               (      fvmodul.asm):00172                  comb               one byte shorter than incb;lslb;negb
0508 58               (      fvmodul.asm):00173                  lslb               (D=-B is what we are doing)
0509 1D               (      fvmodul.asm):00174                  sex
050A 8D0E             (      fvmodul.asm):00175                  bsr    L054E
050C 240A             (      fvmodul.asm):00176                  bcc    L054C
050E 103F52           (      fvmodul.asm):00177                  os9    F$GCMDir    get rid of empty slots in module directory
                      (      fvmodul.asm):00178                IFNE   H6309
                      (      fvmodul.asm):00179                  tfr    0,u
                      (      fvmodul.asm):00180                ELSE
0511 CE0000           (      fvmodul.asm):00181                  ldu    #$0000
                      (      fvmodul.asm):00182                ENDC
0514 EF65             (      fvmodul.asm):00183                  stu    $05,s       Save $0000 so U is 0 in puls below
0516 8D02             (      fvmodul.asm):00184                  bsr    L054E
0518 35F4             (      fvmodul.asm):00185         L054C    puls   b,x,y,u,pc
                      (      fvmodul.asm):00186         
                      (      fvmodul.asm):00187         * Entry: D=negative offset from end of module Dir DAT Img)
051A 9E5A             (      fvmodul.asm):00188         L054E    ldx    <D.ModDAT   get end ptr of Module Dir DAT image
051C 308B             (      fvmodul.asm):00189                  leax   d,x         Add our negative offset
051E 9C58             (      fvmodul.asm):00190                  cmpx   <D.ModEnd   Is that past the end of the module directory?
0520 252D             (      fvmodul.asm):00191                  blo    S.Poll      no, skip ahead
0522 EE67             (      fvmodul.asm):00192                  ldu    7,s         Yes, get U from stack (0 means we compacted mod dir)
0524 2614             (      fvmodul.asm):00193                  bne    L056E       Not compacted, skip ahead
0526 109E58           (      fvmodul.asm):00194                  ldy    <D.ModEnd   Get ptr to end of module directory
0529 3128             (      fvmodul.asm):00195                  leay   MD$ESize,y  Bump up by 1 entry
                      (      fvmodul.asm):00196                IFNE   H6309
                      (      fvmodul.asm):00197                  cmpr   x,y         Offset we did past new entry?
                      (      fvmodul.asm):00198                ELSE
052B 3410             (      fvmodul.asm):00199                  pshs   x           Offset we did past new entry?
052D 10ACE1           (      fvmodul.asm):00200                  cmpy   ,s++
                      (      fvmodul.asm):00201                ENDC
0530 221D             (      fvmodul.asm):00202                  bhi    S.Poll      Yes, skip ahead
0532 109F58           (      fvmodul.asm):00203                  sty    <D.ModEnd   No, save new module directory end ptr
0535 3138             (      fvmodul.asm):00204                  leay   -MD$ESize,y Bump ptr back on entry
0537 10AF67           (      fvmodul.asm):00205                  sty    $07,s       Save that as new U on exit
053A 9F5A             (      fvmodul.asm):00206         L056E    stx    <D.ModDAT   Save new Module Dir DAT image end ptr
                      (      fvmodul.asm):00207                IFNE   H6309
                      (      fvmodul.asm):00208                  ldd    $05,s       Get source ptr
                      (      fvmodul.asm):00209                  stx    $05,s
                      (      fvmodul.asm):00210                  ldf    2,s
                      (      fvmodul.asm):00211                  clre
                      (      fvmodul.asm):00212                  rolw
                      (      fvmodul.asm):00213                  tfm    d+,x+
                      (      fvmodul.asm):00214                  stw    ,x          Save 0
                      (      fvmodul.asm):00215                ELSE
053C 10AE65           (      fvmodul.asm):00216                  ldy   5,s
053F E662             (      fvmodul.asm):00217                  ldb   2,s          B=block count
0541 AF65             (      fvmodul.asm):00218                  stx   5,s          return dir datimg ptr
0543 EEA1             (      fvmodul.asm):00219         L0577    ldu   ,y++         copy images
0545 EF81             (      fvmodul.asm):00220                  stu   ,x++         to new mod dat entry
0547 5A               (      fvmodul.asm):00221                  decb
0548 26F9             (      fvmodul.asm):00222                  bne   L0577
                      (      fvmodul.asm):00223         * 6809/6309 LCB - stb ,x - same size, faster (4 vs 6). Still need CLR
                      (      fvmodul.asm):00224         *  for clr 1,x to make sure carry is cleared
054A E784             (      fvmodul.asm):00225                  stb   ,x           zero flag
054C 6F01             (      fvmodul.asm):00226                  clr   1,x          & clear carry
                      (      fvmodul.asm):00227                ENDC
054E 39               (      fvmodul.asm):00228                  rts
                      (      fvmodul.asm):00229         
                      (      fvmodul.asm):00230         * Default interrupt handling routine on first booting OS9p1
054F 1A01             (      fvmodul.asm):00231         S.Poll   orcc  #Carry
0551 39               (      fvmodul.asm):00232                  rts
                      (      fvmodul.asm):00233         
                      (      fvmodul.asm):00234         * Check module ID & calculate module header parity & CRC
                      (      fvmodul.asm):00235         * Entry: X=Block offset of module
                      (      fvmodul.asm):00236         *        Y=DAT image pointer of module
0552 3430             (      fvmodul.asm):00237         L0586    pshs  x,y          save block offset & DAT pointer
                      (      fvmodul.asm):00238                IFNE  H6309
                      (      fvmodul.asm):00239                  clrd               M$ID offset
                      (      fvmodul.asm):00240                ELSE
0554 4F               (      fvmodul.asm):00241                  clra               M$ID offset
0555 5F               (      fvmodul.asm):00242                  clrb
                      (      fvmodul.asm):00243                ENDC
0556 17052B           (      fvmodul.asm):00244                  lbsr  L0B02        get module ID
0559 108387CD         (      fvmodul.asm):00245                  cmpd  #M$ID12      legal module?
055D 2704             (      fvmodul.asm):00246                  beq   L0597        yes, calculate header parity
055F C6CD             (      fvmodul.asm):00247                  ldb   #E$BMID      get bad module ID error
0561 2062             (      fvmodul.asm):00248                  bra   L05F3        return error
                      (      fvmodul.asm):00249         * Calculate module header parity
0563 3002             (      fvmodul.asm):00250         L0597    leax  2,x          point to start location of header calc
0565 17050A           (      fvmodul.asm):00251                  lbsr  AdjBlk0      adjust it for block 0
                      (      fvmodul.asm):00252                IFNE  H6309
                      (      fvmodul.asm):00253                  ldw   #($4A*256+M$Revs) Get initial value & count (7 bytes of header)
0568                  (      fvmodul.asm):00254         L05A2    lbsr  LDAXY        get a byte from module
                      (      fvmodul.asm):00255                  eorr  a,e          add it into running parity
                      (      fvmodul.asm):00256                  decf               done full header?
                      (      fvmodul.asm):00257                  bne   L05A2        no, keep going
                      (      fvmodul.asm):00258                  ince               valid parity?
                      (      fvmodul.asm):00259                ELSE
0568 327F             (      fvmodul.asm):00260                  leas  -1,s         make var
056A CC4A07           (      fvmodul.asm):00261                  ldd   #($4A*256+M$Revs) Get initial value & count (7 bytes of header)
056D A7E4             (      fvmodul.asm):00262         L05A2    sta   ,s           save crc
056F 1704E7           (      fvmodul.asm):00263                  lbsr  LDAXY        get next byte
0572 A8E4             (      fvmodul.asm):00264                  eora  ,s           do crc
0574 5A               (      fvmodul.asm):00265                  decb               more?
0575 26F6             (      fvmodul.asm):00266                  bne   L05A2        ..loop
0577 3261             (      fvmodul.asm):00267                  leas  1,s          drop var
0579 4C               (      fvmodul.asm):00268                  inca               $FF+1 = 00
                      (      fvmodul.asm):00269                ENDC
057A 2704             (      fvmodul.asm):00270                  beq   L05B5        yes, skip ahead
057C C6EC             (      fvmodul.asm):00271                  ldb   #E$BMHP      get module header parity error
057E 2045             (      fvmodul.asm):00272                  bra   L05F3        return with error
                      (      fvmodul.asm):00273         
0580 3530             (      fvmodul.asm):00274         L05B5    puls  x,y          restore module pointer & DAT pointer
                      (      fvmodul.asm):00275         * this checks if the module CRC checking is on or off
0582 963B             (      fvmodul.asm):00276                  lda   <D.CRC       is CRC checking on?
0584 2603             (      fvmodul.asm):00277                  bne   L05BA        yes - go check it
                      (      fvmodul.asm):00278                IFNE  H6309
                      (      fvmodul.asm):00279                  clrd               no, clear out
                      (      fvmodul.asm):00280                ELSE
0586 4F               (      fvmodul.asm):00281                  clra
0587 5F               (      fvmodul.asm):00282                  clrb
                      (      fvmodul.asm):00283                ENDC
0588 39               (      fvmodul.asm):00284                  rts                and return
                      (      fvmodul.asm):00285         
                      (      fvmodul.asm):00286         * Begin checking Module CRC
                      (      fvmodul.asm):00287         * Entry: X=Module pointer
                      (      fvmodul.asm):00288         *        Y=DAT image pointer of module
0589 CC0002           (      fvmodul.asm):00289         L05BA    ldd   #M$Size      get offset to module size
058C 1704F5           (      fvmodul.asm):00290                  lbsr  L0B02        get module size
                      (      fvmodul.asm):00291                IFNE  H6309
                      (      fvmodul.asm):00292                  tfr   d,w          move length to W
                      (      fvmodul.asm):00293                  pshs  y,x          preserve [X]=Buffer pointer,[Y]=DAT pointer
                      (      fvmodul.asm):00294                ELSE
058F 3436             (      fvmodul.asm):00295                  pshs  y,x,d        preserve [X]=Buffer pointer,[Y]=DAT pointer
                      (      fvmodul.asm):00296                ENDC
0591 CCFFFF           (      fvmodul.asm):00297                  ldd   #$FFFF       initial CRC value of $FFFFFF
0594 3406             (      fvmodul.asm):00298                  pshs  d            set up local 24 bit variable
0596 3404             (      fvmodul.asm):00299                  pshs  b
0598 1704D7           (      fvmodul.asm):00300                  lbsr  AdjBlk0      adjust module pointer into block 0 for mapping
059B 33E4             (      fvmodul.asm):00301                  leau  ,s           point to CRC accumulator
                      (      fvmodul.asm):00302         * Loop: W=# bytes left to use in CRC calc
     059D             (      fvmodul.asm):00303         L05CB    equ   *
                      (      fvmodul.asm):00304                IFNE  H6309
                      (      fvmodul.asm):00305                  tstf               on 256 byte boundary?
                      (      fvmodul.asm):00306                ELSE
059D 5D               (      fvmodul.asm):00307                  tstb
                      (      fvmodul.asm):00308                ENDC
059E 260A             (      fvmodul.asm):00309                  bne   L05D8        no, keep going
05A0 3410             (      fvmodul.asm):00310                  pshs  x            give up some time to system
05A2 8E0001           (      fvmodul.asm):00311                  ldx   #1
05A5 103F0A           (      fvmodul.asm):00312                  os9   F$Sleep
05A8 3510             (      fvmodul.asm):00313                  puls  x            restore module pointer
05AA 1704AC           (      fvmodul.asm):00314         L05D8    lbsr  LDAXY        get a byte from module into A
05AD 8D1A             (      fvmodul.asm):00315                  bsr   CRCCalc      add it to running CRC
                      (      fvmodul.asm):00316                IFNE  H6309
                      (      fvmodul.asm):00317                  decw               Dec # bytes left to calculate CRC with
                      (      fvmodul.asm):00318                ELSE
05AF EC63             (      fvmodul.asm):00319                  ldd   3,s
05B1 830001           (      fvmodul.asm):00320                  subd  #$0001
05B4 ED63             (      fvmodul.asm):00321                  std   3,s
                      (      fvmodul.asm):00322                ENDC
05B6 26E5             (      fvmodul.asm):00323                  bne   L05CB        Still more, continue
                      (      fvmodul.asm):00324                IFNE  H6309
                      (      fvmodul.asm):00325                  puls  b,x          yes, restore CRC
                      (      fvmodul.asm):00326                ELSE
05B8 3534             (      fvmodul.asm):00327                  puls  b,x,y        yes, restore CRC
                      (      fvmodul.asm):00328                ENDC
05BA C180             (      fvmodul.asm):00329                  cmpb  #CRCCon1     CRC MSB match constant?
05BC 2605             (      fvmodul.asm):00330                  bne   L05F1        no, exit with error
05BE 8C0FE3           (      fvmodul.asm):00331                  cmpx  #CRCCon23    LSW match constant?
05C1 2704             (      fvmodul.asm):00332                  beq   L05F5        yes, skip ahead
05C3 C6E8             (      fvmodul.asm):00333         L05F1    ldb   #E$BMCRC     Bad Module CRC error
05C5 1A01             (      fvmodul.asm):00334         L05F3    orcc  #Carry       Set up for error
05C7 35B0             (      fvmodul.asm):00335         L05F5    puls  x,y,pc       exit
                      (      fvmodul.asm):00336         
                      (      fvmodul.asm):00337         * Calculate 24 bit CRC
                      (      fvmodul.asm):00338         * Entry: A=Byte to add to CRC
                      (      fvmodul.asm):00339         *        U=Pointer to 24 bit CRC accumulator
                      (      fvmodul.asm):00340         *
                      (      fvmodul.asm):00341         * Future reference note: Do not use W unless preserved, contains module
                      (      fvmodul.asm):00342         *                        byte counts from routines that come here!!
05C9 A8C4             (      fvmodul.asm):00343         CRCCalc  eora  ,u
05CB 3402             (      fvmodul.asm):00344                  pshs  a
05CD EC41             (      fvmodul.asm):00345                  ldd   1,u
05CF EDC4             (      fvmodul.asm):00346                  std   ,u
05D1 4F               (      fvmodul.asm):00347                  clra
05D2 E6E4             (      fvmodul.asm):00348                  ldb   ,s
                      (      fvmodul.asm):00349                IFNE  H6309
                      (      fvmodul.asm):00350                  lsld
                      (      fvmodul.asm):00351                ELSE
05D4 58               (      fvmodul.asm):00352                  aslb
05D5 49               (      fvmodul.asm):00353                  rola
                      (      fvmodul.asm):00354                ENDC
05D6 A841             (      fvmodul.asm):00355                  eora  1,u
05D8 ED41             (      fvmodul.asm):00356                  std   1,u
05DA 5F               (      fvmodul.asm):00357                  clrb
05DB A6E4             (      fvmodul.asm):00358                  lda   ,s
                      (      fvmodul.asm):00359                IFNE  H6309
                      (      fvmodul.asm):00360                  lsrd
                      (      fvmodul.asm):00361                  lsrd
                      (      fvmodul.asm):00362                  eord  1,u
                      (      fvmodul.asm):00363                ELSE
05DD 44               (      fvmodul.asm):00364                  lsra
05DE 56               (      fvmodul.asm):00365                  rorb
05DF 44               (      fvmodul.asm):00366                  lsra
05E0 56               (      fvmodul.asm):00367                  rorb
05E1 A841             (      fvmodul.asm):00368                  eora  1,u
05E3 E842             (      fvmodul.asm):00369                  eorb  2,u
                      (      fvmodul.asm):00370                ENDC
05E5 ED41             (      fvmodul.asm):00371                  std   1,u
05E7 A6E4             (      fvmodul.asm):00372                  lda   ,s
05E9 48               (      fvmodul.asm):00373                  lsla
05EA A8E4             (      fvmodul.asm):00374                  eora  ,s
05EC A7E4             (      fvmodul.asm):00375                  sta   ,s
05EE 48               (      fvmodul.asm):00376                  lsla
05EF 48               (      fvmodul.asm):00377                  lsla
05F0 A8E4             (      fvmodul.asm):00378                  eora  ,s
05F2 A7E4             (      fvmodul.asm):00379                  sta   ,s
05F4 48               (      fvmodul.asm):00380                  lsla
05F5 48               (      fvmodul.asm):00381                  lsla
05F6 48               (      fvmodul.asm):00382                  lsla
05F7 48               (      fvmodul.asm):00383                  lsla
05F8 A8E0             (      fvmodul.asm):00384                  eora  ,s+
05FA 2A0B             (      fvmodul.asm):00385                  bpl   L0635
                      (      fvmodul.asm):00386                IFNE  H6309
                      (      fvmodul.asm):00387                  eim   #$80,,u
                      (      fvmodul.asm):00388                  eim   #$21,2,u
                      (      fvmodul.asm):00389                ELSE
05FC CC8021           (      fvmodul.asm):00390                  ldd   #$8021
05FF A8C4             (      fvmodul.asm):00391                  eora  ,u
0601 A7C4             (      fvmodul.asm):00392                  sta   ,u
0603 E842             (      fvmodul.asm):00393                  eorb  2,u
0605 E742             (      fvmodul.asm):00394                  stb   2,u
                      (      fvmodul.asm):00395                ENDC
0607 39               (      fvmodul.asm):00396         L0635    rts
                      (      fvmodul.asm):00397         
                      (      fvmodul.asm):00398         **************************************************
                      (      fvmodul.asm):00399         * System Call: F$CRC
                      (      fvmodul.asm):00400         *
                      (      fvmodul.asm):00401         * Function: Compute CRC
                      (      fvmodul.asm):00402         *
                      (      fvmodul.asm):00403         * Input:  X = Address to start computation
                      (      fvmodul.asm):00404         *         Y = Byte count
                      (      fvmodul.asm):00405         *         U = Address of 3 byte CRC accumulator
                      (      fvmodul.asm):00406         *
                      (      fvmodul.asm):00407         * Output: CRC accumulator is updated
                      (      fvmodul.asm):00408         *
                      (      fvmodul.asm):00409         * Error:  CC = C bit set; B = error code
                      (      fvmodul.asm):00410         *
0608 EC46             (      fvmodul.asm):00411         FCRC     ldd   R$Y,u        get # bytes to do
060A 273C             (      fvmodul.asm):00412                  beq   L0677        nothing there, so nothing to do, return
060C AE44             (      fvmodul.asm):00413                  ldx   R$X,u        get caller's buffer pointer
060E 3416             (      fvmodul.asm):00414                  pshs  d,x          save # bytes & buffer pointer
0610 327D             (      fvmodul.asm):00415                  leas  -3,s         allocate a 3 byte buffer
0612 9E50             (      fvmodul.asm):00416                  ldx   <D.Proc      point to current process descriptor
0614 A606             (      fvmodul.asm):00417                  lda   P$Task,x     get its task number
0616 D6D0             (      fvmodul.asm):00418                  ldb   <D.SysTsk    get the system task number 
0618 AE48             (      fvmodul.asm):00419                  ldx   R$U,u        point to user's 24 bit CRC accumulator
061A 108E0003         (      fvmodul.asm):00420                  ldy   #3           number of bytes to move 
061E 33E4             (      fvmodul.asm):00421                  leau  ,s           point to our temp buffer
0620 3436             (      fvmodul.asm):00422                  pshs  d,x,y        save [D]=task #'s,[X]=Buff,[Y]=3
0622 1704D9           (      fvmodul.asm):00423                  lbsr  L0B2C        move CRC accumulator to temp buffer
0625 9E50             (      fvmodul.asm):00424                  ldx   <D.Proc      point to current process descriptor
0627 318840           (      fvmodul.asm):00425                  leay  <P$DATImg,x  point to its DAT image
062A AE6B             (      fvmodul.asm):00426                  ldx   11,s         restore the buffer pointer
062C 170443           (      fvmodul.asm):00427                  lbsr  AdjBlk0      make callers buffer visible
                      (      fvmodul.asm):00428                IFNE  H6309
                      (      fvmodul.asm):00429                  ldw   9,s          get byte count
                      (      fvmodul.asm):00430                ENDC
062F 170427           (      fvmodul.asm):00431         L065D    lbsr  LDAXY        get byte from callers buffer
0632 8D95             (      fvmodul.asm):00432                  bsr   CRCCalc      add it to CRC
                      (      fvmodul.asm):00433                IFNE  H6309
                      (      fvmodul.asm):00434                  decw               done?
                      (      fvmodul.asm):00435                ELSE
0634 EC69             (      fvmodul.asm):00436                  ldd   9,s
0636 830001           (      fvmodul.asm):00437                  subd  #$0001
0639 ED69             (      fvmodul.asm):00438                  std   9,s
                      (      fvmodul.asm):00439                ENDC
063B 26F2             (      fvmodul.asm):00440                  bne   L065D        no, keep going
063D 3536             (      fvmodul.asm):00441                  puls  d,x,y        restore pointers
063F 1E89             (      fvmodul.asm):00442                  exg   a,b          swap around the task numbers 
0641 1E13             (      fvmodul.asm):00443                  exg   x,u          and the pointers
0643 1704B8           (      fvmodul.asm):00444                  lbsr  L0B2C        move accumulator back to user
0646 3267             (      fvmodul.asm):00445                  leas  7,s          clean up stack
0648 5F               (      fvmodul.asm):00446         L0677    clrb               no error
0649 39               (      fvmodul.asm):00447                  rts
                      (    krn_beta5.asm):00645                   use   ffmodul.asm
                      (      ffmodul.asm):00001         **************************************************
                      (      ffmodul.asm):00002         * System Call: F$FModul
                      (      ffmodul.asm):00003         *
                      (      ffmodul.asm):00004         * Function: Find module directory entry
                      (      ffmodul.asm):00005         *
                      (      ffmodul.asm):00006         * Input:  A = Module type
                      (      ffmodul.asm):00007         *         X = Module name string pointer
                      (      ffmodul.asm):00008         *         Y = Name string DAT image pointer
                      (      ffmodul.asm):00009         *
                      (      ffmodul.asm):00010         * Output: A = Module type
                      (      ffmodul.asm):00011         *         B = Module revision
                      (      ffmodul.asm):00012         *         X = Updated past name string
                      (      ffmodul.asm):00013         *         U = Module directory entry pointer
                      (      ffmodul.asm):00014         *
                      (      ffmodul.asm):00015         * Error:  CC = C bit set; B = error code
                      (      ffmodul.asm):00016         *
064A 3440             (      ffmodul.asm):00017         FFModul  pshs  u            preserve register stack pointer
064C A641             (      ffmodul.asm):00018                  lda   R$A,u        get module type
064E AE44             (      ffmodul.asm):00019                  ldx   R$X,u        get pointer to name
0650 10AE46           (      ffmodul.asm):00020                  ldy   R$Y,u        get pointer to DAT image of name (from caller)
0653 8D09             (      ffmodul.asm):00021                  bsr   L068D        go find it
0655 3520             (      ffmodul.asm):00022                  puls  y            restore register stack pointer
0657 ED21             (      ffmodul.asm):00023                  std   R$D,y        save type & revision
0659 AF24             (      ffmodul.asm):00024                  stx   R$X,y        save updated name pointer
065B EF28             (      ffmodul.asm):00025                  stu   R$U,y        save pointer to directory entry
065D 39               (      ffmodul.asm):00026                  rts                return
                      (      ffmodul.asm):00027         
                      (      ffmodul.asm):00028         * Find module in module directory
                      (      ffmodul.asm):00029         * Entry: A=Module type
                      (      ffmodul.asm):00030         *        X=Pointer to module name
                      (      ffmodul.asm):00031         *        Y=DAT image pointer for module name
     065E             (      ffmodul.asm):00032         L068D    equ   *
                      (      ffmodul.asm):00033                IFNE  H6309
                      (      ffmodul.asm):00034                  tfr   0,u          init directory pointer to nothing
                      (      ffmodul.asm):00035                ELSE
065E CE0000           (      ffmodul.asm):00036                  ldu   #$0000
                      (      ffmodul.asm):00037                ENDC
0661 3446             (      ffmodul.asm):00038                  pshs  d,u          preserve (Why B?)
0663 8D7D             (      ffmodul.asm):00039                  bsr   L0712        Go find 1st char of module name requested
0665 812F             (      ffmodul.asm):00040                  cmpa  #PDELIM      Is it a '/'?
0667 2772             (      ffmodul.asm):00041                  beq   L070B        yes, exit with error
0669 1700A5           (      ffmodul.asm):00042                  lbsr  ParseNam     parse the name to find the end & length
066C 2570             (      ffmodul.asm):00043                  bcs   L070E        error (illegal name), exit
066E DE58             (      ffmodul.asm):00044                  ldu   <D.ModEnd    get module directory end pointer
0670 205F             (      ffmodul.asm):00045                  bra   L0700        start looking for it
                      (      ffmodul.asm):00046         
                      (      ffmodul.asm):00047         * Main module directory search
                      (      ffmodul.asm):00048         * Entry: A=Module type
                      (      ffmodul.asm):00049         *        B=Module name length
                      (      ffmodul.asm):00050         *        X=Logical address of name in Caller's 64k space
                      (      ffmodul.asm):00051         *        Y=DAT image of caller (for module name)
                      (      ffmodul.asm):00052         *        U=Module directory Entry ptr (current module being checked)
0672 3436             (      ffmodul.asm):00053         L06A1    pshs  d,x,y        Preserve Mod type/nm len, Log. Addr, DAT Img ptr
0674 3430             (      ffmodul.asm):00054                  pshs  x,y          Preserve Log. addr & DAT Img ptr
0676 10AEC4           (      ffmodul.asm):00055                  ldy   MD$MPDAT,u   Does the module have a DAT Image ptr?
0679 274C             (      ffmodul.asm):00056                  beq   L06F6        no, skip module
067B AE44             (      ffmodul.asm):00057                  ldx   MD$MPtr,u    get module pointer
067D 3430             (      ffmodul.asm):00058                  pshs  x,y          Save module ptr & DAT Img ptr of module
067F CC0004           (      ffmodul.asm):00059                  ldd   #M$Name      # bytes to go in to get module name ptr
0682 1703FF           (      ffmodul.asm):00060                  lbsr  L0B02        Go get the module name ptr
                      (      ffmodul.asm):00061                IFNE  H6309
                      (      ffmodul.asm):00062                  addr  d,x          add it to module start
                      (      ffmodul.asm):00063                ELSE
0685 308B             (      ffmodul.asm):00064                  leax  d,x
                      (      ffmodul.asm):00065                ENDC
0687 3430             (      ffmodul.asm):00066                  pshs  x,y          preserve module name ptr & DAT pointer
0689 3068             (      ffmodul.asm):00067                  leax  8,s          Point to addr of name we are searching for
068B E66D             (      ffmodul.asm):00068                  ldb   13,s         get name length
068D 31E4             (      ffmodul.asm):00069                  leay  ,s           point to module name name ptr within module DAT
                      (      ffmodul.asm):00070         * Stack:
                      (      ffmodul.asm):00071         * 0-1,s = Ptr to module name within Module DAT Img
                      (      ffmodul.asm):00072         * 2-3,s = Ptr to module's DAT Img
                      (      ffmodul.asm):00073         * 4-5,s = Ptr to module start
                      (      ffmodul.asm):00074         * 6-7,s = Ptr to module's DAT Img
                      (      ffmodul.asm):00075         * 8-9,s = Ptr to name we are looking for in caller's 64K space
                      (      ffmodul.asm):00076         * A-B,s = Ptr to caller's DAT Img
                      (      ffmodul.asm):00077         * C,s   = Module type we are looking for (0=don't care)
                      (      ffmodul.asm):00078         * D,s   = Length of module name
                      (      ffmodul.asm):00079         * E-F,s = Ptr to name we are looking for in caller's 64K space
                      (      ffmodul.asm):00080         * 10-11,s = Ptr to caller's DAT Img
                      (      ffmodul.asm):00081         * 12,s  = Module type looking for
                      (      ffmodul.asm):00082         * 13,s  = ??? (B from entry)
                      (      ffmodul.asm):00083         * 14-15,s = Module directory ptr (inited to 0)
068F 170122           (      ffmodul.asm):00084                  lbsr  L07DE        compare the names
0692 3264             (      ffmodul.asm):00085                  leas  4,s          purge stack
0694 3530             (      ffmodul.asm):00086                  puls  y,x          restore module pointer & DAT image
0696 3264             (      ffmodul.asm):00087                  leas  4,s          purge stack
0698 2535             (      ffmodul.asm):00088                  bcs   L06FE        name didn't match, skip ahead
069A CC0006           (      ffmodul.asm):00089                  ldd   #M$Type      Offset ptr to module type
069D 1703E4           (      ffmodul.asm):00090                  lbsr  L0B02        Get it
06A0 A7E4             (      ffmodul.asm):00091                  sta   ,s           Save high byte
06A2 E767             (      ffmodul.asm):00092                  stb   $07,s        And low byte
06A4 A666             (      ffmodul.asm):00093                  lda   $06,s        Get type/language we are looking for
06A6 2716             (      ffmodul.asm):00094                  beq   L06ED        0 means don't care on either, so skip ahead
06A8 84F0             (      ffmodul.asm):00095                  anda  #TypeMask    Keep just type
06AA 2706             (      ffmodul.asm):00096                  beq   L06E1        Type 0 means don't care, skip ahead
06AC A8E4             (      ffmodul.asm):00097                  eora  ,s
06AE 84F0             (      ffmodul.asm):00098                  anda  #TypeMask    does it match?
06B0 261D             (      ffmodul.asm):00099                  bne   L06FE        No, check next module
06B2 A666             (      ffmodul.asm):00100         L06E1    lda   $06,s        Get type/language we are looking for again
06B4 840F             (      ffmodul.asm):00101                  anda  #LangMask    Keep just Language
06B6 2706             (      ffmodul.asm):00102                  beq   L06ED        0=don't care, skip ahad
06B8 A8E4             (      ffmodul.asm):00103                  eora  ,s           Does it match language we are looking for?
06BA 840F             (      ffmodul.asm):00104                  anda  #LangMask
06BC 2611             (      ffmodul.asm):00105                  bne   L06FE        No, check next module
06BE 3536             (      ffmodul.asm):00106         L06ED    puls  y,x,d        Found match, restore regs
06C0 3A               (      ffmodul.asm):00107                  abx
06C1 5F               (      ffmodul.asm):00108                  clrb
06C2 E661             (      ffmodul.asm):00109                  ldb   1,s
06C4 3264             (      ffmodul.asm):00110                  leas  4,s          purge stack and return no error
06C6 39               (      ffmodul.asm):00111                  rts
                      (      ffmodul.asm):00112         
06C7 3264             (      ffmodul.asm):00113         L06F6    leas  4,s          purge stack
06C9 EC68             (      ffmodul.asm):00114                  ldd   8,s          do we have a directory pointer?
06CB 2602             (      ffmodul.asm):00115                  bne   L06FE        yes, skip ahead
06CD EF68             (      ffmodul.asm):00116                  stu   8,s          save directory entry pointer
06CF 3536             (      ffmodul.asm):00117         L06FE    puls  d,x,y        restore pointers
06D1 3358             (      ffmodul.asm):00118         L0700    leau  -MD$ESize,u  move back 1 entry in module table
06D3 119344           (      ffmodul.asm):00119                  cmpu  <D.ModDir    at the beginning?
06D6 249A             (      ffmodul.asm):00120                  bhs   L06A1        no, check entry
06D8 C6DD             (      ffmodul.asm):00121                  ldb   #E$MNF       get error code (module not found)
06DA 8C               (      ffmodul.asm):00122                  fcb   $8C          skip 2 bytes
06DB C6EB             (      ffmodul.asm):00123         L070B    ldb   #E$BNam      get error code
06DD 43               (      ffmodul.asm):00124                  coma               set carry for error
06DE E761             (      ffmodul.asm):00125         L070E    stb   1,s          save error code for caller
06E0 35C6             (      ffmodul.asm):00126                  puls  d,u,pc       return
                      (      ffmodul.asm):00127         
                      (      ffmodul.asm):00128         * Skip spaces in name string & return first character of name
                      (      ffmodul.asm):00129         * Entry: X=Pointer to name
                      (      ffmodul.asm):00130         *        Y=DAT image pointer
                      (      ffmodul.asm):00131         * Exit : A=First character of name
                      (      ffmodul.asm):00132         *        B=DAT image block offset
                      (      ffmodul.asm):00133         *        X=Logical address of name
06E2 3420             (      ffmodul.asm):00134         L0712    pshs  y            preserve DAT image pointer
06E4 17038B           (      ffmodul.asm):00135         L0714    lbsr  AdjBlk0      adjust pointer to offset for mapping in
06E7 17035E           (      ffmodul.asm):00136                  lbsr  L0AC8        map in block
06EA 3001             (      ffmodul.asm):00137                  leax  1,x
06EC 8120             (      ffmodul.asm):00138                  cmpa  #C$SPAC      space?
06EE 27F4             (      ffmodul.asm):00139                  beq   L0714        yes, eat it
06F0 301F             (      ffmodul.asm):00140                  leax  -1,x         move back to first character
06F2 3407             (      ffmodul.asm):00141         L0720    pshs  d,cc         preserve char
06F4 1F20             (      ffmodul.asm):00142                  tfr   y,d          copy DAT pointer to D
06F6 A363             (      ffmodul.asm):00143                  subd  3,s          calculate DAT image offset
06F8 57               (      ffmodul.asm):00144                  asrb               divide it by 2
06F9 170334           (      ffmodul.asm):00145                  lbsr  CmpLBlk      convert X to logical address in 64k map
06FC 35A7             (      ffmodul.asm):00146                  puls  cc,d,y,pc    restore & return
                      (    krn_beta5.asm):00646                   use   fprsnam.asm
                      (      fprsnam.asm):00001         **************************************************
                      (      fprsnam.asm):00002         * System Call: F$PrsNam
                      (      fprsnam.asm):00003         *
                      (      fprsnam.asm):00004         * Function: Parse a path name
                      (      fprsnam.asm):00005         *
                      (      fprsnam.asm):00006         * Modification to allow '-' in filenames by WG
                      (      fprsnam.asm):00007         *
                      (      fprsnam.asm):00008         * Input:  X = Address of pathlist
                      (      fprsnam.asm):00009         *
                      (      fprsnam.asm):00010         * Output: X = Updated past optional "/" character
                      (      fprsnam.asm):00011         *         Y = Address of last character of pathlist + 1
                      (      fprsnam.asm):00012         *         B = Length of pathlist
                      (      fprsnam.asm):00013         *
                      (      fprsnam.asm):00014         * Error:  CC = C bit set; B = error code
                      (      fprsnam.asm):00015         *
                      (      fprsnam.asm):00016                IFGT  Level-1
                      (      fprsnam.asm):00017         * Level 2 code
06FE 9E50             (      fprsnam.asm):00018         FPrsNam  ldx   <D.Proc      proc desc
0700 318840           (      fprsnam.asm):00019                  leay  <P$DATImg,x  Y=DAT image ptr
0703 AE44             (      fprsnam.asm):00020                  ldx   R$X,u        X=name string
0705 8D0A             (      fprsnam.asm):00021                  bsr   ParseNam     get it and length
0707 ED41             (      fprsnam.asm):00022                  std   R$D,u        return length in D
0709 2503             (      fprsnam.asm):00023                  bcs   L073E        ..err
070B AF44             (      fprsnam.asm):00024                  stx   R$X,u        and X at name begin
070D 3A               (      fprsnam.asm):00025                  abx                plus len
070E AF46             (      fprsnam.asm):00026         L073E    stx   R$Y,u        return Y=end of name ptr
0710 39               (      fprsnam.asm):00027                  rts
                      (      fprsnam.asm):00028         
                      (      fprsnam.asm):00029         * Parse name
0711 3420             (      fprsnam.asm):00030         ParseNam pshs  y            save DAT image pointer
0713 17035C           (      fprsnam.asm):00031                  lbsr  AdjBlk0      go find map block...
0716 3430             (      fprsnam.asm):00032                  pshs  x,y          save X offset within block and Y block pointer
0718 8D2B             (      fprsnam.asm):00033                  bsr   GoGetAXY     go get byte at X in block Y...
071A 812E             (      fprsnam.asm):00034                  cmpa  #'.          is the first character a period?
071C 2609             (      fprsnam.asm):00035                  bne   IsSlash      no, do proper first character checking
071E 170327           (      fprsnam.asm):00036                  lbsr  L0AC8        do a LDAXY, without changing X or Y
0721 8D36             (      fprsnam.asm):00037                  bsr   ChkFirst     is the next character non-period?
0723 862E             (      fprsnam.asm):00038                  lda   #'.          restore the period character the LDAXY destroyed
0725 240A             (      fprsnam.asm):00039                  bcc   Do.Loop      if NON-period character, skip 1st char checks
0727 812F             (      fprsnam.asm):00040         IsSlash  cmpa  #PDELIM      is it a slash?
0729 2602             (      fprsnam.asm):00041                  bne   NotSlash     no, go keep X offset and block Y...
072B 8D13             (      fprsnam.asm):00042                  bsr   GetChar      go get character...
072D 8D2A             (      fprsnam.asm):00043         NotSlash bsr   ChkFirst     go check if valid first character...
072F 2519             (      fprsnam.asm):00044                  bcs   NotValid     not valid, go get next name start offset in X...
0731 5F               (      fprsnam.asm):00045         Do.Loop  clrb               initialize character counter
0732 5C               (      fprsnam.asm):00046         LastLoop incb               add one character
0733 4D               (      fprsnam.asm):00047                  tsta               last character in name string?
0734 2B06             (      fprsnam.asm):00048                  bmi   LastChar     yes, go return valid...
0736 8D0D             (      fprsnam.asm):00049                  bsr   GoGetAXY     go get next character...
0738 8D25             (      fprsnam.asm):00050                  bsr   ChkValid     go check if valid character...
073A 24F6             (      fprsnam.asm):00051                  bcc   LastLoop     valid, go check if last character...
073C 1CFE             (      fprsnam.asm):00052         LastChar andcc #^Carry
073E 2015             (      fprsnam.asm):00053                  bra   RtnValid
                      (      fprsnam.asm):00054         
0740 AF62             (      fprsnam.asm):00055         GetChar  stx   2,s          save current offset over old offset
0742 10AF64           (      fprsnam.asm):00056                  sty   4,s          save current block pointer over old block pointer
0745 160311           (      fprsnam.asm):00057         GoGetAXY lbra  LDAXY        go get byte at X in block Y in A,  & return
                      (      fprsnam.asm):00058         
0748 8DF6             (      fprsnam.asm):00059         NextLoop bsr   GetChar      go get character...
074A 812C             (      fprsnam.asm):00060         NotValid cmpa  #',          comma?
074C 27FA             (      fprsnam.asm):00061                  beq   NextLoop     yes, go get next character...
074E 8120             (      fprsnam.asm):00062                  cmpa  #C$SPAC      space?
0750 27F6             (      fprsnam.asm):00063                  beq   NextLoop     yes, go get next character...
0752 53               (      fprsnam.asm):00064                  comb               error, set Carry
0753 C6EB             (      fprsnam.asm):00065                  ldb   #E$BNam      'Bad Name' error
0755 3530             (      fprsnam.asm):00066         RtnValid puls  x,y          recover offset & pointer
0757 2099             (      fprsnam.asm):00067                  bra   L0720        go do a similar exit routine
                      (      fprsnam.asm):00068         
0759 3402             (      fprsnam.asm):00069         ChkFirst pshs  a            save character
075B 847F             (      fprsnam.asm):00070                  anda  #$7F         drop msbit
075D 200C             (      fprsnam.asm):00071                  bra   ChkRst       skip dash for first character check
                      (      fprsnam.asm):00072         
                      (      fprsnam.asm):00073         * Determine if character in A is a valid filename character
075F 3402             (      fprsnam.asm):00074         ChkValid pshs  a            save character
0761 847F             (      fprsnam.asm):00075                  anda  #$7F         drop msbit
0763 812E             (      fprsnam.asm):00076                  cmpa  #'.          period?
0765 2725             (      fprsnam.asm):00077                  beq   ValidChr     yes, go return valid character...
0767 812D             (      fprsnam.asm):00078         ChkRest  cmpa  #'-          is it a dash?
0769 2721             (      fprsnam.asm):00079                  beq   ValidChr     yes, it's valid
076B 817A             (      fprsnam.asm):00080         ChkRst   cmpa  #'z          greater than "z"?
076D 221C             (      fprsnam.asm):00081                  bhi   InvalidC     yes, go return invalid character...
076F 8161             (      fprsnam.asm):00082                  cmpa  #'a          greater than or equal to "a"?
0771 2419             (      fprsnam.asm):00083                  bhs   ValidChr     yes, go return valid character...
0773 815F             (      fprsnam.asm):00084                  cmpa  #'_          underscore?
0775 2715             (      fprsnam.asm):00085                  beq   ValidChr     yes, go return valid character...
0777 815A             (      fprsnam.asm):00086                  cmpa  #'Z          greater than "Z"?
0779 2210             (      fprsnam.asm):00087                  bhi   InvalidC     yes, go return invalid character...
077B 8141             (      fprsnam.asm):00088                  cmpa  #'A          greater than or equal to "A"?
077D 240D             (      fprsnam.asm):00089                  bhs   ValidChr     yes, go return valid character...
077F 8139             (      fprsnam.asm):00090                  cmpa  #'9          greater than "9"?
0781 2208             (      fprsnam.asm):00091                  bhi   InvalidC     yes, go return invalid character...
0783 8130             (      fprsnam.asm):00092                  cmpa  #'0          greater than or equal to "0"?
0785 2405             (      fprsnam.asm):00093                  bhs   ValidChr     yes, go return valid character...
0787 8124             (      fprsnam.asm):00094                  cmpa  #'$          dollar symbol?
0789 2701             (      fprsnam.asm):00095                  beq   ValidChr     yes, go return valid character...
078B 43               (      fprsnam.asm):00096         InvalidC coma               invalid character, set carry
078C 3582             (      fprsnam.asm):00097         ValidChr puls  a,pc
                      (      fprsnam.asm):00098         
                      (      fprsnam.asm):00099                ELSE
                      (      fprsnam.asm):00100         * Level 1 code
078E                  (      fprsnam.asm):00101         FPrsNam  ldx   R$X,u        Get ptr to string
                      (      fprsnam.asm):00102                  bsr   ParseNam     parse it
                      (      fprsnam.asm):00103                  std   R$D,u
                      (      fprsnam.asm):00104                  bcs   L0749
                      (      fprsnam.asm):00105                  stx   R$X,u
078E                  (      fprsnam.asm):00106         L0749    sty   R$Y,u
                      (      fprsnam.asm):00107                  rts
                      (      fprsnam.asm):00108         
078E                  (      fprsnam.asm):00109         ParseNam lda   ,x           Get char from path
                      (      fprsnam.asm):00110                  cmpa  #PDELIM      Slash?
                      (      fprsnam.asm):00111                  bne   L0755        No, skip ahead
                      (      fprsnam.asm):00112                  leax  1,x          Point to 1 past slash
078E                  (      fprsnam.asm):00113         L0755    leay  ,x           Point to char
                      (      fprsnam.asm):00114                  clrb               Init offset to 0
                      (      fprsnam.asm):00115                  lda   ,y+          Get char
                      (      fprsnam.asm):00116                  anda  #$7F         Strip hi bit
                      (      fprsnam.asm):00117                  bsr   ChkRest      Check if valid char
                      (      fprsnam.asm):00118                  bcs   L0772        No,eat spaces/commas if present
078E                  (      fprsnam.asm):00119         L0760    incb               Bump up offset
                      (      fprsnam.asm):00120                  lda   -1,y         get previous char
                      (      fprsnam.asm):00121                  bmi   L076F        hi bit set on this char, done
                      (      fprsnam.asm):00122                  lda   ,y+          Get next char
                      (      fprsnam.asm):00123                  anda  #$7F         strip hi bit
                      (      fprsnam.asm):00124                  bsr   ChkFirst     Do special check for first char not incl. paths
                      (      fprsnam.asm):00125                  bcc   L0760        Legal char, keep parsing
                      (      fprsnam.asm):00126                  lda   ,-y          illegal char, get previous char
078E                  (      fprsnam.asm):00127         L076F    andcc #^Carry      No error and return
                      (      fprsnam.asm):00128                  rts
                      (      fprsnam.asm):00129         
                      (      fprsnam.asm):00130         * eat commas and spaces
                      (      fprsnam.asm):00131         * Entry: Y=ptr to string
                      (      fprsnam.asm):00132         * Exit:  Y=ptr to first non space/comma char in string
                      (      fprsnam.asm):00133         *        A=char first non (space/comma)
078E                  (      fprsnam.asm):00134         L0772    cmpa  #C$COMA      comma?
                      (      fprsnam.asm):00135                  bne   L0778        No, check next
078E                  (      fprsnam.asm):00136         L0776    lda   ,y+          Yes, get next char
078E                  (      fprsnam.asm):00137         L0778    cmpa  #C$SPAC      space?
                      (      fprsnam.asm):00138                  beq   L0776        Yes, eat it and go onto next char
                      (      fprsnam.asm):00139                  lda   ,-y          Get last char
                      (      fprsnam.asm):00140                  comb               Exit with bad name error
                      (      fprsnam.asm):00141                  ldb   #E$BNam
                      (      fprsnam.asm):00142                  rts
                      (      fprsnam.asm):00143         
                      (      fprsnam.asm):00144         * Entry: A=char we are checking
                      (      fprsnam.asm):00145         * check for illegal characters in a pathlist
078E                  (      fprsnam.asm):00146         ChkFirst cmpa  #C$PERD      period?
                      (      fprsnam.asm):00147                  beq   L07C9        Legal char
078E                  (      fprsnam.asm):00148         ChkRest  cmpa  #'0          <ASCII zero?
                      (      fprsnam.asm):00149                  blo   L07A2        yes, illegal char
                      (      fprsnam.asm):00150                  cmpa  #'9          number?
                      (      fprsnam.asm):00151                  bls   L07C9        Yes, legal char
                      (      fprsnam.asm):00152                  cmpa  #'_          underscore?
                      (      fprsnam.asm):00153                  beq   L07C9        yes, legal char
                      (      fprsnam.asm):00154                  cmpa  #'A          Between _ and A?
                      (      fprsnam.asm):00155                  blo   L07A2        Yes, illegal char
                      (      fprsnam.asm):00156                  cmpa  #'Z          A-Z?
                      (      fprsnam.asm):00157                  bls   L07C9        Yes, legal char
                      (      fprsnam.asm):00158                  cmpa  #'a          Between Z and a?
                      (      fprsnam.asm):00159                  blo   L07A2        Yes, illegal char
                      (      fprsnam.asm):00160                  cmpa  #'z          Between a and z?
                      (      fprsnam.asm):00161                  bls   L07C9        yes, legal char
078E                  (      fprsnam.asm):00162         L07A2    orcc  #Carry       Flag as illegal character
                      (      fprsnam.asm):00163                  rts
                      (      fprsnam.asm):00164         
                      (      fprsnam.asm):00165                  ENDC
                      (    krn_beta5.asm):00647                   use   fcmpnam.asm
                      (      fcmpnam.asm):00001         **************************************************
                      (      fcmpnam.asm):00002         * System Call: F$CmpNam
                      (      fcmpnam.asm):00003         *
                      (      fcmpnam.asm):00004         * Function: Compare two names
                      (      fcmpnam.asm):00005         *
                      (      fcmpnam.asm):00006         * Input:  X = Address of first name
                      (      fcmpnam.asm):00007         *         Y = Address of second name
                      (      fcmpnam.asm):00008         *         B = length of first name
                      (      fcmpnam.asm):00009         *
                      (      fcmpnam.asm):00010         * Output: None
                      (      fcmpnam.asm):00011         *
                      (      fcmpnam.asm):00012         * Error:  CC = C bit set; B = error code
                      (      fcmpnam.asm):00013         *
                      (      fcmpnam.asm):00014         
                      (      fcmpnam.asm):00015                  IFGT  Level-1
                      (      fcmpnam.asm):00016         
078E 9E50             (      fcmpnam.asm):00017         FCmpNam  ldx   <D.Proc      get current process ptr
0790 318840           (      fcmpnam.asm):00018                  leay  P$DATImg,x   Point to the DAT image
0793 AE44             (      fcmpnam.asm):00019                  ldx   R$X,u        Get pointer to string #1
0795 3430             (      fcmpnam.asm):00020                  pshs  y,x          preserve 'em
0797 200C             (      fcmpnam.asm):00021                  bra   L07CF
                      (      fcmpnam.asm):00022         
                      (      fcmpnam.asm):00023         * F$CmpNam entry point for system state
0799 9E50             (      fcmpnam.asm):00024         FSCmpNam ldx   <D.Proc      Get current proc. dsc. ptr
079B 318840           (      fcmpnam.asm):00025                  leay  P$DATImg,x   Point to it's DAT image
079E AE44             (      fcmpnam.asm):00026                  ldx   R$X,u        get pointer to string #1
07A0 3430             (      fcmpnam.asm):00027                  pshs  x,y
07A2 109E4C           (      fcmpnam.asm):00028                  ldy   <D.SysDAT    get pointer to system DAT
07A5 AE46             (      fcmpnam.asm):00029         L07CF    ldx   R$Y,u        get pointer to string #2
07A7 3430             (      fcmpnam.asm):00030                  pshs  y,x          Preserve them
07A9 EC41             (      fcmpnam.asm):00031                  ldd   R$D,u        get length
07AB 3064             (      fcmpnam.asm):00032                  leax  4,s          point to string #1 info packet
07AD 31E4             (      fcmpnam.asm):00033                  leay  ,s           point to string #2 info packet
07AF 8D03             (      fcmpnam.asm):00034                  bsr   L07DE        go compare 'em
07B1 3268             (      fcmpnam.asm):00035                  leas  8,s          purge stack
07B3 39               (      fcmpnam.asm):00036                  rts                return
                      (      fcmpnam.asm):00037         
                      (      fcmpnam.asm):00038         * Compare 2 strings
                      (      fcmpnam.asm):00039         *
                      (      fcmpnam.asm):00040         * Input:  D = Length of string #1 (only requires B)
                      (      fcmpnam.asm):00041         *         X = Ptr to string #1 info packet
                      (      fcmpnam.asm):00042         *             0,X = DAT image pointer
                      (      fcmpnam.asm):00043         *             2,X = Pointer to string
                      (      fcmpnam.asm):00044         *         Y = Ptr to string #2 info packet
                      (      fcmpnam.asm):00045         *             0,Y = DAT image pointer
                      (      fcmpnam.asm):00046         *             2,Y = Pointer to string
                      (      fcmpnam.asm):00047         *         U = Register stack ptr
07B4 3476             (      fcmpnam.asm):00048         L07DE    pshs  d,x,y,u      preserve registers
07B6 1F13             (      fcmpnam.asm):00049                  tfr   x,u          U=ptr to string #1 packet
07B8 3730             (      fcmpnam.asm):00050                  pulu  x,y          get DAT ptr to Y and string ptr to X
07BA 1702B5           (      fcmpnam.asm):00051                  lbsr  AdjBlk0      adjust X to use block 0
07BD 3630             (      fcmpnam.asm):00052                  pshu  x,y          put them back
07BF EE64             (      fcmpnam.asm):00053                  ldu   4,s          get pointer to string #2 packet
07C1 3730             (      fcmpnam.asm):00054                  pulu  x,y          get DAT ptr to Y and string ptr to X
07C3 1702AC           (      fcmpnam.asm):00055                  lbsr  AdjBlk0      Adjust X to block 0
07C6 2004             (      fcmpnam.asm):00056                  bra   L07F6        go compare the strings
                      (      fcmpnam.asm):00057         
07C8 EE64             (      fcmpnam.asm):00058         L07F2    ldu   4,s          get pointer to string #2 packet
07CA 3730             (      fcmpnam.asm):00059                  pulu  x,y          get DAT ptr to Y and string ptr to X
07CC 17028A           (      fcmpnam.asm):00060         L07F6    lbsr  LDAXY        Map in the block & grab a byte from string
07CF 3630             (      fcmpnam.asm):00061                  pshu  x,y          Put updated DAT & string ptr back
07D1 3402             (      fcmpnam.asm):00062                  pshs  a            Save the character
07D3 EE63             (      fcmpnam.asm):00063                  ldu   3,s          pointer to string #1 packet
07D5 3730             (      fcmpnam.asm):00064                  pulu  x,y          get DAT ptr to Y and string ptr to X
07D7 17027F           (      fcmpnam.asm):00065                  lbsr  LDAXY        get byte from string #1
07DA 3630             (      fcmpnam.asm):00066                  pshu  y,x          put pointers back
07DC A8E4             (      fcmpnam.asm):00067                  eora  ,s
07DE 6DE0             (      fcmpnam.asm):00068                  tst   ,s+          was it high bit?
07E0 2B0A             (      fcmpnam.asm):00069                  bmi   L0816        yes, check if last character in string #2
07E2 5A               (      fcmpnam.asm):00070                  decb  
07E3 2704             (      fcmpnam.asm):00071                  beq   L0813
07E5 84DF             (      fcmpnam.asm):00072                  anda  #$DF         match?
07E7 27DF             (      fcmpnam.asm):00073                  beq   L07F2        yes, check next character
07E9 53               (      fcmpnam.asm):00074         L0813    comb               set carry
07EA 35F6             (      fcmpnam.asm):00075                  puls  d,x,y,u,pc
                      (      fcmpnam.asm):00076         
07EC 5A               (      fcmpnam.asm):00077         L0816    decb               done whole string?
07ED 26FA             (      fcmpnam.asm):00078                  bne   L0813        no, exit with no match
07EF 845F             (      fcmpnam.asm):00079                  anda  #$5F         match?
07F1 26F6             (      fcmpnam.asm):00080                  bne   L0813        yes, keep checking
07F3 5F               (      fcmpnam.asm):00081                  clrb               strings match, clear carry
07F4 35F6             (      fcmpnam.asm):00082                  puls  d,x,y,u,pc   restore & return
                      (      fcmpnam.asm):00083         
                      (      fcmpnam.asm):00084                  ELSE
                      (      fcmpnam.asm):00085         
07F6                  (      fcmpnam.asm):00086         FCmpNam  ldb   R$B,u
                      (      fcmpnam.asm):00087                  leau  R$X,u
                      (      fcmpnam.asm):00088                  pulu  y,x
07F6                  (      fcmpnam.asm):00089         L07AB    pshs  y,x,b,a
07F6                  (      fcmpnam.asm):00090         L07AD    lda   ,y+
                      (      fcmpnam.asm):00091                  bmi   L07BE
                      (      fcmpnam.asm):00092                  decb
                      (      fcmpnam.asm):00093                  beq   L07BA
                      (      fcmpnam.asm):00094                  eora  ,x+
                      (      fcmpnam.asm):00095                  anda  #$DF
                      (      fcmpnam.asm):00096                  beq   L07AD
07F6                  (      fcmpnam.asm):00097         L07BA    orcc  #Carry
                      (      fcmpnam.asm):00098                  puls  pc,y,x,b,a
07F6                  (      fcmpnam.asm):00099         L07BE    decb
                      (      fcmpnam.asm):00100                  bne   L07BA
                      (      fcmpnam.asm):00101                  eora  ,x
                      (      fcmpnam.asm):00102                  anda  #$5F
                      (      fcmpnam.asm):00103                  bne   L07BA
                      (      fcmpnam.asm):00104                  puls  y,x,b,a
07F6                  (      fcmpnam.asm):00105         L07C9    andcc #^Carry
                      (      fcmpnam.asm):00106                  rts
                      (      fcmpnam.asm):00107         
                      (      fcmpnam.asm):00108                  ENDC
                      (    krn_beta5.asm):00648                   use   fsrqmem.asm
                      (      fsrqmem.asm):00001         **************************************************
                      (      fsrqmem.asm):00002         * System Call: F$SRqMem
                      (      fsrqmem.asm):00003         *
                      (      fsrqmem.asm):00004         * Function: Request memory
                      (      fsrqmem.asm):00005         *
                      (      fsrqmem.asm):00006         * F$SRqMem allocates memory from the system's 64K address space in 256 byte 'pages.'
                      (      fsrqmem.asm):00007         * There are 256 of these '256 byte pages' in the system's RAM area (256*256=64K).
                      (      fsrqmem.asm):00008         * The allocation map, pointed to by D.SysMem holds one byte per page, making the
                      (      fsrqmem.asm):00009         * allocation map itself 256 bytes in size.
                      (      fsrqmem.asm):00010         *
                      (      fsrqmem.asm):00011         * Memory is allocated from the top of the system RAM map downwards.  Rel/Boot/Krn
                      (      fsrqmem.asm):00012         * also reside in this area, and are loaded from $ED00-$FFFF.  Since this area is
                      (      fsrqmem.asm):00013         * always allocated, we start searching for free pages from page $EC downward.
                      (      fsrqmem.asm):00014         *
                      (      fsrqmem.asm):00015         * F$SRqMem also updates the system memory map according to 8K DAT blocks. If an
                      (      fsrqmem.asm):00016         * empty block is found, this routine re-does the 32 entries in the SMAP table to
                      (      fsrqmem.asm):00017         * indicate that they are free.
                      (      fsrqmem.asm):00018         *
                      (      fsrqmem.asm):00019         * Input:  D = Byte count
                      (      fsrqmem.asm):00020         *
                      (      fsrqmem.asm):00021         * Output: U = Address of allocated memory area
                      (      fsrqmem.asm):00022         *
                      (      fsrqmem.asm):00023         * Error:  CC = C bit set; B = error code
                      (      fsrqmem.asm):00024         *
07F6 EC41             (      fsrqmem.asm):00025         FSRqMem  ldd   R$D,u        get memory allocation size requested
07F8 C300FF           (      fsrqmem.asm):00026                  addd  #$00FF       round it up to nearest 256 byte page (e.g. $1FF = $2FE)
07FB 5F               (      fsrqmem.asm):00027                  clrb               just keep # of pages (and start 8K block #, e.g. $2FE = $200)
07FC ED41             (      fsrqmem.asm):00028                  std   R$D,u        save rounded version back to user
                      (      fsrqmem.asm):00029         *         leay  Bt.Start/256,y
                      (      fsrqmem.asm):00030         *         leay  $20,y        skip Block 0 (always reserved for system)
                      (      fsrqmem.asm):00031         * Change to pshs a,b:use 1,s for block # to check, and ,s for TFM spot
                      (      fsrqmem.asm):00032         *         incb               skip block 0 (always reserved for system)
07FE 3406             (      fsrqmem.asm):00033                  pshs  d            reserve a byte & put 0 byte on stack
                      (      fsrqmem.asm):00034         
                      (      fsrqmem.asm):00035         
                      (      fsrqmem.asm):00036         * IMPORTANT!!!
                      (      fsrqmem.asm):00037         * The following code was put in some time back to fix a problem.  That problem was not documented
                      (      fsrqmem.asm):00038         * so I cannot recall why this code was in place.  What it appears to do is reset the system page
                      (      fsrqmem.asm):00039         * memory map based upon the state of the system DAT image.
                      (      fsrqmem.asm):00040         * This code really slows down F$SRqMem and since that system call is used quite often in the system,
                      (      fsrqmem.asm):00041         * I am commenting it out in the hopes that I can remember what the hell I put it in for. -- Boisy
                      (      fsrqmem.asm):00042              IFEQ  1
                      (      fsrqmem.asm):00043                  ldy   <D.SysMem    get ptr to SMAP table
                      (      fsrqmem.asm):00044         * This loop updates the SMAP table if anything can be marked as unused
0800                  (      fsrqmem.asm):00045         L082F    ldx   <D.SysDAT    get pointer to system DAT block list
                      (      fsrqmem.asm):00046                  lslb               adjust block offset for 2 bytes/entry
                      (      fsrqmem.asm):00047                  ldd   b,x          get block type/# from system DAT
                      (      fsrqmem.asm):00048                  cmpd  #DAT.Free    Unused block?
                      (      fsrqmem.asm):00049                  beq   L0847        yes, mark it free in SMAP table
                      (      fsrqmem.asm):00050                  ldx   <D.BlkMap    No, get ptr to MMAP table
                      (      fsrqmem.asm):00051                  lda   d,x          Get block marker for 2 meg mem map
                      (      fsrqmem.asm):00052                  cmpa  #RAMinUse    Is it in use (not free, ROM or used by module)?
                      (      fsrqmem.asm):00053                  bne   L0848        No, mark it as type it is in SMAP table
                      (      fsrqmem.asm):00054                  leay  32,y         Yes, move to next block in pages
                      (      fsrqmem.asm):00055                  bra   L084F        move to next block & try again
                      (      fsrqmem.asm):00056         
                      (      fsrqmem.asm):00057         * Free RAM:
0800                  (      fsrqmem.asm):00058         L0847    clra               Byte to fill system page map with (0=Not in use)
                      (      fsrqmem.asm):00059         * NOT! RAMinUse:
                      (      fsrqmem.asm):00060                IFNE   H6309
0800                  (      fsrqmem.asm):00061         L0848    sta   ,s           Put it on stack
                      (      fsrqmem.asm):00062                  ldw   #$0020       Get size of 8K block in pages
                      (      fsrqmem.asm):00063                  tfm   s,y+         Mark entire block's worth of pages with A
                      (      fsrqmem.asm):00064                ELSE
0800                  (      fsrqmem.asm):00065         L0848    ldb   #32        count = 32 pages
0800                  (      fsrqmem.asm):00066         L084A    sta   ,y+        mark the RAM
                      (      fsrqmem.asm):00067                  decb
                      (      fsrqmem.asm):00068                  bne    L084A
                      (      fsrqmem.asm):00069                ENDC
0800                  (      fsrqmem.asm):00070         L084F    inc   1,s          Bump up to next block to check
                      (      fsrqmem.asm):00071                  ldb   1,s          Get it
                      (      fsrqmem.asm):00072                  cmpb  #DAT.BlCt    Done whole 64k system space?
                      (      fsrqmem.asm):00073                  blo   L082F        no, keep checking
                      (      fsrqmem.asm):00074              ENDC
                      (      fsrqmem.asm):00075         
                      (      fsrqmem.asm):00076         * Now we can actually attempt to allocate the system RAM requested
                      (      fsrqmem.asm):00077         * NOTE: Opt for CoCo/TC9 OS9 ONLY: skip last 256 - Bt.Start pages since
                      (      fsrqmem.asm):00078         * they are: Kernel (REL/BOOT/KRN - 17 pages), vector RAM & I/O (2 pages)
                      (      fsrqmem.asm):00079         * (Already permanently marked@ L01D2)
                      (      fsrqmem.asm):00080         * At the start, Y is pointing to the end of the SMAP table+1
0800 9E4E             (      fsrqmem.asm):00081                  ldx   <D.SysMem    Get start of table ptr
0802 318900ED         (      fsrqmem.asm):00082                  leay  Bt.Start/256,x
0806 C620             (      fsrqmem.asm):00083                  ldb   #32          skip block 0: it's always full
0808 3A               (      fsrqmem.asm):00084                  abx                same size, but faster than leax $20,x
                      (      fsrqmem.asm):00085         *         leay  -(256-(Bt.Start>>8)),y  skip Kernel, Vector RAM & I/O (Can't be free)
0809 E641             (      fsrqmem.asm):00086         L0857    ldb   R$A,u        Get # 256 byte pages requested
                      (      fsrqmem.asm):00087         * Loop (from end of system mem map) to look for # continuous pages requested
     080B             (      fsrqmem.asm):00088         L0859    equ   *
                      (      fsrqmem.asm):00089                IFNE  H6309
                      (      fsrqmem.asm):00090                  cmpr  x,y          We still have any system RAM left to try?
                      (      fsrqmem.asm):00091                ELSE
080B 3410             (      fsrqmem.asm):00092                  pshs  x
080D 10ACE1           (      fsrqmem.asm):00093                  cmpy  ,s++
                      (      fsrqmem.asm):00094                ENDC
0810 2205             (      fsrqmem.asm):00095                  bhi   L0863        Yes, continue
0812 53               (      fsrqmem.asm):00096                  comb               Exit with No System RAM Error
0813 C6ED             (      fsrqmem.asm):00097                  ldb   #E$NoRAM
0815 2031             (      fsrqmem.asm):00098                  bra   L0894        Eat stack & exit
                      (      fsrqmem.asm):00099         
0817 A6A2             (      fsrqmem.asm):00100         L0863    lda   ,-y          Get page marker (starting @ end of SMAP)
0819 26EE             (      fsrqmem.asm):00101                  bne   L0857        Used, try next lower page
081B 5A               (      fsrqmem.asm):00102                  decb               Found 1 page, dec # pages we need to allocate
081C 26ED             (      fsrqmem.asm):00103                  bne   L0859        Still more pages needed, check if we can get more
081E 10AFE4           (      fsrqmem.asm):00104                  sty   ,s           Found free contiguous pages, save SMAP entry ptr
0821 A661             (      fsrqmem.asm):00105                  lda   1,s          Get LSB of ptr
0823 44               (      fsrqmem.asm):00106                  lsra               Divide by 32 (Calculate start 8K block #)
0824 44               (      fsrqmem.asm):00107                  lsra
0825 44               (      fsrqmem.asm):00108                  lsra
0826 44               (      fsrqmem.asm):00109                  lsra
0827 44               (      fsrqmem.asm):00110                  lsra
0828 E661             (      fsrqmem.asm):00111                  ldb   1,s          Get LSB of ptr again
082A C41F             (      fsrqmem.asm):00112                  andb  #%00011111   Keep only within 8K block offset
082C EB41             (      fsrqmem.asm):00113                  addb  R$A,u        Add # pages requested
082E CB1F             (      fsrqmem.asm):00114                  addb  #$1F         Round up to nearest 8K block
0830 54               (      fsrqmem.asm):00115                  lsrb               Divide by 32 (Calculate end 8K block #)
0831 54               (      fsrqmem.asm):00116                  lsrb
0832 54               (      fsrqmem.asm):00117                  lsrb
0833 54               (      fsrqmem.asm):00118                  lsrb
0834 54               (      fsrqmem.asm):00119                  lsrb
0835 9E4A             (      fsrqmem.asm):00120                  ldx   <D.SysPrc    Get ptr to system proc. dsc.
0837 17010D           (      fsrqmem.asm):00121                  lbsr  L09BE        Allocate an image with our start/end block #'s
083A 250C             (      fsrqmem.asm):00122                  bcs   L0894        Couldn't, exit with error
083C E641             (      fsrqmem.asm):00123                  ldb   R$A,u        Get # pages requested
083E 6CA0             (      fsrqmem.asm):00124         L088A    inc   ,y+          Since RAMinUse is 1, we can save space by INC'ing from 0->1
0840 5A               (      fsrqmem.asm):00125                  decb
0841 26FB             (      fsrqmem.asm):00126                  bne   L088A
0843 A661             (      fsrqmem.asm):00127                  lda   1,s          Get MSB of ptr to start of newly allocated Sys RAM
0845 ED48             (      fsrqmem.asm):00128                  std   R$U,u        Save for caller
0847 5F               (      fsrqmem.asm):00129                  clrb               No error
0848 35C0             (      fsrqmem.asm):00130         L0894    puls  u,pc         Eat stack (U is changed after it exits) & return
                      (      fsrqmem.asm):00131         
                      (      fsrqmem.asm):00132         **************************************************
                      (      fsrqmem.asm):00133         * System Call: F$SRtMem
                      (      fsrqmem.asm):00134         *
                      (      fsrqmem.asm):00135         * Function: Return memory
                      (      fsrqmem.asm):00136         *
                      (      fsrqmem.asm):00137         * Input:  U = Address of memory to return
                      (      fsrqmem.asm):00138         *         D = Number of bytes to return
                      (      fsrqmem.asm):00139         *
                      (      fsrqmem.asm):00140         * Output: None
                      (      fsrqmem.asm):00141         *
                      (      fsrqmem.asm):00142         * Error:  CC = C bit set; B = error code
                      (      fsrqmem.asm):00143         *
084A EC41             (      fsrqmem.asm):00144         FSRtMem  ldd   R$D,u        get # pages to free up
084C 2757             (      fsrqmem.asm):00145                  beq   L08F2        nothing to free, return without error
084E C300FF           (      fsrqmem.asm):00146                  addd  #$00FF       round it up to nearest page
0851 E649             (      fsrqmem.asm):00147                  ldb   R$U+1,u      get LSB of address
0853 2704             (      fsrqmem.asm):00148                  beq   L08A6        it's a even page, skip ahead
0855 53               (      fsrqmem.asm):00149                  comb               set carry
0856 C6D2             (      fsrqmem.asm):00150                  ldb   #E$BPAddr    get error code
0858 39               (      fsrqmem.asm):00151                  rts                return
                      (      fsrqmem.asm):00152         
0859 E648             (      fsrqmem.asm):00153         L08A6    ldb   R$U,u        get MSB of page address
085B 2748             (      fsrqmem.asm):00154                  beq   L08F2        not a legal page, return without error
085D 9E4E             (      fsrqmem.asm):00155                  ldx   <D.SysMem    get pointer to system memory map
085F 3A               (      fsrqmem.asm):00156                  abx                set pointer into map
     0860             (      fsrqmem.asm):00157         L08AD    equ   *
                      (      fsrqmem.asm):00158                IFNE  H6309
                      (      fsrqmem.asm):00159                  aim   #^RAMinUse,,x+
                      (      fsrqmem.asm):00160                ELSE
0860 E684             (      fsrqmem.asm):00161                  ldb   ,x
0862 C4FE             (      fsrqmem.asm):00162                  andb  #^RAMinUse
0864 E780             (      fsrqmem.asm):00163                  stb   ,x+
                      (      fsrqmem.asm):00164                ENDC
0866 4A               (      fsrqmem.asm):00165                  deca  
0867 26F7             (      fsrqmem.asm):00166                  bne   L08AD
                      (      fsrqmem.asm):00167         * Scan DAT image to find memory blocks to free up
0869 9E4C             (      fsrqmem.asm):00168                  ldx   <D.SysDAT    get pointer to system DAT image
                      (      fsrqmem.asm):00169                IFNE  H6309
                      (      fsrqmem.asm):00170                  lde   #DAT.BlCt    get # blocks to check
                      (      fsrqmem.asm):00171                ELSE
086B 108E0008         (      fsrqmem.asm):00172                  ldy   #DAT.BlCt
                      (      fsrqmem.asm):00173                ENDC
086F EC84             (      fsrqmem.asm):00174         L08BC    ldd   ,x           get block image
0871 1083333E         (      fsrqmem.asm):00175                  cmpd  #DAT.Free    is it already free?
0875 2728             (      fsrqmem.asm):00176                  beq   L08EC        yes, skip to next one
0877 DE40             (      fsrqmem.asm):00177                  ldu   <D.BlkMap    get pointer to MMU block map
0879 A6CB             (      fsrqmem.asm):00178                  lda   d,u          get allocation flag for this block: 16-bit offset
087B 8101             (      fsrqmem.asm):00179                  cmpa  #RAMinUse    being used?
087D 2620             (      fsrqmem.asm):00180                  bne   L08EC        no, move to next block
087F 1F10             (      fsrqmem.asm):00181                  tfr   x,d
0881 934C             (      fsrqmem.asm):00182                  subd  <D.SysDAT
0883 58               (      fsrqmem.asm):00183                  lslb
0884 58               (      fsrqmem.asm):00184                  lslb
0885 58               (      fsrqmem.asm):00185                  lslb
0886 58               (      fsrqmem.asm):00186                  lslb
0887 DE4E             (      fsrqmem.asm):00187                  ldu   <D.SysMem    get pointer to system map
                      (      fsrqmem.asm):00188                IFNE   H6309
                      (      fsrqmem.asm):00189                  addr   d,u
                      (      fsrqmem.asm):00190         * Check if we can remove the entire memory block from system map
                      (      fsrqmem.asm):00191                  ldf   #16          get # pages per block/2
0889                  (      fsrqmem.asm):00192         L08DA    ldd   ,u++         Either of these 2 pages allocated?
                      (      fsrqmem.asm):00193                ELSE
0889 33CB             (      fsrqmem.asm):00194                  leau  d,u
088B C620             (      fsrqmem.asm):00195                  ldb   #32
088D A6C0             (      fsrqmem.asm):00196         L08DA    lda   ,u+          Either of these 2 pages allocated?
                      (      fsrqmem.asm):00197                ENDC
088F 260E             (      fsrqmem.asm):00198                  bne   L08EC        yes, can't free block, skip to next one
                      (      fsrqmem.asm):00199                IFNE  H6309
                      (      fsrqmem.asm):00200                  decf               checked all pages?
                      (      fsrqmem.asm):00201                ELSE
0891 5A               (      fsrqmem.asm):00202                  decb
                      (      fsrqmem.asm):00203                ENDC
0892 26F9             (      fsrqmem.asm):00204                  bne   L08DA        no, keep looking
0894 EC84             (      fsrqmem.asm):00205                  ldd   ,x           get block # into B: could be >$80
0896 DE40             (      fsrqmem.asm):00206                  ldu   <D.BlkMap    point to allocation table
                      (      fsrqmem.asm):00207                IFNE  H6309
                      (      fsrqmem.asm):00208                  sta   d,u          clear the block using 16-bit offset
                      (      fsrqmem.asm):00209                ELSE
0898 6FCB             (      fsrqmem.asm):00210                  clr   d,u
                      (      fsrqmem.asm):00211                ENDC
089A CC333E           (      fsrqmem.asm):00212                  ldd   #DAT.Free    get free block marker
089D ED84             (      fsrqmem.asm):00213                  std   ,x           save it into DAT image
089F 3002             (      fsrqmem.asm):00214         L08EC    leax  2,x          move to next DAT block
                      (      fsrqmem.asm):00215                IFNE  H6309
                      (      fsrqmem.asm):00216                  dece               done?
                      (      fsrqmem.asm):00217                ELSE
08A1 313F             (      fsrqmem.asm):00218                  leay  -1,y
                      (      fsrqmem.asm):00219                ENDC
08A3 26CA             (      fsrqmem.asm):00220                  bne   L08BC        no, keep checking
08A5 5F               (      fsrqmem.asm):00221         L08F2    clrb               clear errors
08A6 39               (      fsrqmem.asm):00222         L08F3    rts                return
                      (      fsrqmem.asm):00223         
                      (      fsrqmem.asm):00224         
                      (      fsrqmem.asm):00225         **************************************************
                      (      fsrqmem.asm):00226         * System Call: F$Boot
                      (      fsrqmem.asm):00227         *
                      (      fsrqmem.asm):00228         * Function: Bootstrap the system
                      (      fsrqmem.asm):00229         *
                      (      fsrqmem.asm):00230         * Optimized for size, as it's only called once...
                      (      fsrqmem.asm):00231         *
                      (      fsrqmem.asm):00232         * Input:  None
                      (      fsrqmem.asm):00233         *
                      (      fsrqmem.asm):00234         * Output: None
                      (      fsrqmem.asm):00235         *
                      (      fsrqmem.asm):00236         * Error:  CC = C bit set; B = error code
                      (      fsrqmem.asm):00237         *
08A7 8674             (      fsrqmem.asm):00238         FBoot    lda   #'t          tried to boot
08A9 9D5E             (      fsrqmem.asm):00239                  jsr   <D.BtBug
08AB 43               (      fsrqmem.asm):00240                  coma               Set boot flag
08AC 9631             (      fsrqmem.asm):00241                  lda   <D.Boot      we booted once before?
08AE 26F6             (      fsrqmem.asm):00242                  bne   L08F3        Yes, return
08B0 0C31             (      fsrqmem.asm):00243                  inc   <D.Boot      Set boot flag
08B2 9E24             (      fsrqmem.asm):00244                  ldx   <D.Init      Get ptr to init module if it exists
08B4 270D             (      fsrqmem.asm):00245                  beq   L0908        it doesn't, point to boot name
08B6 EC8814           (      fsrqmem.asm):00246                  ldd   <BootStr,x   Get offset to text
08B9 2708             (      fsrqmem.asm):00247                  beq   L0908        Doesn't exist, get hard coded text
08BB 308B             (      fsrqmem.asm):00248                  leax   d,x         Adjust X to point to boot module
08BD 2007             (      fsrqmem.asm):00249                  bra   L090C        Try & link to module
                      (      fsrqmem.asm):00250         
08BF 426F6FF4         (      fsrqmem.asm):00251         boot     fcs   /Boot/
                      (      fsrqmem.asm):00252         
08C3 308CF9           (      fsrqmem.asm):00253         L0908    leax  <boot,pcr
                      (      fsrqmem.asm):00254         * Link to module and execute
08C6 86C1             (      fsrqmem.asm):00255         L090C    lda   #Systm+Objct
08C8 103F00           (      fsrqmem.asm):00256                  os9   F$Link   
08CB 25D9             (      fsrqmem.asm):00257                  bcs   L08F3
08CD 8662             (      fsrqmem.asm):00258                  lda   #'b        calling boot
08CF 9D5E             (      fsrqmem.asm):00259                  jsr   <D.BtBug
08D1 ADA4             (      fsrqmem.asm):00260                  jsr   ,y           load boot file
08D3 25D1             (      fsrqmem.asm):00261                  bcs   L08F3
08D5 DD38             (      fsrqmem.asm):00262                  std   <D.BtSz      save boot file size
08D7 9F36             (      fsrqmem.asm):00263                  stx   <D.BtPtr     save start pointer of bootfile
08D9 8662             (      fsrqmem.asm):00264                  lda   #'b        boot returns OK
08DB 9D5E             (      fsrqmem.asm):00265                  jsr   <D.BtBug
                      (      fsrqmem.asm):00266         * added for IOMan system memory extentions
                      (      fsrqmem.asm):00267                IFNE  H6309
                      (      fsrqmem.asm):00268                  ldd   M$Name,x   grab the name offset
                      (      fsrqmem.asm):00269                  ldd   d,x        find the first 2 bytes of the first module
                      (      fsrqmem.asm):00270                  cmpd  #$4E69     'Ni' ? (NitrOS9 module?)
                      (      fsrqmem.asm):00271                  bne   not.ext    no, not system memory extensions
                      (      fsrqmem.asm):00272                  ldd   M$Exec,x   grab the execution ptr
                      (      fsrqmem.asm):00273                  jmp   d,x        and go execute the system memory extension module
                      (      fsrqmem.asm):00274                ENDC
                      (      fsrqmem.asm):00275         
08DD DC38             (      fsrqmem.asm):00276         not.ext  ldd   <D.BtSz
08DF 8D0E             (      fsrqmem.asm):00277                  bsr   I.VBlock   internal verify block routine
08E1 9E4C             (      fsrqmem.asm):00278                  ldx   <D.SysDAT    get system DAT pointer
08E3 E60D             (      fsrqmem.asm):00279                  ldb   $0D,x      get highest allocated block number
08E5 5C               (      fsrqmem.asm):00280                  incb             allocate block 0, too
08E6 9E40             (      fsrqmem.asm):00281                  ldx   <D.BlkMap  point to the memory block map
08E8 16F8C6           (      fsrqmem.asm):00282                  lbra  L01DF      and go mark the blocks as used.
                      (      fsrqmem.asm):00283         
                      (      fsrqmem.asm):00284         **************************************************
                      (      fsrqmem.asm):00285         * System Call: F$VBlock
                      (      fsrqmem.asm):00286         *
                      (      fsrqmem.asm):00287         * Function: ??? (I believe this is to verify a block of modules at once
                      (      fsrqmem.asm):00288         *           rather than one at a time, used to verify entire OS9boot  - LCB)
                      (      fsrqmem.asm):00289         *
                      (      fsrqmem.asm):00290         * Input:  D = Size of block to verify
                      (      fsrqmem.asm):00291         *         X = Start address to verify
                      (      fsrqmem.asm):00292         *
                      (      fsrqmem.asm):00293         * Output: None
                      (      fsrqmem.asm):00294         *
                      (      fsrqmem.asm):00295         * Error:  CC = C bit set; B = error code       
                      (      fsrqmem.asm):00296         *
08EB EC41             (      fsrqmem.asm):00297         FVBlock  ldd   R$D,u        size of block to verify
08ED AE44             (      fsrqmem.asm):00298                  ldx   R$X,u        start address to verify
08EF 338B             (      fsrqmem.asm):00299         I.VBlock leau  d,x          point to end of bootfile
08F1 1F10             (      fsrqmem.asm):00300                  tfr   x,d          Move start ptr to D
08F3 84E0             (      fsrqmem.asm):00301                  anda  #$E0         Keep only 8K block part of ptr
08F5 5F               (      fsrqmem.asm):00302                  clrb
08F6 3446             (      fsrqmem.asm):00303                  pshs  d,u          Save ptrs
08F8 44               (      fsrqmem.asm):00304                  lsra               /16 to get MMU block #
08F9 44               (      fsrqmem.asm):00305                  lsra
08FA 44               (      fsrqmem.asm):00306                  lsra
08FB 44               (      fsrqmem.asm):00307                  lsra
08FC 109E4C           (      fsrqmem.asm):00308                  ldy   <D.SysDAT    get pointer to system DAT
08FF 31A6             (      fsrqmem.asm):00309                  leay  a,y          offset to bootfile
0901 EC84             (      fsrqmem.asm):00310         L092D    ldd   M$ID,x       get module ID
0903 108387CD         (      fsrqmem.asm):00311                  cmpd  #M$ID12      legal ID?
0907 2630             (      fsrqmem.asm):00312                  bne   L0954        no, keep looking
0909 EC04             (      fsrqmem.asm):00313                  ldd   M$Name,x     find name offset pointer
090B 3410             (      fsrqmem.asm):00314                  pshs  x
090D 308B             (      fsrqmem.asm):00315                  leax  d,x
090F A680             (      fsrqmem.asm):00316         name.prt lda   ,x+          get first character of the name
0911 9D5E             (      fsrqmem.asm):00317                  jsr   <D.BtBug     print it out
0913 2AFA             (      fsrqmem.asm):00318                  bpl   name.prt
0915 8620             (      fsrqmem.asm):00319                  lda   #C$SPAC      a space
0917 9D5E             (      fsrqmem.asm):00320                  jsr   <D.BtBug
0919 3510             (      fsrqmem.asm):00321                  puls  x
                      (      fsrqmem.asm):00322                IFNE  H6309
                      (      fsrqmem.asm):00323                  ldd   ,s           offset into block
                      (      fsrqmem.asm):00324                  subr  d,x          make X=offset into block
                      (      fsrqmem.asm):00325                ELSE
091B 1F10             (      fsrqmem.asm):00326                  tfr   x,d
091D A3E4             (      fsrqmem.asm):00327                  subd  ,s
091F 1F01             (      fsrqmem.asm):00328                  tfr   d,x          make X=offset into block
                      (      fsrqmem.asm):00329                ENDC
0921 1F20             (      fsrqmem.asm):00330                  tfr   y,d
0923 103F2E           (      fsrqmem.asm):00331                  os9   F$VModul
                      (      fsrqmem.asm):00332                IFNE  H6309
                      (      fsrqmem.asm):00333                  ldw   ,s
                      (      fsrqmem.asm):00334                  leax  w,x
                      (      fsrqmem.asm):00335                ELSE
0926 3404             (      fsrqmem.asm):00336                  pshs  b
0928 EC61             (      fsrqmem.asm):00337                  ldd   1,s
092A 308B             (      fsrqmem.asm):00338                  leax  d,x
092C 3504             (      fsrqmem.asm):00339                  puls  b
                      (      fsrqmem.asm):00340                ENDC
092E 2404             (      fsrqmem.asm):00341                  bcc   L094E        No error, skip ahead
0930 C1E7             (      fsrqmem.asm):00342                  cmpb  #E$KwnMod    Known Module error? (I think duplicate)
0932 2605             (      fsrqmem.asm):00343                  bne   L0954        no, skip ahead
0934 EC02             (      fsrqmem.asm):00344         L094E    ldd   M$Size,x     get module size
0936 308B             (      fsrqmem.asm):00345                  leax  d,x          Point to next module
0938 8C               (      fsrqmem.asm):00346                  fcb   $8C          skip 2 bytes
0939 3001             (      fsrqmem.asm):00347         L0954    leax  1,x          move to next byte
093B AC62             (      fsrqmem.asm):00348         L0956    cmpx  2,s          gone thru whole bootfile?
093D 25C2             (      fsrqmem.asm):00349                  bcs   L092D        no, keep looking
093F 3264             (      fsrqmem.asm):00350                  leas  4,s          purge stack
0941 5F               (      fsrqmem.asm):00351                  clrb
0942 39               (      fsrqmem.asm):00352                  rts
                      (    krn_beta5.asm):00649                 IFNE  H6309
                      (    krn_beta5.asm):00650                   use   fdelram.asm
                      (    krn_beta5.asm):00651                 ENDC
                      (    krn_beta5.asm):00652                   use   fallimg.asm
                      (      fallimg.asm):00001         **************************************************
                      (      fallimg.asm):00002         * System Call: F$AllImg
                      (      fallimg.asm):00003         *
                      (      fallimg.asm):00004         * Function: Allocate image RAM blocks
                      (      fallimg.asm):00005         *
                      (      fallimg.asm):00006         * Input:  A = Starting block number
                      (      fallimg.asm):00007         *         B = Number of blocks
                      (      fallimg.asm):00008         *         X = Process descriptor pointer
                      (      fallimg.asm):00009         *
                      (      fallimg.asm):00010         * Output: None
                      (      fallimg.asm):00011         *
                      (      fallimg.asm):00012         * Error:  CC = C bit set; B = error code
                      (      fallimg.asm):00013         *
0943 EC41             (      fallimg.asm):00014         FAllImg  ldd   R$D,u        get starting block # & # of blocks
0945 AE44             (      fallimg.asm):00015                  ldx   R$X,u        get process descriptor pointer
                      (      fallimg.asm):00016         * 6309 NOTE: IF W IS USED HERE, TRY TO PRESERVE IT AS F$SRQMEM WILL
                      (      fallimg.asm):00017         *   PROBABLY END UP USING IT
                      (      fallimg.asm):00018         * Entry point from F$SRqMem
0947 3476             (      fallimg.asm):00019         L09BE    pshs  d,x,y,u
0949 48               (      fallimg.asm):00020                  lsla               Start MMU block #*2 (2 bytes/DAT entry)
094A 318840           (      fallimg.asm):00021                  leay  P$DATImg,x   Point to DAT img in process descriptor
094D 31A6             (      fallimg.asm):00022                  leay  a,y          Point to specific block # we want
094F 4F               (      fallimg.asm):00023                  clra
0950 1F01             (      fallimg.asm):00024                  tfr   d,x          X=# of blocks
0952 DE40             (      fallimg.asm):00025                  ldu   <D.BlkMap    Get memory block map ptr
0954 3476             (      fallimg.asm):00026                  pshs  d,x,y,u      Save regs
0956 ECA1             (      fallimg.asm):00027         L09CD    ldd   ,y++         Get DAT for current block
0958 1083333E         (      fallimg.asm):00028                  cmpd  #DAT.Free    Is it free?
095C 270D             (      fallimg.asm):00029                  beq   L09E2        Yes, skip ahead
095E A6CB             (      fallimg.asm):00030                  lda   d,u          No, get the memory block block type
0960 8101             (      fallimg.asm):00031                  cmpa  #RAMinUse    RAM already in use?
0962 3506             (      fallimg.asm):00032                  puls  d            Get # of blocks to allocate back
0964 261A             (      fallimg.asm):00033                  bne   L09F7        not RAM in use, skip ahead
                      (      fallimg.asm):00034                IFNE  H6309
                      (      fallimg.asm):00035                  decd               Drop # of blocks needed
                      (      fallimg.asm):00036                ELSE
0966 830001           (      fallimg.asm):00037                  subd  #$0001       Drop # of blocks needed
                      (      fallimg.asm):00038                ENDC
0969 3406             (      fallimg.asm):00039                  pshs  d            Save as new # of blocks still needed
096B 301F             (      fallimg.asm):00040         L09E2    leax  -1,x         Drop total # of blocks needed
096D 26E7             (      fallimg.asm):00041                  bne   L09CD        Still more, keep checking
096F AEE1             (      fallimg.asm):00042                  ldx   ,s++         Get # of blocks still needed
0971 2716             (      fallimg.asm):00043                  beq   L0A00        None, skip ahead
0973 A6C0             (      fallimg.asm):00044         L09EA    lda   ,u+          Get flag byte for next MMU block in full memory map
0975 2604             (      fallimg.asm):00045                  bne   L09F2        Not free, skip ahead
0977 301F             (      fallimg.asm):00046                  leax  -1,x         Free, drop total # of blocks needed
0979 270E             (      fallimg.asm):00047                  beq   L0A00        No more left, skip ahead
097B 119342           (      fallimg.asm):00048         L09F2    cmpu  <D.BlkMap+2  Have we hit the end of the full memory map?
097E 25F3             (      fallimg.asm):00049                  blo   L09EA        No, keep checking
0980 C6CF             (      fallimg.asm):00050         L09F7    ldb   #E$MemFul    Yes, we couldn't allocate, mem full error
0982 3266             (      fallimg.asm):00051                  leas  6,s          Eat stack
0984 E761             (      fallimg.asm):00052                  stb   1,s          Save error # on stack to pull off as B
0986 53               (      fallimg.asm):00053                  comb
0987 35F6             (      fallimg.asm):00054                  puls  d,x,y,u,pc   Restore regs, exit with mem full error
                      (      fallimg.asm):00055         
                      (      fallimg.asm):00056         * Found enough RAM for allocation request
0989 3570             (      fallimg.asm):00057         L0A00    puls  x,y,u        Restore some regs
098B ECA1             (      fallimg.asm):00058         L0A02    ldd   ,y++         Get DAT image for current 8K block
098D 1083333E         (      fallimg.asm):00059                  cmpd  #DAT.Free    Is it marked as free?
0991 260C             (      fallimg.asm):00060                  bne   L0A16        No, skip ahead
0993 A6C0             (      fallimg.asm):00061         L0A0A    lda   ,u+          Yes, get memory map flag for MMU block
0995 26FC             (      fallimg.asm):00062                  bne   L0A0A        Already allocated in some way, look for free one
0997 6CC2             (      fallimg.asm):00063                  inc   ,-u          Was unused; set to RAMinUse
0999 1F30             (      fallimg.asm):00064                  tfr   u,d          Move ptr to just allocated block to D
099B 9340             (      fallimg.asm):00065                  subd  <D.BlkMap    Subtract start of main memory map ptr
099D ED3E             (      fallimg.asm):00066                  std   -2,y         Save MMU block # into DAT block
099F 301F             (      fallimg.asm):00067         L0A16    leax  -1,x         Dec # blocks left to assign
09A1 26E8             (      fallimg.asm):00068                  bne   L0A02        Keep going until all are allocated
09A3 AE62             (      fallimg.asm):00069                  ldx   2,s          Get process descriptor ptr back
                      (      fallimg.asm):00070                IFNE  H6309
                      (      fallimg.asm):00071                  oim   #ImgChg,P$State,x  flag DAT IMG change for system
                      (      fallimg.asm):00072                ELSE
09A5 A60C             (      fallimg.asm):00073                  lda   P$State,x    flag DAT IMG change for system
09A7 8A10             (      fallimg.asm):00074                  ora   #ImgChg
09A9 A70C             (      fallimg.asm):00075                  sta   P$State,x
                      (      fallimg.asm):00076                ENDC
09AB 5F               (      fallimg.asm):00077                  clrb               No error, restore regs & return
09AC 35F6             (      fallimg.asm):00078                  puls  d,x,y,u,pc
                      (    krn_beta5.asm):00653                   use   ffreehb.asm
                      (      ffreehb.asm):00001         **************************************************
                      (      ffreehb.asm):00002         * System Call: F$FreeHB
                      (      ffreehb.asm):00003         *
                      (      ffreehb.asm):00004         * Function: Get free high block (usually for video RAM allocation)
                      (      ffreehb.asm):00005         *           This does contiguous blocks only, and into a 64K workspace
                      (      ffreehb.asm):00006         *           (Ptr to DAT img for workspace in Y)
                      (      ffreehb.asm):00007         * Called from F$MapBlk and from SS.MpGPB)
                      (      ffreehb.asm):00008         *
                      (      ffreehb.asm):00009         * Input:  B = Block count
                      (      ffreehb.asm):00010         *         Y = DAT image pointer
                      (      ffreehb.asm):00011         *
                      (      ffreehb.asm):00012         * Output: A = High block number
                      (      ffreehb.asm):00013         *
                      (      ffreehb.asm):00014         * Error:  CC = C bit set; B = error code
                      (      ffreehb.asm):00015         *
09AE E642             (      ffreehb.asm):00016         FFreeHB  ldb   R$B,u          Get # blocks requested
09B0 10AE46           (      ffreehb.asm):00017                  ldy   R$Y,u          Get DAT Img ptr
09B3 8D05             (      ffreehb.asm):00018                  bsr   L0A31          Go find free blocks in high part of DAT
09B5 2502             (      ffreehb.asm):00019         L0A2C    bcs   L0A30          Couldn't find any, exit with error
09B7 A741             (      ffreehb.asm):00020                  sta   R$A,u          Save starting block #
09B9 39               (      ffreehb.asm):00021         L0A30    rts                  Return
                      (      ffreehb.asm):00022         
09BA 1F98             (      ffreehb.asm):00023         L0A31    tfr   b,a            Copy # blocks requested to A
                      (      ffreehb.asm):00024         * This gets called directly from within F$Link
09BC 8009             (      ffreehb.asm):00025         L0A33    suba  #$09           Invert within 8
09BE 40               (      ffreehb.asm):00026                  nega
09BF 3416             (      ffreehb.asm):00027                  pshs  x,d            Save X, block # & block count
09C1 CCFFFF           (      ffreehb.asm):00028                  ldd   #$FFFF         -1'
09C4 3406             (      ffreehb.asm):00029         L0A56    pshs  d
                      (      ffreehb.asm):00030         
                      (      ffreehb.asm):00031         * Move to next block - SHOULD OPTIMIZE WITH W
09C6 4F               (      ffreehb.asm):00032         L0A58    clra                 # free blocks found so far=0
09C7 E662             (      ffreehb.asm):00033                  ldb   2,s            Get block #
09C9 EBE4             (      ffreehb.asm):00034                  addb  ,s             Add block increment (point to next block)
09CB E762             (      ffreehb.asm):00035                  stb   2,s            Save new block # to check
09CD E161             (      ffreehb.asm):00036                  cmpb  1,s            Same as block count?
09CF 2612             (      ffreehb.asm):00037                  bne   L0A75          No, skip ahead
09D1 C6CF             (      ffreehb.asm):00038                  ldb   #E$MemFul      Preset error for 207 (Process mem full)
09D3 109C4C           (      ffreehb.asm):00039                  cmpy  <D.SysDAT      Is it the system process?
09D6 2602             (      ffreehb.asm):00040                  bne   L0A6C          No, exit with error 207
09D8 C6ED             (      ffreehb.asm):00041                  ldb   #E$NoRAM       System Mem full (237)
09DA E763             (      ffreehb.asm):00042         L0A6C    stb   3,s            Save error code
09DC 53               (      ffreehb.asm):00043                  comb                 set carry
09DD 2011             (      ffreehb.asm):00044                  bra   L0A82          Exit with error
                      (      ffreehb.asm):00045         
09DF 1F89             (      ffreehb.asm):00046         L0A71    tfr   a,b            Copy # blocks to B
09E1 EB62             (      ffreehb.asm):00047                  addb  2,s            Add to current start block #
09E3 58               (      ffreehb.asm):00048         L0A75    lslb                 Multiply block # by 2
09E4 AEA5             (      ffreehb.asm):00049                  ldx   b,y            Get DAT marker for that block
09E6 8C333E           (      ffreehb.asm):00050                  cmpx  #DAT.Free      Empty block?
09E9 26DB             (      ffreehb.asm):00051                  bne   L0A58          No, move to next block
09EB 4C               (      ffreehb.asm):00052                  inca                 Bump up # blocks free counter
09EC A163             (      ffreehb.asm):00053                  cmpa  3,s            Have we got enough?
09EE 26EF             (      ffreehb.asm):00054                  bne   L0A71          No, keep looking
09F0 3262             (      ffreehb.asm):00055         L0A82    leas  2,s            Eat temporary stack
09F2 3596             (      ffreehb.asm):00056                  puls  d,x,pc         Restore reg, error code & return
                      (      ffreehb.asm):00057         
                      (      ffreehb.asm):00058         * Allocate blocks in caller's provided DAT img from low free memory
                      (      ffreehb.asm):00059         * Rodney says: "It's called via os9p1 syscall vector in line 393"
                      (      ffreehb.asm):00060         * This is the version called from system state (task 0)
09F4 E642             (      ffreehb.asm):00061         FSFreeLB ldb   R$B,u          Get block count
09F6 10AE46           (      ffreehb.asm):00062                  ldy   R$Y,u          Get ptr to DAT Image
09F9 8D02             (      ffreehb.asm):00063                  bsr   L0A4B          Go find block #'s
09FB 20B8             (      ffreehb.asm):00064                  bra   L0A2C          Do error checking & exit
                      (      ffreehb.asm):00065         
09FD 86FF             (      ffreehb.asm):00066         L0A4B    lda   #$FF           Value to start loop at block 0
09FF 3416             (      ffreehb.asm):00067                  pshs  x,d            Preserve X,flag & block count
                      (      ffreehb.asm):00068         *         lda   #$01           # to add to go to next block (positive here)
0A01 40               (      ffreehb.asm):00069                  nega             -(-1)=+1
0A02 C009             (      ffreehb.asm):00070                  subb  #9             Drop block count to -8 to -1 (invert within 8)
0A04 50               (      ffreehb.asm):00071                  negb                 Negate so it is a positive # again
0A05 20BD             (      ffreehb.asm):00072                  bra   L0A56          Go into main find loop
                      (      ffreehb.asm):00073         
                      (      ffreehb.asm):00074         
                      (      ffreehb.asm):00075         **************************************************
                      (      ffreehb.asm):00076         * System Call: F$FreeLB
                      (      ffreehb.asm):00077         *
                      (      ffreehb.asm):00078         * Function: Get free low block using caller provided DAT image
                      (      ffreehb.asm):00079         *           This does contiguous blocks only, and into a 64K workspace
                      (      ffreehb.asm):00080         *           (Ptr to DAT img for workspace in Y). Used for non-video related
                      (      ffreehb.asm):00081         *           allocation (loading modules, RAM drives, etc.)
                      (      ffreehb.asm):00082         *
                      (      ffreehb.asm):00083         * Input:  B = Block count
                      (      ffreehb.asm):00084         *         Y = DAT image pointer
                      (      ffreehb.asm):00085         *
                      (      ffreehb.asm):00086         * Output: A = Low block number
                      (      ffreehb.asm):00087         *
                      (      ffreehb.asm):00088         * Error:  CC = C bit set; B = error code
                      (      ffreehb.asm):00089         * this is the version called from user state (like Grfdrv)
0A07 EC41             (      ffreehb.asm):00090         FFreeLB  ldd   R$D,u        B=# blocks needed,A=offset into DAT img
0A09 AE44             (      ffreehb.asm):00091                  ldx   R$X,u        Get callers X and U regs (note: these do not
0A0B EE48             (      ffreehb.asm):00092                  ldu   R$U,u         appear in the manual) X=DAT img ptr
0A0D 3476             (      ffreehb.asm):00093         L0A8C    pshs  d,x,y,u      Save regs
0A0F 318840           (      ffreehb.asm):00094                  leay  <P$DATImg,x  Point to DAT img in process descriptor
0A12 48               (      ffreehb.asm):00095                  lsla               *2 since 2 bytes/DAT image block #
0A13 31A6             (      ffreehb.asm):00096                  leay  a,y          Point to the DAT img entry we want
                      (      ffreehb.asm):00097                IFNE  H6309
                      (      ffreehb.asm):00098                  clra               D=# of bytes to copy
                      (      ffreehb.asm):00099                  lslb
                      (      ffreehb.asm):00100                  tfr   d,w
                      (      ffreehb.asm):00101                  tfm   u+,y+        Copy from ? to DAT image
                      (      ffreehb.asm):00102                  oim   #ImgChg,P$State,x  Flag DAT img change for system
                      (      ffreehb.asm):00103                ELSE
0A15 58               (      ffreehb.asm):00104                  lslb               B=# bytes to copy
0A16 A6C0             (      ffreehb.asm):00105         L0ALoop  lda   ,u+          Copy from ? to DAT image
0A18 A7A0             (      ffreehb.asm):00106                  sta   ,y+
0A1A 5A               (      ffreehb.asm):00107                  decb
0A1B 26F9             (      ffreehb.asm):00108                  bne   L0ALoop
0A1D A60C             (      ffreehb.asm):00109                  lda   P$State,x    Flag DAT imge change for system
0A1F 8A10             (      ffreehb.asm):00110                  ora   #ImgChg
0A21 A70C             (      ffreehb.asm):00111                  sta   P$State,x
                      (      ffreehb.asm):00112                ENDC
0A23 5F               (      ffreehb.asm):00113                  clrb               No error, restore regs & return
0A24 35F6             (      ffreehb.asm):00114                  puls  d,x,y,u,pc
                      (    krn_beta5.asm):00654                   use   fdatlog.asm
                      (      fdatlog.asm):00001         **************************************************
                      (      fdatlog.asm):00002         * System Call: F$DATLog
                      (      fdatlog.asm):00003         *
                      (      fdatlog.asm):00004         * Function: Convert DAT block/offset to logical address
                      (      fdatlog.asm):00005         *
                      (      fdatlog.asm):00006         * Input:  B = DAT image offset
                      (      fdatlog.asm):00007         *         X = Block offset
                      (      fdatlog.asm):00008         *
                      (      fdatlog.asm):00009         * Output: X = Logical address
                      (      fdatlog.asm):00010         *
                      (      fdatlog.asm):00011         * Error:  CC = C bit set; B = error code
                      (      fdatlog.asm):00012         *
0A26 E642             (      fdatlog.asm):00013         FDATLog  ldb   R$B,u          Get logical Block #
0A28 AE44             (      fdatlog.asm):00014                  ldx   R$X,u          Get offset into block
0A2A 8D04             (      fdatlog.asm):00015                  bsr   CmpLBlk        Go modify X to be Logical address
0A2C AF44             (      fdatlog.asm):00016                  stx   R$X,u          Save in callers X register
0A2E 5F               (      fdatlog.asm):00017                  clrb                 No error & return
0A2F 39               (      fdatlog.asm):00018                  rts
                      (      fdatlog.asm):00019         
                      (      fdatlog.asm):00020         * Compute logical address given B=Logical Block # & X=offset into block
                      (      fdatlog.asm):00021         * Exits with B being logical block & X=logical address
0A30 3404             (      fdatlog.asm):00022         CmpLBlk  pshs  b              Preserve logical block #
0A32 1F98             (      fdatlog.asm):00023                  tfr   b,a            Move log. block # to A
0A34 48               (      fdatlog.asm):00024                  lsla                 Multiply logical block by 32
0A35 48               (      fdatlog.asm):00025                  lsla
0A36 48               (      fdatlog.asm):00026                  lsla
0A37 48               (      fdatlog.asm):00027                  lsla
0A38 48               (      fdatlog.asm):00028                  lsla
0A39 5F               (      fdatlog.asm):00029                  clrb                 D=8k offset value
                      (      fdatlog.asm):00030                IFNE  H6309
                      (      fdatlog.asm):00031                  addr  d,x            X=logical address in 64k workspace
                      (      fdatlog.asm):00032                ELSE
0A3A 308B             (      fdatlog.asm):00033                  leax  d,x
                      (      fdatlog.asm):00034                ENDC
0A3C 3584             (      fdatlog.asm):00035                  puls  b,pc           Restore A, block # & return
                      (    krn_beta5.asm):00655                   use   fld.asm
                      (          fld.asm):00001         **************************************************
                      (          fld.asm):00002         * System Call: F$LDAXY
                      (          fld.asm):00003         *
                      (          fld.asm):00004         * Function: Load A [X,[Y]]
                      (          fld.asm):00005         *
                      (          fld.asm):00006         * Input:  X = Block offset
                      (          fld.asm):00007         *         Y = DAT image pointer
                      (          fld.asm):00008         *
                      (          fld.asm):00009         * Output: A = data byte at X offset of Y
                      (          fld.asm):00010         *
                      (          fld.asm):00011         * Error:  CC = C bit set; B = error code
                      (          fld.asm):00012         *
0A3E AE44             (          fld.asm):00013         FLDAXY   ldx   R$X,u          Get offset within block (S/B $0000-$1FFF)
0A40 10AE46           (          fld.asm):00014                  ldy   R$Y,u          Get ptr to DAT block entry
0A43 8D03             (          fld.asm):00015                  bsr   L0AC8          Go get byte
0A45 A741             (          fld.asm):00016                  sta   R$A,u          Save in caller's A reg.
0A47 39               (          fld.asm):00017                  rts
                      (          fld.asm):00018         
                      (          fld.asm):00019         * Entry: X=offset ($0000-$1fff) to get from block pointed to by Y (DAT entry
                      (          fld.asm):00020         * format)
0A48 A621             (          fld.asm):00021         L0AC8    lda   1,y            Get MMU block # to get data from
0A4A 5F               (          fld.asm):00022                  clrb                 Clear carry/setup for STB
0A4B 3401             (          fld.asm):00023                  pshs  cc             Preserve interrupt status/settings
0A4D 1A50             (          fld.asm):00024                  orcc  #IntMasks      shut IRQ's off
0A4F B7FFA0           (          fld.asm):00025                  sta   >DAT.Regs      Map block into $0000-$1FFF
0A52 A684             (          fld.asm):00026                  lda   ,x             Get byte
0A54 F7FFA0           (          fld.asm):00027                  stb   >DAT.Regs      Map block 0 into $0000-$1FFF
0A57 3581             (          fld.asm):00028                  puls  pc,cc          Get interrupt status/(or turn on) & return
                      (          fld.asm):00029         
                      (          fld.asm):00030         * Get 1st byte of LDDDXY - also used by many other routines
                      (          fld.asm):00031         * Increments X on exit; adjusts X for within 8K block & Y (DAT img ptr)
0A59 A621             (          fld.asm):00032         LDAXY    lda   1,y            Get MMU block #
0A5B 3405             (          fld.asm):00033                  pshs  b,cc           Save regs
0A5D 5F               (          fld.asm):00034                  clrb
0A5E 1A50             (          fld.asm):00035                  orcc  #IntMasks      Shut off interrupts
0A60 B7FFA0           (          fld.asm):00036                  sta   >DAT.Regs      Map in MMU block into slot 0
0A63 A680             (          fld.asm):00037                  lda   ,x+            Get byte
0A65 F7FFA0           (          fld.asm):00038                  stb   >DAT.Regs      Map MMU block #0 back
0A68 3505             (          fld.asm):00039                  puls  b,cc
0A6A 2006             (          fld.asm):00040                  bra   AdjBlk0
                      (          fld.asm):00041         
0A6C 3089E000         (          fld.asm):00042         L0AEA    leax  >-DAT.BlSz,x      Bump offset ptr to start of block again
0A70 3122             (          fld.asm):00043                  leay  2,y            Bump source MMU block up to next on in DAT Image
0A72 8C2000           (          fld.asm):00044         AdjBlk0  cmpx  #DAT.BlSz      Going to wrap out of our block?
0A75 24F5             (          fld.asm):00045                  bhs   L0AEA          Yes, go adjust
0A77 39               (          fld.asm):00046                  rts                  No, return
                      (          fld.asm):00047         
                      (          fld.asm):00048         
                      (          fld.asm):00049         **************************************************
                      (          fld.asm):00050         * System Call: F$LDDXY
                      (          fld.asm):00051         *
                      (          fld.asm):00052         * Function: Load D [D+X,[Y]]
                      (          fld.asm):00053         *
                      (          fld.asm):00054         * Input:  D = Offset to offset
                      (          fld.asm):00055         *         X = Offset
                      (          fld.asm):00056         *         Y = DAT image pointer
                      (          fld.asm):00057         *
                      (          fld.asm):00058         * Output: D = bytes address by [D+X,Y]
                      (          fld.asm):00059         *
                      (          fld.asm):00060         * Error:  CC = C bit set; B = error code
                      (          fld.asm):00061         *
0A78 EC41             (          fld.asm):00062         FLDDDXY  ldd   R$D,u          Get offset to offset within DAT Image
0A7A 3344             (          fld.asm):00063                  leau  R$X,u          Point U to Offset
0A7C 3730             (          fld.asm):00064                  pulu  x,y            Y=Offset within DAT Image, X=DAT Image ptr
0A7E 8D04             (          fld.asm):00065                  bsr   L0B02          Go get 2 bytes
0A80 ED59             (          fld.asm):00066                  std   -(R$X+3),u     Save into caller's X
0A82 5F               (          fld.asm):00067                  clrb                 No error & return
0A83 39               (          fld.asm):00068                  rts
                      (          fld.asm):00069         * Get 2 bytes for LDDDXY (also called by other routines)
                      (          fld.asm):00070         * Should simply map in 2 blocks, and do a LDD (don't have to worry about wrap)
0A84 3470             (          fld.asm):00071         L0B02    pshs  u,y,x          Preserve regs
                      (          fld.asm):00072                IFNE  H6309
                      (          fld.asm):00073                  addr  d,x            Point X to X+D
                      (          fld.asm):00074                ELSE
0A86 308B             (          fld.asm):00075                  leax  d,x
                      (          fld.asm):00076                ENDC
0A88 8DE8             (          fld.asm):00077                  bsr   AdjBlk0        Wrap address around for 1 block
0A8A DE4C             (          fld.asm):00078                  ldu   <D.SysDAT      Get sys DAT Image ptr
0A8C 4F               (          fld.asm):00079                  clra             system block 0 =0 always
0A8D E643             (          fld.asm):00080                  ldb   3,u            Get MMU block #1
0A8F 1F03             (          fld.asm):00081                  tfr   d,u        make U=blocks to re-map in once done
0A91 A621             (          fld.asm):00082                  lda   1,y            Get MMU block #0
0A93 E623             (          fld.asm):00083                  ldb   3,y            Get MMU block #1
0A95 3401             (          fld.asm):00084                  pshs  cc             Preserve int. status
0A97 1A50             (          fld.asm):00085                  orcc  #IntMasks      shut off int.
0A99 FDFFA0           (          fld.asm):00086                  std   >DAT.Regs      Map in both blocks
0A9C EC84             (          fld.asm):00087                  ldd   ,x             Get 2 bytes
0A9E FFFFA0           (          fld.asm):00088                  stu   >DAT.Regs      Map original blocks in
0AA1 35F1             (          fld.asm):00089                  puls  pc,u,y,x,cc    Restore regs & return
                      (    krn_beta5.asm):00656                   use   fcpymem_beta5.asm
                      (fcpymem_beta5.asm):00001         **************************************************
                      (fcpymem_beta5.asm):00002         * System Call: F$CpyMem
                      (fcpymem_beta5.asm):00003         *
                      (fcpymem_beta5.asm):00004         * Function: Copy external memory
                      (fcpymem_beta5.asm):00005         *
                      (fcpymem_beta5.asm):00006         * Input:  D = Starting memory block number
                      (fcpymem_beta5.asm):00007         *         X = Offset in block to begin copy
                      (fcpymem_beta5.asm):00008         *         Y = Byte count
                      (fcpymem_beta5.asm):00009         *         U = Caller's destination buffer
                      (fcpymem_beta5.asm):00010         * Entry:  U = register stack ptr
                      (fcpymem_beta5.asm):00011         * Output: None
                      (fcpymem_beta5.asm):00012         *
                      (fcpymem_beta5.asm):00013         * Error:  CC = C bit set; B = error code
                      (fcpymem_beta5.asm):00014         *
                      (fcpymem_beta5.asm):00015                 IFNE  H6309
                      (fcpymem_beta5.asm):00016         * F$CpyMem for NitrOS-9 Level Two
                      (fcpymem_beta5.asm):00017         * Notes:
                      (fcpymem_beta5.asm):00018         * Exits w/o error if one attempts to copy overtop vector page or I/O page
                      (fcpymem_beta5.asm):00019         * 6809 version now updated to do same check LCB 11/25/2019
0AA3                  (fcpymem_beta5.asm):00020         FCpyMem  ldd   R$Y,u        get byte count
                      (fcpymem_beta5.asm):00021                  beq   L0A01        nothing there so nothing to move, return
                      (fcpymem_beta5.asm):00022                  addd  R$U,u        add it caller's buffer start ptr.
                      (fcpymem_beta5.asm):00023                  cmpa  #$FE         Is it going to overwrite Vector or I/O pages?
                      (fcpymem_beta5.asm):00024                  bhs   L0A01        Yes, exit without error
                      (fcpymem_beta5.asm):00025                  leas  -$10,s       make a buffer for DAT image
                      (fcpymem_beta5.asm):00026                  leay  ,s           point to it
                      (fcpymem_beta5.asm):00027                  pshs  y,u          Preserve stack buffer ptr & register stack pointer
                      (fcpymem_beta5.asm):00028                  ldx   <D.Proc      Get caller's task #
                      (fcpymem_beta5.asm):00029                  ldf   P$Task,x     get task # of caller
                      (fcpymem_beta5.asm):00030                  leay  P$DATImg,x   Point to DAT image in callers's process dsc.
                      (fcpymem_beta5.asm):00031                  ldx   R$D,u        get caller's DAT image pointer
                      (fcpymem_beta5.asm):00032                  lde   #$08         counter (for double byte moves)
                      (fcpymem_beta5.asm):00033                  ldu   ,s           get temp. stack buffer pointer
                      (fcpymem_beta5.asm):00034         * This loop copies the DAT image from the caller's process descriptor into
                      (fcpymem_beta5.asm):00035         * a temporary buffer on the stack
0AA3                  (fcpymem_beta5.asm):00036         L09C7    clrd               Clear offset to 0
                      (fcpymem_beta5.asm):00037                  bsr   L0B02        Short cut OS9 F$LDDDXY
                      (fcpymem_beta5.asm):00038                  std   ,u++         save it to buffer
                      (fcpymem_beta5.asm):00039                  leax  2,x          Bump ptr
                      (fcpymem_beta5.asm):00040                  dece               Decrement loop counter
                      (fcpymem_beta5.asm):00041                  bne   L09C7        Keep doing until 16 bytes is done
                      (fcpymem_beta5.asm):00042                  ldu   2,s          Get back register stack pointer
                      (fcpymem_beta5.asm):00043                  lbsr  L0CA6        Short cut OS9 F$ResTsk
                      (fcpymem_beta5.asm):00044                  bcs   L09FB        If error, deallocate our stack & exit with error
                      (fcpymem_beta5.asm):00045                  tfr   b,e          New temp task # into E
                      (fcpymem_beta5.asm):00046                  lslb               Multiply by 2 for 2 byte entries
                      (fcpymem_beta5.asm):00047                  ldx   <D.TskIPt    Get ptr to task image table
                      (fcpymem_beta5.asm):00048         * Make new temporary task use the memory blocks from the requested DAT image
                      (fcpymem_beta5.asm):00049         *   from the caller, to help do a 1 shot F$Move command, because in general
                      (fcpymem_beta5.asm):00050         * the temporary DAT image is not associated with a task.
                      (fcpymem_beta5.asm):00051                  ldu   ,s           Get pointer to DAT image we just copied
                      (fcpymem_beta5.asm):00052                  stu   b,x          Point new task image table to our DAT image copy
                      (fcpymem_beta5.asm):00053                  ldu   2,s          Get back data area pointer
                      (fcpymem_beta5.asm):00054                  tfr   w,d          Move temp & caller's task #'s into proper regs.
                      (fcpymem_beta5.asm):00055                  pshs  a            Save new task #
                      (fcpymem_beta5.asm):00056                  bsr   L0B25        F$Move the memory into the caller's requested area
                      (fcpymem_beta5.asm):00057         * BAD Bug! Well, maybe not.  F$Move NEVER returns an error code
                      (fcpymem_beta5.asm):00058         * but if it did, we'd skip the $RelTsk, and have an orphan task
                      (fcpymem_beta5.asm):00059         * left over.
                      (fcpymem_beta5.asm):00060         *         bcs   L09FB        If error, purge stack & return with error code
                      (fcpymem_beta5.asm):00061                  puls  b            Get back new task #
                      (fcpymem_beta5.asm):00062                  lbsr  L0CC3        Short cut OS9 F$RelTsk
0AA3                  (fcpymem_beta5.asm):00063         L09FB    leas  <$14,s       Purge our stack buffer & return
                      (fcpymem_beta5.asm):00064                  rts
                      (fcpymem_beta5.asm):00065         
0AA3                  (fcpymem_beta5.asm):00066         L0A01    clrb               No error & exit
                      (fcpymem_beta5.asm):00067                  rts   
                      (fcpymem_beta5.asm):00068         
                      (fcpymem_beta5.asm):00069                ELSE
                      (fcpymem_beta5.asm):00070         
                      (fcpymem_beta5.asm):00071         * F$CpyMem for OS-9 Level Two- 6809 - for back in KRN
                      (fcpymem_beta5.asm):00072         * Entry: U=ptr to stack contents from caller (parameters)
0AA3 EC46             (fcpymem_beta5.asm):00073         FCpyMem  ldd   R$Y,u        Get # of bytes to copy
0AA5 274A             (fcpymem_beta5.asm):00074                  beq   L0A01        If 0, exit
0AA7 E348             (fcpymem_beta5.asm):00075                  addd  R$U,u        plus dest buff
                      (fcpymem_beta5.asm):00076         * LCB - Added check to match 6309 version
0AA9 81FE             (fcpymem_beta5.asm):00077                  cmpa  #$FE         Is it going to overwrite Vector or I/O pages?
0AAB 2444             (fcpymem_beta5.asm):00078                  bhs   L0A01        Yes, exit without error
0AAD 3270             (fcpymem_beta5.asm):00079                  leas  -$10,s       Make room on stack for temp DAT image
0AAF 31E4             (fcpymem_beta5.asm):00080                  leay  ,s           Point to it
0AB1 3460             (fcpymem_beta5.asm):00081                  pshs  y,u          Save temp DAT img & register stack ptrs
0AB3 9E50             (fcpymem_beta5.asm):00082                  ldx   <D.Proc      Get current process descriptor ptr
0AB5 8608             (fcpymem_beta5.asm):00083                  lda   #8           # of 16 bit words to copy
0AB7 E606             (fcpymem_beta5.asm):00084                  ldb   P$Task,x     Get current process;s task #
0AB9 3406             (fcpymem_beta5.asm):00085                  pshs  d            save ctr & caller task #
0ABB 318840           (fcpymem_beta5.asm):00086                  leay  P$DATImg,x   Point to DAT image of caller
0ABE AE41             (fcpymem_beta5.asm):00087                  ldx   R$D,u        Get caller's ptr to the DAT image they provided
0AC0 EE62             (fcpymem_beta5.asm):00088                  ldu   2,s          Get temp DAT IMG Ptr
0AC2 4F               (fcpymem_beta5.asm):00089         L09C7    clra               Set offset to offset to 0
0AC3 5F               (fcpymem_beta5.asm):00090                  clrb
0AC4 8DBE             (fcpymem_beta5.asm):00091                  bsr   L0B02        Short cut OS9 F$LDDDXY
0AC6 EDC1             (fcpymem_beta5.asm):00092                  std   ,u++         to our temp DAT img
0AC8 3002             (fcpymem_beta5.asm):00093                  leax  2,x          2 bytes per entry
0ACA 6AE4             (fcpymem_beta5.asm):00094                  dec   ,s           copy all 8 sets of 2 bytes
0ACC 26F4             (fcpymem_beta5.asm):00095                  bne   L09C7
0ACE EE64             (fcpymem_beta5.asm):00096                  ldu   4,s          get callers register stack pr back
0AD0 17019E           (fcpymem_beta5.asm):00097                  lbsr  L0CA6        short cut os9 F$ResTsk (returns in B, destroys A)
0AD3 2518             (fcpymem_beta5.asm):00098                  bcs   L09FB        If error, deallocate our stack & exit with error
0AD5 E7E4             (fcpymem_beta5.asm):00099                  stb   ,s           Save copy of new temp task # (overtop temp ctr)
                      (fcpymem_beta5.asm):00100         * 0,s   =new temp task #
                      (fcpymem_beta5.asm):00101         * 1,s   =task # of caller
                      (fcpymem_beta5.asm):00102         * 2-3,s =temp DAT image buffer ptr
                      (fcpymem_beta5.asm):00103         * 4-5,s =callers register stack ptr
                      (fcpymem_beta5.asm):00104         * 6-21,s=temp DAT image
0AD7 58               (fcpymem_beta5.asm):00105                  lslb               *2 for 2 byte entries
0AD8 9EA1             (fcpymem_beta5.asm):00106                  ldx   <D.TskIPt    Get ptr to task image table
                      (fcpymem_beta5.asm):00107         * Use new temporary task for 1 shot F$Move command
0ADA EE62             (fcpymem_beta5.asm):00108                  ldu   2,s          Get ptr to DAT image we just copied
0ADC EF85             (fcpymem_beta5.asm):00109                  stu   b,x          Point new task image table to our DAT image copy
0ADE EE64             (fcpymem_beta5.asm):00110                  ldu   4,s          Get back callers register stack ptr
0AE0 ECE0             (fcpymem_beta5.asm):00111                  ldd   ,s+          A=temp task #,B=callers task #, eat temp task#
                      (fcpymem_beta5.asm):00112         * 0,s   =task # of caller
                      (fcpymem_beta5.asm):00113         * 1-2,s =temp DAT image buffer ptr
                      (fcpymem_beta5.asm):00114         * 3-4,s =callers register stack ptr
                      (fcpymem_beta5.asm):00115         * 5-20,s=temp DAT image
0AE2 A7E4             (fcpymem_beta5.asm):00116                  sta   ,s           Save temp task #
0AE4 8D0F             (fcpymem_beta5.asm):00117                  bsr   L0B25        Shortcut F$Move memory into callers requested area
0AE6 3504             (fcpymem_beta5.asm):00118                  puls  b            get back temp task #
0AE8 1701A1           (fcpymem_beta5.asm):00119                  lbsr  L0CC3        Shortcut OS9 F$RelTsk
0AEB 327E             (fcpymem_beta5.asm):00120                  leas  -2,s         Adjust stack for fall thru
0AED 32E816           (fcpymem_beta5.asm):00121         L09FB    leas  $16,s        Purge our stack buffer ptr & return
0AF0 39               (fcpymem_beta5.asm):00122                  rts
                      (fcpymem_beta5.asm):00123         
0AF1 5F               (fcpymem_beta5.asm):00124         L0A01    clrb
0AF2 39               (fcpymem_beta5.asm):00125                  rts
                      (fcpymem_beta5.asm):00126                ENDC
                      (    krn_beta5.asm):00657                   use   fmove.asm
                      (        fmove.asm):00001         **************************************************
                      (        fmove.asm):00002         * System Call: F$Move
                      (        fmove.asm):00003         *
                      (        fmove.asm):00004         * Function: Move data (low bound first)
                      (        fmove.asm):00005         * Entry: U=ptr to caller's stack (see Input for what registers on stack
                      (        fmove.asm):00006         *  mean)
                      (        fmove.asm):00007         *
                      (        fmove.asm):00008         * Input:  A = Source task #
                      (        fmove.asm):00009         *         B = Destination task #
                      (        fmove.asm):00010         *         X = Source pointer
                      (        fmove.asm):00011         *         Y = Number of bytes to move
                      (        fmove.asm):00012         *         U = Destination pointer
                      (        fmove.asm):00013         *
                      (        fmove.asm):00014         * Output: None
                      (        fmove.asm):00015         *
                      (        fmove.asm):00016         * Error:  CC = C bit set; B = error code
                      (        fmove.asm):00017         *
                      (        fmove.asm):00018         * 2009/12/31 - Modified 6809 version so that it does not use the stack
                      (        fmove.asm):00019         * while MMU is in used... this addresses a crash that occurred when the
                      (        fmove.asm):00020         * bootfile was too small, causing the process descriptor to be allocated
                      (        fmove.asm):00021         * in the $AXXX range, and as a result, the process stack pointer would get
                      (        fmove.asm):00022         * switched out when $FFA5-$FFA6 was written and the stack would disappear.
                      (        fmove.asm):00023         * 2019/11/20 - Changed to use DP location for counter (DEC<xx is 6
                      (        fmove.asm):00024         * cycles) using D.IRQTmp. Saves 14 cycles/8 bytes copied in block copy loop
                      (        fmove.asm):00025         * Used D.IRQTmp+1 for copy of current block size as well.
                      (        fmove.asm):00026         * Eliminated pshs cc/puls cc around actual copy loop (when both temp MMU
                      (        fmove.asm):00027         * blocks swapped in) replacing with just orcc/andcc (slightly smaller, faster)
                      (        fmove.asm):00028         * Attempted change to size of copy from 64 to 96 bytes with new faster routine
                      (        fmove.asm):00029         *   (still has IRQ's off for 17 cycles less than 6309 version)
                      (        fmove.asm):00030         * Should speed up larger F$Moves
                      (        fmove.asm):00031         
0AF3 EC41             (        fmove.asm):00032         FMove    ldd   R$D,u        get source & destination task #'s
                      (        fmove.asm):00033         * Entry point from F$CRC
0AF5 10AE46           (        fmove.asm):00034         L0B25    ldy   R$Y,u        Get # bytes to move
0AF8 27F7             (        fmove.asm):00035                  beq   L0A01        None, exit without error
0AFA AE44             (        fmove.asm):00036                  ldx   R$X,u        get source pointer
0AFC EE48             (        fmove.asm):00037                  ldu   R$U,u        get destination pointer
0AFE 3476             (        fmove.asm):00038         L0B2C    pshs  d,x,y,u      preserve it all
0B00 3426             (        fmove.asm):00039                  pshs  d,y          save task #'s & byte count
0B02 1F89             (        fmove.asm):00040                  tfr   a,b          copy source task to B
0B04 1700D1           (        fmove.asm):00041                  lbsr  L0BF5        calculate block offset of source
0B07 31C6             (        fmove.asm):00042                  leay  a,u          point to block
0B09 3430             (        fmove.asm):00043                  pshs  x,y          save source pointer & DAT pointer of source
0B0B E669             (        fmove.asm):00044                  ldb   9,s          get destination task #
0B0D AE6E             (        fmove.asm):00045                  ldx   14,s         get destination pointer
0B0F 1700C6           (        fmove.asm):00046                  lbsr  L0BF5        calculate block offset
0B12 31C6             (        fmove.asm):00047                  leay  a,u          point to block
0B14 3430             (        fmove.asm):00048                  pshs  x,y          save dest. pointer & DAT pointer to dest.
                      (        fmove.asm):00049         * try ldq #$20002000/ subr x,w / pshsw (+3), take out ldd (-3)
0B16 CC2000           (        fmove.asm):00050                  ldd   #DAT.BlSz    get block size
0B19 A3E4             (        fmove.asm):00051                  subd  ,s           take off offset
0B1B 3406             (        fmove.asm):00052                  pshs  d            preserve
0B1D CC2000           (        fmove.asm):00053                  ldd   #DAT.BlSz    init offset in block
0B20 A366             (        fmove.asm):00054                  subd  6,s
0B22 3406             (        fmove.asm):00055                  pshs  d            save distance to end??
0B24 AE68             (        fmove.asm):00056                  ldx   8,s          get source pointer
0B26 3089A000         (        fmove.asm):00057                  leax  -$6000,x     make X point to where we'll map block ($a000)
0B2A EE64             (        fmove.asm):00058                  ldu   4,s          get destination pointer
0B2C 33C9C000         (        fmove.asm):00059                  leau  -$4000,u     make U point to where we'll map block ($c000)
0B30 109E4C           (        fmove.asm):00060                  ldy   <D.SysDAT    Get ptr to system DAT image
0B33 A62B             (        fmove.asm):00061                  lda   11,y         Get MMU block #5
0B35 E62D             (        fmove.asm):00062                  ldb   13,y         Get MMU block #6
                      (        fmove.asm):00063                IFNE  H6309
                      (        fmove.asm):00064                  tfr   d,y          Move to Y since unused in loop below
                      (        fmove.asm):00065                ENDC
                      (        fmove.asm):00066         * Main move loop
                      (        fmove.asm):00067         * Stack:  0,s=distance to end of source block
                      (        fmove.asm):00068         *         2,s=distance to end of destination block
                      (        fmove.asm):00069         *         4,s=pointer to destination
                      (        fmove.asm):00070         *         6,s=pointer to destination DAT image
                      (        fmove.asm):00071         *         8,s=pointer to source
                      (        fmove.asm):00072         *        10,s=pointer to source DAT image
                      (        fmove.asm):00073         *        12,s=task # of source
                      (        fmove.asm):00074         *        13,s=task # of destination
                      (        fmove.asm):00075         *        14,s=total byte count of move
                      (        fmove.asm):00076         * Registers: X=Source pointer
                      (        fmove.asm):00077         *            U=Destination pointer
     0B37             (        fmove.asm):00078         L0B6A    equ   *
                      (        fmove.asm):00079                IFNE  H6309
                      (        fmove.asm):00080                  ldd   [<6,s]       [B]=Block # of source
                      (        fmove.asm):00081                  ldw   [<10,s]      [A]=Block # of destination
                      (        fmove.asm):00082                  tfr   f,a
                      (        fmove.asm):00083         * Calculate move length for this pass
                      (        fmove.asm):00084                  ldw   14,s         get full byte count
                      (        fmove.asm):00085                  cmpw  ,s           we gonna overlap source?
                      (        fmove.asm):00086                  bls   L0B82        no, skip ahead
                      (        fmove.asm):00087                  ldw   ,s           get remaining bytes in source block
0B37                  (        fmove.asm):00088         L0B82    cmpw  2,s          we gonna overlap destination?
                      (        fmove.asm):00089                  bls   L0B89        no, skip ahead
                      (        fmove.asm):00090                  ldw   2,s          get remaining bytes in destination block
0B37                  (        fmove.asm):00091         L0B89    cmpw  #$0100       less than 256 bytes?
                      (        fmove.asm):00092                  bls   L0B92        yes, skip ahead
                      (        fmove.asm):00093                  ldw   #$0100       force to 256 bytes
0B37                  (        fmove.asm):00094         L0B92    stw   12,s         save count
                      (        fmove.asm):00095                  orcc  #IntMasks    Shut off interrupts
                      (        fmove.asm):00096                  std   >$FFA5       map in the blocks
                      (        fmove.asm):00097                  tfm   x+,u+        Copy up to 256 bytes (max 774 cycles)
                      (        fmove.asm):00098                  sty   >$FFA5       Restore system blocks 5&6 to normal
                      (        fmove.asm):00099                  andcc #^IntMasks
                      (        fmove.asm):00100                  ldd   14,s         get full count
                      (        fmove.asm):00101                  subd  12,s         done?
                      (        fmove.asm):00102                  beq   L0BEF        yes, return
                      (        fmove.asm):00103                  std   14,s         save updated count
                      (        fmove.asm):00104                  ldd   ,s           get current offset in block
                      (        fmove.asm):00105                  subd  12,s         need to switch source block?
                      (        fmove.asm):00106                  bne   L0BD7        no, skip ahead
                      (        fmove.asm):00107                  lda   #$20         B=0 from 'bne' above
                      (        fmove.asm):00108                  subr  d,x          reset source back to begining of block
                      (        fmove.asm):00109                  inc   11,s         add 2 to source DAT pointer
                      (        fmove.asm):00110                  inc   11,s
0B37                  (        fmove.asm):00111         L0BD7    std   ,s           save updated source offset in block
                      (        fmove.asm):00112                  ldd   2,s          get destination offset
                      (        fmove.asm):00113                  subd  12,s         need to switch destination block?
                      (        fmove.asm):00114                  bne   L0BEA        no, skip ahead
                      (        fmove.asm):00115                  lda   #$20         B=0 from 'bne', above
                      (        fmove.asm):00116                  subr  d,u          reset destination back to beginning of block
                      (        fmove.asm):00117                  inc   7,s          add 2 to destination DAT pointer
                      (        fmove.asm):00118                  inc   7,s
0B37                  (        fmove.asm):00119         L0BEA    std   2,s          save updated destination offset in block
                      (        fmove.asm):00120                  bra   L0B6A        go do next block
                      (        fmove.asm):00121         
                      (        fmove.asm):00122         * Block move done, return
0B37                  (        fmove.asm):00123         L0BEF    leas  16,s         purge stack
0B37                  (        fmove.asm):00124         L0BF2    clrb               clear errors
                      (        fmove.asm):00125                  puls  d,x,y,u,pc   return
                      (        fmove.asm):00126         
                      (        fmove.asm):00127                ELSE
                      (        fmove.asm):00128         
                      (        fmove.asm):00129         * Main move loop
                      (        fmove.asm):00130         * Stack:  0,s=distance to end of source block
                      (        fmove.asm):00131         *         2,s=distance to end of destination block
                      (        fmove.asm):00132         *         4,s=pointer to destination
                      (        fmove.asm):00133         *         6,s=pointer to destination DAT image
                      (        fmove.asm):00134         *         8,s=pointer to source
                      (        fmove.asm):00135         *        10,s=pointer to source DAT image
                      (        fmove.asm):00136         *        12,s=task # of source      \ These get repurposed to hold
                      (        fmove.asm):00137         *        13,s=task # of destination / current block copy size (6809)
                      (        fmove.asm):00138         *        14,s=total byte count of move
                      (        fmove.asm):00139         * Registers: X=Source pointer
                      (        fmove.asm):00140         *            U=Destination pointer
0B37 ECF806           (        fmove.asm):00141         L0BXA    ldd   [<$6,s]      Get block # of source into B
0B3A 3404             (        fmove.asm):00142                  pshs  b            Save on stack
0B3C ECF80B           (        fmove.asm):00143                  ldd   [<10+1,s]    Get block # of dest into B
0B3F 3404             (        fmove.asm):00144                  pshs  b            Save on stack
0B41 ECE810           (        fmove.asm):00145                  ldd   <14+2,s      Get total byte count left we are copying
0B44 10A362           (        fmove.asm):00146                  cmpd  0+2,s        Will that go past end of source block?
0B47 2302             (        fmove.asm):00147                  bls   L0B82        No, check destination
0B49 EC62             (        fmove.asm):00148                  ldd   0+2,s        Get # of bytes until end of source block
0B4B 10A364           (        fmove.asm):00149         L0B82    cmpd  2+2,s        Will that go past end of dest block?
0B4E 2302             (        fmove.asm):00150                  bls   L0B89        No, check max size we want IRQ's of
0B50 EC64             (        fmove.asm):00151                  ldd   2+2,s        Get # of bytes until end of dest block
0B52 10830060         (        fmove.asm):00152         L0B89    cmpd  #$0060       >96 bytes to copy left?
0B56 2303             (        fmove.asm):00153                  bls   L0B84        No, do entire # of bytes left
0B58 CC0060           (        fmove.asm):00154                  ldd   #$0060       Yes, force to 96
0B5B ED6E             (        fmove.asm):00155         L0B84    std   12+2,s       Save size of current copy block
0B5D 3520             (        fmove.asm):00156                  puls  y            Get source & dest MMU block #'s
0B5F 1A50             (        fmove.asm):00157                  orcc  #IntMasks    Shut IRQ's off
0B61 D712             (        fmove.asm):00158                  stb   <D.IRQTmp+1  Save copy of current copy block size
0B63 10BFFFA5         (        fmove.asm):00159                  sty   >$FFA5       Swap in source/dest MMU blocks into $A000-$DFFF
                      (        fmove.asm):00160         ***** NO STACK USE BETWEEN HERE.....
0B67 C407             (        fmove.asm):00161                  andb  #$07         2 1st, do single byte copies for 1-7 leftover bytes
0B69 2707             (        fmove.asm):00162                  beq   L0B99        3 No leftovers, go to 8 byte copy routine
0B6B A680             (        fmove.asm):00163         L0B92    lda   ,x+          6 Copy 1-7 leftover bytes
0B6D A7C0             (        fmove.asm):00164                  sta   ,u+          6
0B6F 5A               (        fmove.asm):00165                  decb               2
0B70 26F9             (        fmove.asm):00166                  bne   L0B92        3
0B72 9612             (        fmove.asm):00167         L0B99    lda   <D.IRQTmp+1  +4 Get copy size back into A
0B74 44               (        fmove.asm):00168                  lsra               Divide size by 8 (since 8 byte chunks copying)
0B75 44               (        fmove.asm):00169                  lsra
0B76 44               (        fmove.asm):00170                  lsra
0B77 271A             (        fmove.asm):00171                  beq   L0BBC
0B79 9711             (        fmove.asm):00172                  sta    <D.IRQTmp   Save loop counter (# 8 byte blocks) +4
0B7B 1E13             (        fmove.asm):00173                  exg   x,u          Swap source/destination ptrs for PULU routine
0B7D 3726             (        fmove.asm):00174         L0BA4    pulu  y,d          9 55 cycles per 8 bytes copied
0B7F ED84             (        fmove.asm):00175                  std   ,x           5 (old pulu y/sty ,x++ was 69)
0B81 10AF02           (        fmove.asm):00176                  sty   2,x          6
0B84 3726             (        fmove.asm):00177                  pulu  y,d          9
0B86 ED04             (        fmove.asm):00178                  std   4,x          6
0B88 10AF06           (        fmove.asm):00179                  sty   6,x          6
0B8B 3008             (        fmove.asm):00180                  leax  8,x          5
0B8D 0A11             (        fmove.asm):00181                  dec   <D.IRQTmp    6
0B8F 26EC             (        fmove.asm):00182                  bne   L0BA4        3
0B91 1E13             (        fmove.asm):00183                  exg   x,u          8 Swap updated source/dest ptrs
0B93 109E4C           (        fmove.asm):00184         L0BBC    ldy   <D.SysDAT    6 Get system DAT pointer
0B96 A62B             (        fmove.asm):00185                  lda   $0B,y        5 Get original MMU blocks
0B98 E62D             (        fmove.asm):00186                  ldb   $0D,y        5
0B9A FDFFA5           (        fmove.asm):00187                  std   >$FFA5       6 Restore originals
                      (        fmove.asm):00188         ***** AND HERE...........
0B9D 1CAF             (        fmove.asm):00189                  andcc #^IntMasks   Turn IRQ's back on
0B9F EC6E             (        fmove.asm):00190                  ldd   14,s         Get # of bytes left to copy
0BA1 A36C             (        fmove.asm):00191                  subd  12,s         Subtract # bytes we copied
0BA3 272B             (        fmove.asm):00192                  beq   L0BEF        Done Move
0BA5 ED6E             (        fmove.asm):00193                  std   14,s         Save new # of bytes left to copy
0BA7 ECE4             (        fmove.asm):00194                  ldd   ,s           Get # bytes until end of source block
0BA9 A36C             (        fmove.asm):00195                  subd  12,s         Subtract # bytes copied
0BAB 260B             (        fmove.asm):00196                  bne   L0BD7        Still more in current source MMU block
0BAD CC2000           (        fmove.asm):00197                  ldd   #DAT.BlSz    Size of MMU block (8K)
                      (        fmove.asm):00198         * Since we know where the blocks are mapped, we can change this leax
                      (        fmove.asm):00199         * and the later leau to ldx #$A000 and ldu #$C000 (faster smaller)
0BB0 3089E000         (        fmove.asm):00200                  leax  >-DAT.BlSz,x Move source ptr back to beginning of MMU block
                      (        fmove.asm):00201         * If we do lda 11,s/adda #2/sta 11,s (2 more bytes, -2 cycles), move above
                      (        fmove.asm):00202         * ldd #DAT.BlSz to after the sta 11,s
                      (        fmove.asm):00203         * Not sure if worth the extra code space - these only get done when 8K
                      (        fmove.asm):00204         * boundaries are crossed, so not often at all
0BB4 6C6B             (        fmove.asm):00205                  inc   11,s         7 Add 2 to source DAT ptr
0BB6 6C6B             (        fmove.asm):00206                  inc   11,s
0BB8 EDE4             (        fmove.asm):00207         L0BD7    std   ,s           Save new distance (8K) to end of source block
0BBA EC62             (        fmove.asm):00208                  ldd   2,s          Get # bytes until end of dest block
0BBC A36C             (        fmove.asm):00209                  subd  12,s         Subtract # bytes copied
0BBE 260B             (        fmove.asm):00210                  bne   L0BEA        Still more in current dest MMU block
0BC0 CC2000           (        fmove.asm):00211                  ldd   #DAT.BlSz
0BC3 33C9E000         (        fmove.asm):00212                  leau  >-DAT.BlSz,u Wrap dest pr back
0BC7 6C67             (        fmove.asm):00213                  inc   7,s          7 Add 2 to dest DAT ptr
0BC9 6C67             (        fmove.asm):00214                  inc   7,s
0BCB ED62             (        fmove.asm):00215         L0BEA    std   2,s          Save # of bytes left in dest block
0BCD 16FF67           (        fmove.asm):00216                  lbra  L0BXA
                      (        fmove.asm):00217         
0BD0 32E810           (        fmove.asm):00218         L0BEF    leas  <$10,s       Eat temp stack
0BD3 5F               (        fmove.asm):00219         L0BF2    clrb               Exit w/o error
0BD4 35F6             (        fmove.asm):00220                  puls  pc,u,y,x,d
                      (        fmove.asm):00221         
                      (        fmove.asm):00222                ENDC
                      (        fmove.asm):00223         
0BD6 1F32             (        fmove.asm):00224         L0BF3    tfr   u,y        save a copy of U for later
                      (        fmove.asm):00225         * Calculate offset within DAT image
                      (        fmove.asm):00226         * Entry: B=Task #
                      (        fmove.asm):00227         *        X=Pointer to data
                      (        fmove.asm):00228         * Exit : A=Offset into DAT image
                      (        fmove.asm):00229         *        X=Offset within block from original pointer
                      (        fmove.asm):00230         * Possible bug:  No one ever checks if the DAT image, in fact, exists.
0BD8 DEA1             (        fmove.asm):00231         L0BF5    ldu   <D.TskIPt    get task image ptr table
0BDA 58               (        fmove.asm):00232                  lslb
0BDB EEC5             (        fmove.asm):00233                  ldu   b,u          get ptr to this task's DAT image
0BDD 1F10             (        fmove.asm):00234                  tfr   x,d          copy logical address to D
0BDF 84E0             (        fmove.asm):00235                  anda  #%11100000   Keep only which 8K bank it's in
0BE1 270F             (        fmove.asm):00236                  beq   L0C07        Bank 0, no further calcs needed
0BE3 5F               (        fmove.asm):00237                  clrb               force it to start on an 8K boundary
                      (        fmove.asm):00238                IFNE  H6309
                      (        fmove.asm):00239                  subr  d,x          now X=offset into the block
                      (        fmove.asm):00240                ELSE
0BE4 3406             (        fmove.asm):00241                  pshs  d
0BE6 1F10             (        fmove.asm):00242                  tfr   x,d
0BE8 A3E4             (        fmove.asm):00243                  subd  ,s
0BEA 1F01             (        fmove.asm):00244                  tfr   d,x
0BEC 3506             (        fmove.asm):00245                  puls  d
                      (        fmove.asm):00246                ENDC
0BEE 44               (        fmove.asm):00247                  lsra               Calculate offset into DAT image to get proper
0BEF 44               (        fmove.asm):00248                  lsra               8K bank (remember that each entry in a DAT image
0BF0 44               (        fmove.asm):00249                  lsra               is 2 bytes)
0BF1 44               (        fmove.asm):00250                  lsra
0BF2 39               (        fmove.asm):00251         L0C07    rts
                      (    krn_beta5.asm):00658                   use   fldabx.asm
                      (       fldabx.asm):00001         **************************************************
                      (       fldabx.asm):00002         * System Call: F$LDABX
                      (       fldabx.asm):00003         *
                      (       fldabx.asm):00004         * Function: Load A from 0,X in task B
                      (       fldabx.asm):00005         *
                      (       fldabx.asm):00006         * Input:  B = Task number
                      (       fldabx.asm):00007         *         X = Data pointer
                      (       fldabx.asm):00008         *
                      (       fldabx.asm):00009         * Output: A = Data byte at 0,x in task's address space
                      (       fldabx.asm):00010         *
                      (       fldabx.asm):00011         * Error:  CC = C bit set; B = error code
                      (       fldabx.asm):00012         *
0BF3 E642             (       fldabx.asm):00013         FLDABX   ldb   R$B,u        Get task # to get byte from
0BF5 AE44             (       fldabx.asm):00014                  ldx   R$X,u        Get offset into task's DAT image to get byte from
                      (       fldabx.asm):00015         * Load a byte from another task
                      (       fldabx.asm):00016         * Entry: B=Task #
                      (       fldabx.asm):00017         *        X=Pointer to data
                      (       fldabx.asm):00018         * Exit : B=Byte from other task
0BF7 3453             (       fldabx.asm):00019         L0C40    pshs  cc,a,x,u
0BF9 8DDD             (       fldabx.asm):00020                  bsr   L0BF5
0BFB ECC6             (       fldabx.asm):00021                  ldd   a,u
0BFD 1A50             (       fldabx.asm):00022                  orcc  #IntMasks
0BFF F7FFA0           (       fldabx.asm):00023                  stb   >DAT.Regs
0C02 E684             (       fldabx.asm):00024                  ldb   ,x
0C04 7FFFA0           (       fldabx.asm):00025                  clr   >DAT.Regs
0C07 3553             (       fldabx.asm):00026                  puls  cc,a,x,u
0C09 E741             (       fldabx.asm):00027                  stb   R$A,u        Save into caller's A & return
0C0B 5F               (       fldabx.asm):00028                  clrb               set to no errors
0C0C 39               (       fldabx.asm):00029                  rts
                      (       fldabx.asm):00030         
                      (       fldabx.asm):00031         **************************************************
                      (       fldabx.asm):00032         * System Call: F$STABX
                      (       fldabx.asm):00033         *
                      (       fldabx.asm):00034         * Function: Store A at 0,X in task B
                      (       fldabx.asm):00035         *
                      (       fldabx.asm):00036         * Input:  A = Data byte to store in task's address space
                      (       fldabx.asm):00037         *         B = Task number
                      (       fldabx.asm):00038         *         X = Logical address in task's address space
                      (       fldabx.asm):00039         *
                      (       fldabx.asm):00040         * Output: None
                      (       fldabx.asm):00041         *
                      (       fldabx.asm):00042         * Error:  CC = C bit set; B = error code
                      (       fldabx.asm):00043         *
0C0D EC41             (       fldabx.asm):00044         FSTABX   ldd   R$D,u
0C0F AE44             (       fldabx.asm):00045                  ldx   R$X,u
                      (       fldabx.asm):00046         * Store a byte in another task
                      (       fldabx.asm):00047         * Entry: A=Byte to store
                      (       fldabx.asm):00048         *        B=Task #
                      (       fldabx.asm):00049         *        X=Pointer to data
0C11 1CFE             (       fldabx.asm):00050         L0C28    andcc #^Carry
0C13 3457             (       fldabx.asm):00051                  pshs  cc,d,x,u
0C15 8DC1             (       fldabx.asm):00052                  bsr   L0BF5        calculate offset into DAT image
0C17 ECC6             (       fldabx.asm):00053                  ldd   a,u          get memory block
0C19 A661             (       fldabx.asm):00054                  lda   1,s
0C1B 1A50             (       fldabx.asm):00055                  orcc  #IntMasks
0C1D F7FFA0           (       fldabx.asm):00056                  stb   >DAT.Regs
0C20 A784             (       fldabx.asm):00057                  sta   ,x
0C22 7FFFA0           (       fldabx.asm):00058                  clr   >DAT.Regs
0C25 35D7             (       fldabx.asm):00059                  puls  cc,d,x,u,pc
                      (    krn_beta5.asm):00659                   use   falltsk.asm
                      (      falltsk.asm):00001         **************************************************
                      (      falltsk.asm):00002         * System Call: F$AllTsk
                      (      falltsk.asm):00003         *
                      (      falltsk.asm):00004         * Function: Allocate process task number
                      (      falltsk.asm):00005         *
                      (      falltsk.asm):00006         * Input:  X = Process descriptor pointer
                      (      falltsk.asm):00007         *
                      (      falltsk.asm):00008         * Output: None
                      (      falltsk.asm):00009         *
                      (      falltsk.asm):00010         * Error:  CC = C bit set; B = error code
                      (      falltsk.asm):00011         *
0C27 AE44             (      falltsk.asm):00012         FAllTsk  ldx   R$X,u        get pointer to process descriptor
0C29 E606             (      falltsk.asm):00013         L0C58    ldb   P$Task,x     already have a task #?
0C2B 2608             (      falltsk.asm):00014                  bne   L0C64        yes, return
0C2D 8D42             (      falltsk.asm):00015                  bsr   L0CA6        find a free task
0C2F 2505             (      falltsk.asm):00016                  bcs   L0C65        error, couldn't get one, return
0C31 E706             (      falltsk.asm):00017                  stb   P$Task,x     save task #
0C33 8D15             (      falltsk.asm):00018                  bsr   L0C79        load MMU with task
0C35 5F               (      falltsk.asm):00019         L0C64    clrb               clear errors
0C36 39               (      falltsk.asm):00020         L0C65    rts                return
                      (      falltsk.asm):00021         
                      (      falltsk.asm):00022         **************************************************
                      (      falltsk.asm):00023         * System Call: F$DelTsk
                      (      falltsk.asm):00024         *
                      (      falltsk.asm):00025         * Function: Deallocate process task number
                      (      falltsk.asm):00026         *
                      (      falltsk.asm):00027         * Input:  X = Process descriptor pointer
                      (      falltsk.asm):00028         *
                      (      falltsk.asm):00029         * Output: None
                      (      falltsk.asm):00030         *
                      (      falltsk.asm):00031         * Error:  CC = C bit set; B = error code
                      (      falltsk.asm):00032         *
0C37 AE44             (      falltsk.asm):00033         FDelTsk  ldx   R$X,u
0C39 E606             (      falltsk.asm):00034         L0C68    ldb   P$Task,x   grab the current task number
0C3B 27F8             (      falltsk.asm):00035                  beq   L0C64      if system (or released), exit
0C3D 6F06             (      falltsk.asm):00036                  clr   P$Task,x   force the task number to be zero
0C3F 204B             (      falltsk.asm):00037                  bra   L0CC3      do a F$RelTsk
                      (      falltsk.asm):00038         
     0C41             (      falltsk.asm):00039         TstImg   equ   *
                      (      falltsk.asm):00040                IFNE  H6309
                      (      falltsk.asm):00041                  tim   #ImgChg,P$State,x  DAT image change flagged in process desc?
                      (      falltsk.asm):00042                ELSE
0C41 E60C             (      falltsk.asm):00043                  ldb   P$State,x    DAT image change flagged in process desc?
0C43 C510             (      falltsk.asm):00044                  bitb  #ImgChg
                      (      falltsk.asm):00045                ENDC
0C45 27EF             (      falltsk.asm):00046                  beq   L0C65        if not, exit now: (clear carry not needed)
0C47 8C               (      falltsk.asm):00047                  fcb   $8C          skip LDX, below
                      (      falltsk.asm):00048         **************************************************
                      (      falltsk.asm):00049         * System Call: F$SetTsk
                      (      falltsk.asm):00050         *
                      (      falltsk.asm):00051         * Function: Set process task DAT registers
                      (      falltsk.asm):00052         *
                      (      falltsk.asm):00053         * Input:  X = Process descriptor pointer
                      (      falltsk.asm):00054         *
                      (      falltsk.asm):00055         * Output: None
                      (      falltsk.asm):00056         *
                      (      falltsk.asm):00057         * Error:  CC = C bit set; B = error code
                      (      falltsk.asm):00058         *
0C48 AE44             (      falltsk.asm):00059         FSetTsk  ldx   R$X,u        get process descriptor pointer
     0C4A             (      falltsk.asm):00060         L0C79    equ   *
                      (      falltsk.asm):00061                IFNE  H6309
                      (      falltsk.asm):00062                  aim   #^ImgChg,P$State,x flag DAT image change in process descriptor
                      (      falltsk.asm):00063                ELSE
0C4A E60C             (      falltsk.asm):00064                  ldb   P$State,x    flag DAT image change in process descriptor
0C4C C4EF             (      falltsk.asm):00065                  andb  #^ImgChg
0C4E E70C             (      falltsk.asm):00066                  stb   P$State,x
                      (      falltsk.asm):00067                ENDC
0C50 0F3D             (      falltsk.asm):00068                  clr   <D.Task1N  task 1 DAT image has changed
0C52 1CFE             (      falltsk.asm):00069                  andcc #^Carry      clear carry
0C54 3457             (      falltsk.asm):00070                  pshs  cc,d,x,u     preserve everything
0C56 E606             (      falltsk.asm):00071                  ldb   P$Task,x     get task #
0C58 338840           (      falltsk.asm):00072                  leau  <P$DATImg,x  point to DAT image
0C5B 9EA1             (      falltsk.asm):00073                  ldx   <D.TskIPt    get task image table pointer
0C5D 58               (      falltsk.asm):00074                  lslb               account for 2 bytes/entry
0C5E EF85             (      falltsk.asm):00075                  stu   b,x          save DAT image pointer in task table
0C60 C102             (      falltsk.asm):00076                  cmpb  #2           is it either system or GrfDrv?
0C62 2206             (      falltsk.asm):00077                  bhi   L0C9F        no, return
0C64 8EFFA0           (      falltsk.asm):00078                  ldx   #DAT.Regs    update system DAT image
0C67 170204           (      falltsk.asm):00079                  lbsr  L0E93      go bash the hardware
0C6A 35D7             (      falltsk.asm):00080         L0C9F    puls  cc,d,x,u,pc
                      (      falltsk.asm):00081         
                      (      falltsk.asm):00082         **************************************************
                      (      falltsk.asm):00083         * System Call: F$ResTsk
                      (      falltsk.asm):00084         *
                      (      falltsk.asm):00085         * Function: Reserve task number
                      (      falltsk.asm):00086         *
                      (      falltsk.asm):00087         * Input:  None
                      (      falltsk.asm):00088         *
                      (      falltsk.asm):00089         * Output: B = Task number
                      (      falltsk.asm):00090         *
                      (      falltsk.asm):00091         * Error:  CC = C bit set; B = error code
                      (      falltsk.asm):00092         *
0C6C 8D03             (      falltsk.asm):00093         FResTsk  bsr   L0CA6
0C6E E742             (      falltsk.asm):00094                  stb   R$B,u
0C70 39               (      falltsk.asm):00095         L0CA5    rts
                      (      falltsk.asm):00096         
                      (      falltsk.asm):00097         
                      (      falltsk.asm):00098         * Find a free task in task map
                      (      falltsk.asm):00099         * Entry: None
                      (      falltsk.asm):00100         * Exit : B=Task #
0C71 3410             (      falltsk.asm):00101         L0CA6    pshs  x            preserve X
0C73 C602             (      falltsk.asm):00102                  ldb   #$02         get starting task # (skip System/Grfdrv)
0C75 9E20             (      falltsk.asm):00103                  ldx   <D.Tasks     get task table pointer
0C77 A685             (      falltsk.asm):00104         L0CAC    lda   b,x          task allocated?
0C79 270A             (      falltsk.asm):00105                  beq   L0CBA        no, allocate it & return
0C7B 5C               (      falltsk.asm):00106                  incb               move to next task
0C7C C120             (      falltsk.asm):00107                  cmpb  #$20         end of task list?
0C7E 26F7             (      falltsk.asm):00108                  bne   L0CAC        no, keep looking
0C80 53               (      falltsk.asm):00109                  comb               set carry for error
0C81 C6EF             (      falltsk.asm):00110                  ldb   #E$NoTask    get error code
0C83 3590             (      falltsk.asm):00111                  puls  x,pc
                      (      falltsk.asm):00112         
0C85 E785             (      falltsk.asm):00113         L0CBA    stb   b,x          flag task used (1 cycle faster than inc)
0C87 4F               (      falltsk.asm):00114                  clra               clear carry
0C88 3590             (      falltsk.asm):00115         L0CBF    puls  x,pc         restore & return
                      (      falltsk.asm):00116         
                      (      falltsk.asm):00117         
                      (      falltsk.asm):00118         **************************************************
                      (      falltsk.asm):00119         * System Call: F$RelTsk
                      (      falltsk.asm):00120         *
                      (      falltsk.asm):00121         * Function: Release task number
                      (      falltsk.asm):00122         *
                      (      falltsk.asm):00123         * Input:  B = Task number
                      (      falltsk.asm):00124         *
                      (      falltsk.asm):00125         * Output: None
                      (      falltsk.asm):00126         *
                      (      falltsk.asm):00127         * Error:  CC = C bit set; B = error code
                      (      falltsk.asm):00128         *
0C8A E642             (      falltsk.asm):00129         FRelTsk  ldb   R$B,u        Get task # to release
0C8C 3414             (      falltsk.asm):00130         L0CC3    pshs  b,x          Preserve it & X
0C8E 5D               (      falltsk.asm):00131                  tstb               check out B
0C8F 2704             (      falltsk.asm):00132                  beq   L0CD0        If system task, don't bother deleting the task
0C91 9E20             (      falltsk.asm):00133                  ldx   <D.Tasks     Get task table ptr
0C93 6F85             (      falltsk.asm):00134                  clr   b,x          Clear out the task
0C95 3594             (      falltsk.asm):00135         L0CD0    puls  b,x,pc       Restore regs & return
                      (      falltsk.asm):00136         
                      (      falltsk.asm):00137         * Sleeping process update (Gets executed from clock)
                      (      falltsk.asm):00138         * Could move this code into Clock, but what about the call to F$AProc (L0D11)?
                      (      falltsk.asm):00139         * It probably will be OK... but have to check.
                      (      falltsk.asm):00140         *   Possible, move ALL software-clock code into OS9p2, and therefore
                      (      falltsk.asm):00141         * have it auto-initialize?  All hardware clocks would then be called
                      (      falltsk.asm):00142         * just once a minute.
0C97 9E56             (      falltsk.asm):00143         L0CD2    ldx   <D.SProcQ      Get sleeping process Queue ptr
0C99 2727             (      falltsk.asm):00144                  beq   L0CFD          None (no one sleeping), so exit
                      (      falltsk.asm):00145                IFNE  H6309
                      (      falltsk.asm):00146                  tim   #TimSleep,P$State,x  Is it a timed sleep?
                      (      falltsk.asm):00147                ELSE
0C9B E60C             (      falltsk.asm):00148                  ldb   P$State,x      Is it a timed sleep?
0C9D C540             (      falltsk.asm):00149                  bitb  #TimSleep
                      (      falltsk.asm):00150                ENDC
0C9F 2721             (      falltsk.asm):00151                  beq   L0CFD          No, exit: waiting for signal/interrupt
0CA1 EE04             (      falltsk.asm):00152                  ldu   P$SP,x         Yes, get his stack pointer
0CA3 EC44             (      falltsk.asm):00153                  ldd   R$X,u          Get his sleep tick count
                      (      falltsk.asm):00154                IFNE  H6309
                      (      falltsk.asm):00155                  decd                 decrement sleep count
                      (      falltsk.asm):00156                ELSE
0CA5 830001           (      falltsk.asm):00157                  subd  #$0001
                      (      falltsk.asm):00158                ENDC
0CA8 ED44             (      falltsk.asm):00159                  std   R$X,u          Save it back
0CAA 2616             (      falltsk.asm):00160                  bne   L0CFD          Still more ticks to go, so exit
                      (      falltsk.asm):00161         * Process needs to wake up, update queue pointers
0CAC EE0D             (      falltsk.asm):00162         L0CE7    ldu   P$Queue,x      Get next process in Queue
0CAE 8D26             (      falltsk.asm):00163                  bsr   L0D11          activate it
0CB0 30C4             (      falltsk.asm):00164                  leax  ,u             point to new process
0CB2 270C             (      falltsk.asm):00165                  beq   L0CFB          don't exist, go on
                      (      falltsk.asm):00166                IFNE  H6309
                      (      falltsk.asm):00167                  tim   #TimSleep,P$State,x  is it in a timed sleep?
                      (      falltsk.asm):00168                ELSE
0CB4 E60C             (      falltsk.asm):00169                  ldb   P$State,x      Is it a timed sleep?
0CB6 C540             (      falltsk.asm):00170                  bitb  #TimSleep
                      (      falltsk.asm):00171                ENDC
0CB8 2706             (      falltsk.asm):00172                  beq   L0CFB          no, go update process table
0CBA EE04             (      falltsk.asm):00173                  ldu   P$SP,x         get it's stack pointer
0CBC EC44             (      falltsk.asm):00174                  ldd   R$X,u          any sleep time left?
0CBE 27EC             (      falltsk.asm):00175                  beq   L0CE7          no, go activate next process in queue
0CC0 9F56             (      falltsk.asm):00176         L0CFB    stx   <D.SProcQ      Store new sleeping process pointer
0CC2 0A2F             (      falltsk.asm):00177         L0CFD    dec   <D.Slice       Any time remaining on process?
0CC4 260C             (      falltsk.asm):00178                  bne   L0D0D          Yes, exit
0CC6 0C2F             (      falltsk.asm):00179                  inc   <D.Slice       reset slice count
0CC8 9E50             (      falltsk.asm):00180                  ldx   <D.Proc        Get current process pointer
0CCA 2706             (      falltsk.asm):00181                  beq   L0D0D          none, return
                      (      falltsk.asm):00182                IFNE  H6309
                      (      falltsk.asm):00183                  oim   #TimOut,P$State,x put him in a timeout state
                      (      falltsk.asm):00184                ELSE
0CCC E60C             (      falltsk.asm):00185                  ldb   P$State,x      put him in a timeout state
0CCE CA20             (      falltsk.asm):00186                  orb   #TimOut
0CD0 E70C             (      falltsk.asm):00187                  stb   P$State,x
                      (      falltsk.asm):00188                ENDC
0CD2 5F               (      falltsk.asm):00189         L0D0D    clrb
0CD3 39               (      falltsk.asm):00190                  rts
                      (    krn_beta5.asm):00660                   use   faproc.asm
                      (       faproc.asm):00001         **************************************************
                      (       faproc.asm):00002         * System Call: F$AProc
                      (       faproc.asm):00003         *
                      (       faproc.asm):00004         * Function: Insert process into active process queue
                      (       faproc.asm):00005         *
                      (       faproc.asm):00006         * Input:  X = Address of process descriptor
                      (       faproc.asm):00007         *
                      (       faproc.asm):00008         * Output: None
                      (       faproc.asm):00009         *
                      (       faproc.asm):00010         * Error:  CC = C bit set; B = error code
                      (       faproc.asm):00011         *
0CD4 AE44             (       faproc.asm):00012         FAProc   ldx   R$X,u        Get ptr to process to activate
0CD6 5F               (       faproc.asm):00013         L0D11    clrb
0CD7 3475             (       faproc.asm):00014                  pshs  cc,b,x,y,u
0CD9 A60A             (       faproc.asm):00015                  lda   P$Prior,x    Get process priority
0CDB A70B             (       faproc.asm):00016                  sta   P$Age,x      Save it as age (How long it's been around)
0CDD 1A50             (       faproc.asm):00017                  orcc  #IntMasks    Shut down IRQ's
0CDF CE0045           (       faproc.asm):00018                  ldu   #(D.AProcQ-P$Queue)  Get ptr to active process queue
0CE2 200A             (       faproc.asm):00019                  bra   L0D29        Go through the chain
                      (       faproc.asm):00020         * Update active process queue
                      (       faproc.asm):00021         *  X=Process to activate
                      (       faproc.asm):00022         *  U=Current process in queue links
0CE4 6C4B             (       faproc.asm):00023         L0D1F    inc   P$Age,u      update current process age
0CE6 2602             (       faproc.asm):00024                  bne   L0D25        wrap?
0CE8 6A4B             (       faproc.asm):00025                  dec   P$Age,u      yes, reset it to max.
0CEA A14B             (       faproc.asm):00026         L0D25    cmpa  P$Age,u      match process ages??
0CEC 2202             (       faproc.asm):00027                  bhi   L0D2B        no, skip update
0CEE 31C4             (       faproc.asm):00028         L0D29    leay  ,u           point Y to current process
0CF0 EE4D             (       faproc.asm):00029         L0D2B    ldu   P$Queue,u    get pointer to next process in chain
0CF2 26F0             (       faproc.asm):00030                  bne   L0D1F        Still more in chain, keep going
0CF4 EC2D             (       faproc.asm):00031                  ldd   P$Queue,y
0CF6 AF2D             (       faproc.asm):00032                  stx   P$Queue,y    save new process to chain
0CF8 ED0D             (       faproc.asm):00033                  std   P$Queue,x
0CFA 35F5             (       faproc.asm):00034                  puls  cc,b,x,y,u,pc
                      (    krn_beta5.asm):00661         
                      (    krn_beta5.asm):00662         * System IRQ service routine
0CFC 9E50             (    krn_beta5.asm):00663         XIRQ      ldx   <D.Proc     get current process pointer
0CFE 10EF04           (    krn_beta5.asm):00664                   sts   P$SP,x      save the stack pointer
0D01 10DECC           (    krn_beta5.asm):00665                   lds   <D.SysStk   get system stack pointer
0D04 DCC0             (    krn_beta5.asm):00666                   ldd   <D.SysSvc   set system service routine to current
0D06 DDE4             (    krn_beta5.asm):00667                   std   <D.XSWI2
0D08 DCC4             (    krn_beta5.asm):00668                   ldd   <D.SysIRQ   set system IRQ routine to current
0D0A DDE8             (    krn_beta5.asm):00669                   std   <D.XIRQ
0D0C AD9F00CE         (    krn_beta5.asm):00670                   jsr   [>D.SvcIRQ] execute irq service
0D10 2414             (    krn_beta5.asm):00671                   bcc   L0D5B
0D12 9E50             (    krn_beta5.asm):00672                   ldx   <D.Proc     get current process pointer
0D14 E606             (    krn_beta5.asm):00673                   ldb   P$Task,x
0D16 AE04             (    krn_beta5.asm):00674                   ldx   P$SP,x      get it's stack pointer
0D18 3447             (    krn_beta5.asm):00675                   pshs  u,d,cc      save some registers
0D1A 33E4             (    krn_beta5.asm):00676                   leau  ,s          point to a 'caller register stack'
0D1C 17FED8           (    krn_beta5.asm):00677                   lbsr  L0C40       do a LDB 0,X in task B
0D1F 3547             (    krn_beta5.asm):00678                   puls  u,d,cc      and now A ( R$A,U ) = the CC we want
0D21 8A50             (    krn_beta5.asm):00679                   ora   #IntMasks   disable it's IRQ's
0D23 17FEEB           (    krn_beta5.asm):00680                   lbsr  L0C28       save it back
0D26 1A50             (    krn_beta5.asm):00681         L0D5B     orcc  #IntMasks   shut down IRQ's
0D28 9E50             (    krn_beta5.asm):00682                   ldx   <D.Proc     get current process pointer
0D2A 0D3F             (    krn_beta5.asm):00683                   tst   <D.QIRQ     was it a clock IRQ?
0D2C 1026008D         (    krn_beta5.asm):00684                   lbne  L0DF7       if not, do a quick return
0D30 A60C             (    krn_beta5.asm):00685                   lda   P$State,x   Get it's state
0D32 8520             (    krn_beta5.asm):00686                   bita  #TimOut     Is it timed out?
0D34 2617             (    krn_beta5.asm):00687                   bne   L0D7C       yes, wake it up
                      (    krn_beta5.asm):00688         * Update active process queue
0D36 CE0045           (    krn_beta5.asm):00689                   ldu   #(D.AProcQ-P$Queue)    point to active process queue
0D39 C608             (    krn_beta5.asm):00690                   ldb   #Suspend    get suspend flag
0D3B EE4D             (    krn_beta5.asm):00691         L0D6A     ldu   P$Queue,u   get a active process pointer
0D3D 270A             (    krn_beta5.asm):00692                   beq   L0D78
0D3F E54C             (    krn_beta5.asm):00693                   bitb  P$State,u   is it suspended?
0D41 26F8             (    krn_beta5.asm):00694                   bne   L0D6A       yes, go to next one in chain
0D43 E60A             (    krn_beta5.asm):00695                   ldb   P$Prior,x   get current process priority
0D45 E14A             (    krn_beta5.asm):00696                   cmpb  P$Prior,u   do we bump this one?
0D47 2504             (    krn_beta5.asm):00697                   blo   L0D7C
0D49 EE04             (    krn_beta5.asm):00698         L0D78     ldu   P$SP,x
0D4B 203A             (    krn_beta5.asm):00699                   bra   L0DB9
                      (    krn_beta5.asm):00700         
0D4D 84DF             (    krn_beta5.asm):00701         L0D7C     anda  #^TimOut
0D4F A70C             (    krn_beta5.asm):00702                   sta   P$State,x
     0D51             (    krn_beta5.asm):00703         L0D80     equ   *
0D51 8D83             (    krn_beta5.asm):00704         L0D83     bsr   L0D11        activate next process
                      (    krn_beta5.asm):00705                 
                      (    krn_beta5.asm):00706                   use   fnproc.asm
                      (       fnproc.asm):00001         **************************************************
                      (       fnproc.asm):00002         * System Call: F$NProc
                      (       fnproc.asm):00003         *
                      (       fnproc.asm):00004         * Function: Start the next process in the active queue
                      (       fnproc.asm):00005         *
                      (       fnproc.asm):00006         * Input:  None
                      (       fnproc.asm):00007         *
                      (       fnproc.asm):00008         * Output: Control does not return to the caller
                      (       fnproc.asm):00009         *
0D53                  (       fnproc.asm):00010         FNProc   
                      (       fnproc.asm):00011                IFGT  Level-1
0D53 9E4A             (       fnproc.asm):00012                  ldx   <D.SysPrc   get system process descriptor
0D55 9F50             (       fnproc.asm):00013                  stx   <D.Proc     save it as current
0D57 10DECC           (       fnproc.asm):00014                  lds   <D.SysStk   get system stack pointer
0D5A 1CAF             (       fnproc.asm):00015                  andcc #^IntMasks  re-enable IRQ's (to allow pending one through)
                      (       fnproc.asm):00016                ELSE
                      (       fnproc.asm):00017                  clra
                      (       fnproc.asm):00018                  clrb
                      (       fnproc.asm):00019                  std   <D.Proc
                      (       fnproc.asm):00020                ENDC
0D5C 8C               (       fnproc.asm):00021                  fcb   $8C        skip the next 2 bytes
0D5D 3CAF             (       fnproc.asm):00022         L0D91    cwai  #^IntMasks  re-enable IRQ's and wait for one
0D5F 1A50             (       fnproc.asm):00023         L0D93    orcc  #IntMasks   Shut off interrupts again
0D61 8608             (       fnproc.asm):00024                  lda   #Suspend    get suspend suspend state flag
0D63 8E0045           (       fnproc.asm):00025                  ldx   #D.AProcQ-P$Queue For start of loop, setup to point to current process
                      (       fnproc.asm):00026         * Loop to find next active process that is not Suspended
0D66 3184             (       fnproc.asm):00027         L0D9A    leay  ,x          Point y to previous link (process dsc. ptr)
0D68 AE2D             (       fnproc.asm):00028                  ldx   P$Queue,y   Get process dsc. ptr for next active process
0D6A 27F1             (       fnproc.asm):00029                  beq   L0D91       None, allow any pending IRQ thru & try again
0D6C A50C             (       fnproc.asm):00030                  bita  P$State,x   There is one, is it Suspended?
0D6E 26F6             (       fnproc.asm):00031                  bne   L0D9A       Yes, skip it & try next one
                      (       fnproc.asm):00032         * Found a process in line ready to be started
0D70 EC0D             (       fnproc.asm):00033                  ldd   P$Queue,x   Get next process dsc. ptr in line after found one
0D72 ED2D             (       fnproc.asm):00034                  std   P$Queue,y   Save the next one in line in previous' next ptr
0D74 9F50             (       fnproc.asm):00035                  stx   <D.Proc     Make new process dsc. the current one
0D76 17FEB0           (       fnproc.asm):00036                  lbsr  L0C58       Go check or make a task # for the found process
0D79 25D6             (       fnproc.asm):00037                  bcs   L0D83       Couldn't get one, go to next process in line
0D7B 9630             (       fnproc.asm):00038                  lda   <D.TSlice   Reload # ticks this process can run
0D7D 972F             (       fnproc.asm):00039                  sta   <D.Slice    Save as new tick counter for process
0D7F EE04             (       fnproc.asm):00040                  ldu   P$SP,x      get the process stack pointer
0D81 A60C             (       fnproc.asm):00041                  lda   P$State,x   get it's state
0D83 102B008E         (       fnproc.asm):00042                  lbmi  L0E29       If in System State, switch to system task (0)
0D87 8502             (       fnproc.asm):00043         L0DB9    bita  #Condem     Was it condemned by a deadly signal?
0D89 264D             (       fnproc.asm):00044                  bne   L0DFD       Yes, go exit with Error=the signal code #
0D8B 17FEB3           (       fnproc.asm):00045                  lbsr  TstImg      do a F$SetTsk if the ImgChg flag is set
0D8E E68819           (       fnproc.asm):00046         L0DBD    ldb   <P$Signal,x any signals?
0D91 272A             (       fnproc.asm):00047                  beq   L0DF7       no, go on
0D93 5A               (       fnproc.asm):00048                  decb              is it a wake up signal?
0D94 2724             (       fnproc.asm):00049                  beq   L0DEF       yes, go wake it up
0D96 3274             (       fnproc.asm):00050                  leas  -R$Size,s   make a register buffer on stack
0D98 33E4             (       fnproc.asm):00051                  leau  ,s          point to it
0D9A 17F515           (       fnproc.asm):00052                  lbsr  L02CB       copy the stack from process to our copy of it
0D9D A68819           (       fnproc.asm):00053                  lda   <P$Signal,x get last signal
0DA0 A742             (       fnproc.asm):00054                  sta   R$B,u       save it to process' B
0DA2 EC881A           (       fnproc.asm):00055                  ldd   <P$SigVec,x any intercept trap?
0DA5 2731             (       fnproc.asm):00056                  beq   L0DFD       no, go force the process to F$Exit
0DA7 ED4A             (       fnproc.asm):00057                  std   R$PC,u      save vector to it's PC
0DA9 EC881C           (       fnproc.asm):00058                  ldd   <P$SigDat,x get pointer to intercept data area
0DAC ED48             (       fnproc.asm):00059                  std   R$U,u       save it to it's U
0DAE EC04             (       fnproc.asm):00060                  ldd   P$SP,x      get it's stack pointer
0DB0 83000C           (       fnproc.asm):00061                  subd  #R$Size     take off register stack
0DB3 ED04             (       fnproc.asm):00062                  std   P$SP,x      save updated SP
0DB5 17F509           (       fnproc.asm):00063                  lbsr  L02DA       Copy modified stack back overtop process' stack
0DB8 326C             (       fnproc.asm):00064                  leas  R$Size,s    purge temporary stack
0DBA 6F8819           (       fnproc.asm):00065         L0DEF    clr   <P$Signal,x clear the signal
                      (       fnproc.asm):00066         * No signals go here
     0DBD             (       fnproc.asm):00067         L0DF7    equ   *
                      (       fnproc.asm):00068                IFNE  H6309
                      (       fnproc.asm):00069                  oim   #$01,<D.Quick  Flag that stack is NOT at $FEE1
                      (       fnproc.asm):00070                ELSE
0DBD D63E             (       fnproc.asm):00071                  ldb   <D.Quick    Flag that stack is NOT at $FEE1
0DBF CA01             (       fnproc.asm):00072                  orb   #$01
0DC1 D73E             (       fnproc.asm):00073                  stb   <D.Quick
                      (       fnproc.asm):00074                ENDC
     0DC3             (       fnproc.asm):00075         BackTo1  equ   *
0DC3 DEC6             (       fnproc.asm):00076         L0DF2    ldu   <D.UsrSvc   Get current User's system call service routine ptr
0DC5 DFE4             (       fnproc.asm):00077                  stu   <D.XSWI2    Save as SWI2 service routine ptr
0DC7 DECA             (       fnproc.asm):00078                  ldu   <D.UsrIRQ   Get IRQ entry point for user state
0DC9 DFE8             (       fnproc.asm):00079                  stu   <D.XIRQ     Save as IRQ service routine ptr
0DCB E606             (       fnproc.asm):00080                  ldb   P$Task,x    get task number
0DCD 58               (       fnproc.asm):00081                  lslb              2 bytes per entry in D.TskIpt
0DCE 10AE04           (       fnproc.asm):00082                  ldy   P$SP,x      get stack pointer
0DD1 17008D           (       fnproc.asm):00083                  lbsr  L0E8D       re-map the DAT image, if necessary
0DD4 D63E             (       fnproc.asm):00084                  ldb   <D.Quick    get quick return flag
0DD6 2053             (       fnproc.asm):00085                  bra   L0E4C       Go switch GIME over to new process & run
                      (       fnproc.asm):00086         
                      (       fnproc.asm):00087         * Process a signal (process had no signal trap)
     0DD8             (       fnproc.asm):00088         L0DFD    equ   *
                      (       fnproc.asm):00089                IFNE  H6309
                      (       fnproc.asm):00090                  oim   #SysState,P$State,x  Put process into system state
                      (       fnproc.asm):00091                ELSE
0DD8 E60C             (       fnproc.asm):00092                  ldb   P$State,x    Put process into system state
0DDA CA80             (       fnproc.asm):00093                  orb   #SysState
0DDC E70C             (       fnproc.asm):00094                  stb   P$State,x
                      (       fnproc.asm):00095                ENDC
0DDE 32890200         (       fnproc.asm):00096                  leas  >P$Stack,x   Point SP to process' stack
0DE2 1CAF             (       fnproc.asm):00097                  andcc #^IntMasks   Turn interrupts on
0DE4 E68819           (       fnproc.asm):00098                  ldb   <P$Signal,x  Get signal that process received
0DE7 6F8819           (       fnproc.asm):00099                  clr   <P$Signal,x  Clear out the one in process dsc.
0DEA 103F06           (       fnproc.asm):00100                  os9   F$Exit       Exit with signal # being error code
                      (       fnproc.asm):00101         
0DED 6E9F0026         (       fnproc.asm):00102         S.SvcIRQ jmp    [>D.Poll]   Call IOMAN for IRQ polling
                      (    krn_beta5.asm):00707                 
                      (    krn_beta5.asm):00708         * The following routines must appear no earlier than $E00 when assembled, as
                      (    krn_beta5.asm):00709         * they have to always be in the vector RAM page ($FE00-$FEFF)
                      (    krn_beta5.asm):00710                 
                      (    krn_beta5.asm):00711         * Default routine for D.SysIRQ
0DF1 96A4             (    krn_beta5.asm):00712         S.SysIRQ  lda   <D.SSTskN   Get current task's GIME task # (0 or 1)
0DF3 2713             (    krn_beta5.asm):00713                   beq   FastIRQ     Use super-fast version for system state
0DF5 0FA4             (    krn_beta5.asm):00714                   clr   <D.SSTskN   Clear out memory copy (task 0)
0DF7 AD9F00CE         (    krn_beta5.asm):00715                   jsr   [>D.SvcIRQ] (Normally routine in Clock calling D.Poll)
0DFB 0CA4             (    krn_beta5.asm):00716                   inc   <D.SSTskN   Save task # for system state
0DFD 8601             (    krn_beta5.asm):00717                   lda   #1          Task 1
0DFF 9A91             (    krn_beta5.asm):00718                   ora   <D.TINIT    Merge task bit's into Shadow version
0E01 9791             (    krn_beta5.asm):00719                   sta   <D.TINIT    Update shadow
0E03 B7FF91           (    krn_beta5.asm):00720                   sta   >DAT.Task   Save to GIME as well & return
0E06 2004             (    krn_beta5.asm):00721                   bra   DoneIRQ     Check for error and exit
                      (    krn_beta5.asm):00722                 
0E08 AD9F00CE         (    krn_beta5.asm):00723         FastIRQ   jsr   [>D.SvcIRQ] (Normally routine in Clock calling D.Poll)
0E0C 2406             (    krn_beta5.asm):00724         DoneIRQ   bcc   L0E28       No error on IRQ, exit
                      (    krn_beta5.asm):00725                 IFNE    H6309
                      (    krn_beta5.asm):00726                   oim   #IntMasks,0,s  Setup RTI to shut interrupts off again
                      (    krn_beta5.asm):00727                 ELSE    
0E0E A6E4             (    krn_beta5.asm):00728                   lda   ,s          Setup RTI to shut interrupts off again
0E10 8A50             (    krn_beta5.asm):00729                   ora   #IntMasks
0E12 A7E4             (    krn_beta5.asm):00730                   sta   ,s
                      (    krn_beta5.asm):00731                 ENDC
0E14 3B               (    krn_beta5.asm):00732         L0E28     rti
                      (    krn_beta5.asm):00733         
                      (    krn_beta5.asm):00734         * return from a system call
0E15 4F               (    krn_beta5.asm):00735         L0E29     clra              Force System task # to 0 (non-GRDRV)
0E16 9E4A             (    krn_beta5.asm):00736         L0E2B     ldx   <D.SysPrc   Get system process dsc. ptr
0E18 17FE26           (    krn_beta5.asm):00737                   lbsr  TstImg      check image, and F$SetTsk (PRESERVES A)
0E1B 1A50             (    krn_beta5.asm):00738                   orcc  #IntMasks   Shut interrupts off
0E1D 97A4             (    krn_beta5.asm):00739                   sta   <D.SSTskN   Save task # for system state
0E1F 2707             (    krn_beta5.asm):00740                   beq   Fst2        If task 0, skip subroutine
0E21 9A91             (    krn_beta5.asm):00741                   ora   <D.TINIT    Merge task bit's into Shadow version
0E23 9791             (    krn_beta5.asm):00742                   sta   <D.TINIT    Update shadow
0E25 B7FF91           (    krn_beta5.asm):00743                   sta   >DAT.Task   Save to GIME as well & return
0E28 32C4             (    krn_beta5.asm):00744         Fst2      leas  ,u          Stack ptr=U & return
0E2A 3B               (    krn_beta5.asm):00745                   rti
                      (    krn_beta5.asm):00746         
                      (    krn_beta5.asm):00747         * Switch to new process, X=Process descriptor pointer, U=Stack pointer
     0E2B             (    krn_beta5.asm):00748         L0E4C     equ    *
                      (    krn_beta5.asm):00749                 IFNE  H6309
                      (    krn_beta5.asm):00750                   oim   #$01,<D.TINIT  switch GIME shadow to user state
                      (    krn_beta5.asm):00751                   lda   <D.TINIT
                      (    krn_beta5.asm):00752                 ELSE
0E2B 9691             (    krn_beta5.asm):00753                   lda   <D.TINIT    switch GIME shadow to user state
0E2D 8A01             (    krn_beta5.asm):00754                   ora   #$01
0E2F 9791             (    krn_beta5.asm):00755                   sta   <D.TINIT
                      (    krn_beta5.asm):00756                 ENDC
0E31 B7FF91           (    krn_beta5.asm):00757                   sta   >DAT.Task   save it to GIME
0E34 32A4             (    krn_beta5.asm):00758                   leas  ,y          point to new stack
0E36 5D               (    krn_beta5.asm):00759                   tstb              is the stack at SWISTACK?
0E37 260C             (    krn_beta5.asm):00760                   bne   MyRTI       no, we're doing a system-state rti
                      (    krn_beta5.asm):00761                 IFNE  H6309
                      (    krn_beta5.asm):00762                   ldf   #R$Size     E=0 from call to L0E8D before
                      (    krn_beta5.asm):00763                   ldu   #Where+SWIStack    point to the stack
                      (    krn_beta5.asm):00764                   tfm   u+,y+       move the stack from top of memory to user memory
                      (    krn_beta5.asm):00765                 ELSE
0E39 C606             (    krn_beta5.asm):00766                   ldb   #R$Size/2
0E3B CEFEDF           (    krn_beta5.asm):00767                   ldu   #Where+SWIStack  point to the stack
0E3E AEC1             (    krn_beta5.asm):00768         RtiLoop   ldx   ,u++
0E40 AFA1             (    krn_beta5.asm):00769                   stx   ,y++
0E42 5A               (    krn_beta5.asm):00770                   decb
0E43 26F9             (    krn_beta5.asm):00771                   bne   RtiLoop
                      (    krn_beta5.asm):00772                 ENDC
0E45 3B               (    krn_beta5.asm):00773         MyRTI     rti               return from IRQ
                      (    krn_beta5.asm):00774         
                      (    krn_beta5.asm):00775         * Execute routine in task 1 pointed to by U
                      (    krn_beta5.asm):00776         * comes from user requested SWI vectors
     0E46             (    krn_beta5.asm):00777         L0E5E     equ    *
                      (    krn_beta5.asm):00778                 IFNE  H6309
                      (    krn_beta5.asm):00779                   oim    #$01,<D.TINIT  switch GIME shadow to user state
                      (    krn_beta5.asm):00780                   ldb    <D.TINIT
                      (    krn_beta5.asm):00781                 ELSE
0E46 D691             (    krn_beta5.asm):00782                   ldb    <D.TINIT   switch GIME shadow to user state
0E48 CA01             (    krn_beta5.asm):00783                   orb    #$01
0E4A D791             (    krn_beta5.asm):00784                   stb    <D.TINIT
                      (    krn_beta5.asm):00785                 ENDC
0E4C F7FF91           (    krn_beta5.asm):00786                   stb    >DAT.Task
0E4F 6EC4             (    krn_beta5.asm):00787                   jmp    ,u
                      (    krn_beta5.asm):00788         
                      (    krn_beta5.asm):00789         * Flip to task 1 (used by GRF/WINDInt to switch to GRFDRV) (pointed to 
                      (    krn_beta5.asm):00790         *  by <D.Flip1). All regs are already preserved on stack for the RTI
0E51 C602             (    krn_beta5.asm):00791         S.Flip1   ldb   #2          get Task image entry numberx2 for Grfdrv (task 1)
0E53 8D0C             (    krn_beta5.asm):00792                   bsr   L0E8D       copy over the DAT image
                      (    krn_beta5.asm):00793                 IFNE  H6309
                      (    krn_beta5.asm):00794                   oim   #$01,<D.TINIT
                      (    krn_beta5.asm):00795                   lda   <D.TINIT    get copy of GIME Task side
                      (    krn_beta5.asm):00796                 ELSE
0E55 9691             (    krn_beta5.asm):00797                   lda   <D.TINIT    get copy of GIME Task side
0E57 8A01             (    krn_beta5.asm):00798                   ora   #$01
0E59 9791             (    krn_beta5.asm):00799                   sta   <D.TINIT
                      (    krn_beta5.asm):00800                 ENDC
0E5B B7FF91           (    krn_beta5.asm):00801                   sta   >DAT.Task   save it to GIME register
0E5E 0CA4             (    krn_beta5.asm):00802                   inc   <D.SSTskN   increment system state task number
0E60 3B               (    krn_beta5.asm):00803                   rti               return
                      (    krn_beta5.asm):00804         
                      (    krn_beta5.asm):00805         * Setup MMU in task 1, B=Task # to swap to, shifted left 1 bit
0E61 D13D             (    krn_beta5.asm):00806         L0E8D     cmpb  <D.Task1N   are we going back to the same task
0E63 271B             (    krn_beta5.asm):00807                   beq   L0EA3       without the DAT image changing?
0E65 D73D             (    krn_beta5.asm):00808                   stb   <D.Task1N   nope, save current task in map type 1
0E67 8EFFA8           (    krn_beta5.asm):00809                   ldx   #$FFA8      get MMU start register for process's
0E6A DEA1             (    krn_beta5.asm):00810                   ldu   <D.TskIPt   get task image pointer table
0E6C EEC5             (    krn_beta5.asm):00811                   ldu   b,u         get address of DAT image
0E6E 3341             (    krn_beta5.asm):00812         L0E93     leau  1,u         point to actual MMU block
                      (    krn_beta5.asm):00813                 IFNE  H6309
                      (    krn_beta5.asm):00814                   lde   #4          get # banks/2 for task
                      (    krn_beta5.asm):00815                 ELSE
0E70 8604             (    krn_beta5.asm):00816                   lda   #4          get # banks/2 for task
0E72 3402             (    krn_beta5.asm):00817                   pshs  a
                      (    krn_beta5.asm):00818                 ENDC
0E74 A6C1             (    krn_beta5.asm):00819         L0E9B     lda   ,u++        get a bank
0E76 E6C1             (    krn_beta5.asm):00820                   ldb   ,u++        and next one
0E78 ED81             (    krn_beta5.asm):00821                   std   ,x++        Save it to MMU
                      (    krn_beta5.asm):00822                 IFNE    H6309
                      (    krn_beta5.asm):00823                   dece              Done?
                      (    krn_beta5.asm):00824                 ELSE
0E7A 6AE4             (    krn_beta5.asm):00825                   dec   ,s          Done?
                      (    krn_beta5.asm):00826                 ENDC
0E7C 26F6             (    krn_beta5.asm):00827                   bne   L0E9B       no, keep going
                      (    krn_beta5.asm):00828                 IFEQ    H6309
                      (    krn_beta5.asm):00829         * 6809 - 10 cyc down to 8
                      (    krn_beta5.asm):00830         *          leas  1,s         Eat temp stack
0E7E 3582             (    krn_beta5.asm):00831                   puls  a,pc        Eat temp & return
                      (    krn_beta5.asm):00832                 ENDC
0E80 39               (    krn_beta5.asm):00833         L0EA3     rts               return
                      (    krn_beta5.asm):00834         
                      (    krn_beta5.asm):00835         * Execute FIRQ vector (called from $FEF4)
0E81 8E00F6           (    krn_beta5.asm):00836         FIRQVCT   ldx   #D.FIRQ     get DP offset of vector
0E84 2005             (    krn_beta5.asm):00837                   bra   L0EB8       go execute it
                      (    krn_beta5.asm):00838         
                      (    krn_beta5.asm):00839         * Execute IRQ vector (called from $FEF7)
0E86 1A50             (    krn_beta5.asm):00840         IRQVCT    orcc  #IntMasks   disasble IRQ's
0E88 8E00F8           (    krn_beta5.asm):00841                   ldx   #D.IRQ      get DP offset of vector
                      (    krn_beta5.asm):00842         * Execute interrupt vector, B=DP Vector offset
0E8B 4F               (    krn_beta5.asm):00843         L0EB8     clra              (faster than CLR >$xxxx)
0E8C B7FF91           (    krn_beta5.asm):00844                   sta   >DAT.Task   Force to Task 0 (system state)
                      (    krn_beta5.asm):00845                 IFNE  H6309
                      (    krn_beta5.asm):00846                   tfr   0,dp        setup DP
                      (    krn_beta5.asm):00847                 ELSE
0E8F 1F8B             (    krn_beta5.asm):00848                   tfr    a,dp       setup DP
                      (    krn_beta5.asm):00849                 ENDC
     0E91             (    krn_beta5.asm):00850         MapGrf    equ   *
                      (    krn_beta5.asm):00851                 IFNE  H6309
                      (    krn_beta5.asm):00852                   aim   #$FE,<D.TINIT  switch GIME shadow to system state
                      (    krn_beta5.asm):00853                   lda   <D.TINIT    set GIME again just in case timer is used
                      (    krn_beta5.asm):00854                 ELSE
0E91 9691             (    krn_beta5.asm):00855                   lda   <D.TINIT    switch GIME shadow to system state
0E93 84FE             (    krn_beta5.asm):00856                   anda  #$FE
0E95 9791             (    krn_beta5.asm):00857                   sta   <D.TINIT
                      (    krn_beta5.asm):00858                 ENDC
0E97 B7FF91           (    krn_beta5.asm):00859         MapT0     sta   >DAT.Task
0E9A 6E94             (    krn_beta5.asm):00860                   jmp   [,x]        execute it
                      (    krn_beta5.asm):00861         
                      (    krn_beta5.asm):00862         * Execute SWI3 vector (called from $FEEE)
0E9C 1A50             (    krn_beta5.asm):00863         SWI3VCT   orcc  #IntMasks   disable IRQ's
0E9E 8E00F2           (    krn_beta5.asm):00864                   ldx   #D.SWI3     get DP offset of vector
0EA1 2005             (    krn_beta5.asm):00865                   bra   SWICall     go execute it
                      (    krn_beta5.asm):00866         
                      (    krn_beta5.asm):00867         * Execute SWI2 vector (called from $FEF1)
0EA3 1A50             (    krn_beta5.asm):00868         SWI2VCT   orcc  #IntMasks   disasble IRQ's
0EA5 8E00F4           (    krn_beta5.asm):00869                   ldx   #D.SWI2     get DP offset of vector
                      (    krn_beta5.asm):00870         * This routine is called from an SWI, SWI2, or SWI3
                      (    krn_beta5.asm):00871         * saves 1 cycle on system-system calls
                      (    krn_beta5.asm):00872         * saves about 200 cycles (calls to I.LDABX and L029E) on grfdrv-system,
                      (    krn_beta5.asm):00873         *  or user-system calls.
0EA8 E6F80A           (    krn_beta5.asm):00874         SWICall   ldb   [R$PC,s]    get callcode of the system call
                      (    krn_beta5.asm):00875         * NOTE: Alan DeKok claims that this is BAD.  It crashed Colin McKay's
                      (    krn_beta5.asm):00876         * CoCo 3.  Instead, we should do a clra/sta >DAT.Task.
                      (    krn_beta5.asm):00877         *         clr   >DAT.Task    go to map type 1
0EAB 4F               (    krn_beta5.asm):00878                   clra
0EAC B7FF91           (    krn_beta5.asm):00879                   sta   >DAT.Task
                      (    krn_beta5.asm):00880         * set DP to zero
                      (    krn_beta5.asm):00881                 IFNE  H6309
                      (    krn_beta5.asm):00882                   tfr   0,dp
                      (    krn_beta5.asm):00883                 ELSE    
0EAF 1F8B             (    krn_beta5.asm):00884                   tfr   a,dp
                      (    krn_beta5.asm):00885                 ENDC    
                      (    krn_beta5.asm):00886         * These lines add a total of 81 addition cycles to each SWI(2,3) call,
                      (    krn_beta5.asm):00887         * and 36 bytes+12 for R$Size in the constant page at $FExx
                      (    krn_beta5.asm):00888         *  It takes no more time for a SWI(2,3) from system state than previously,
                      (    krn_beta5.asm):00889         * ... and adds 14 cycles to each SWI(2,3) call from grfdrv... not a problem.
                      (    krn_beta5.asm):00890         * For processes that re-vector SWI, SWI3, it adds 81 cycles.  BUT SWI(3)
                      (    krn_beta5.asm):00891         * CANNOT be vectored to L0EBF cause the user SWI service routine has been
                      (    krn_beta5.asm):00892         * changed
0EB1 9691             (    krn_beta5.asm):00893                   lda   <D.TINIT    get map type flag
0EB3 8501             (    krn_beta5.asm):00894                   bita  #$01        check it without changing it
                      (    krn_beta5.asm):00895         * Change to LBEQ R.SysSvc to avoid JMP [,X]
                      (    krn_beta5.asm):00896         * and add R.SysSvc STA >DAT.Task ???
0EB5 27E0             (    krn_beta5.asm):00897                   beq   MapT0       in map 0: restore hardware and do system service
0EB7 0DA4             (    krn_beta5.asm):00898                   tst   <D.SSTskN   get system state 0,1
0EB9 26D6             (    krn_beta5.asm):00899                   bne   MapGrf      if in grfdrv, go to map 0 and do system service
                      (    krn_beta5.asm):00900         * the preceding few lines are necessary, as all SWI's still pass thru
                      (    krn_beta5.asm):00901         * here before being vectored to the system service routine... which
                      (    krn_beta5.asm):00902         * doesn't copy the stack from user state.
0EBB B7FF91           (    krn_beta5.asm):00903                   sta   >DAT.Task   go to map type X again to get user's stack
                      (    krn_beta5.asm):00904         * a byte less, a cycle more than ldy #$FEED-R$Size, or ldy #$F000+SWIStack
0EBE 318C1E           (    krn_beta5.asm):00905                   leay  <SWIStack,pc  where to put the register stack: to $FEDF
0EC1 1F43             (    krn_beta5.asm):00906                   tfr   s,u         get a copy of where the stack is
                      (    krn_beta5.asm):00907                 IFNE    H6309
                      (    krn_beta5.asm):00908                   ldw   #R$Size     get the size of the stack
                      (    krn_beta5.asm):00909                   tfm   u+,y+       move the stack to the top of memory
                      (    krn_beta5.asm):00910                 ELSE
0EC3 3410             (    krn_beta5.asm):00911                   pshs  x
0EC5 8606             (    krn_beta5.asm):00912                   lda   #R$Size/2   Move stack to top of memory (A is reset in L0EB8, no need to preserve)
0EC7 AEC1             (    krn_beta5.asm):00913         Looper    ldx   ,u++
0EC9 AFA1             (    krn_beta5.asm):00914                   stx   ,y++
0ECB 4A               (    krn_beta5.asm):00915                   deca
0ECC 26F9             (    krn_beta5.asm):00916                   bne   Looper
0ECE 3510             (    krn_beta5.asm):00917                   puls  x
                      (    krn_beta5.asm):00918                 ENDC
0ED0 20B9             (    krn_beta5.asm):00919                   bra   L0EB8       and go from map type 1 to map type 0
                      (    krn_beta5.asm):00920         
                      (    krn_beta5.asm):00921         * Execute SWI vector (called from $FEFA)
0ED2 8E00FA           (    krn_beta5.asm):00922         SWIVCT    ldx   #D.SWI      get DP offset of vector
0ED5 20D1             (    krn_beta5.asm):00923                   bra   SWICall     go execute it
                      (    krn_beta5.asm):00924         
                      (    krn_beta5.asm):00925         * Execute NMI vector (called from $FEFD)
0ED7 8E00FC           (    krn_beta5.asm):00926         NMIVCT    ldx   #D.NMI      get DP offset of vector
0EDA 20AF             (    krn_beta5.asm):00927                   bra   L0EB8       go execute it
                      (    krn_beta5.asm):00928         
                      (    krn_beta5.asm):00929         * The end of the kernel module is here
0EDC 8BBD73           (    krn_beta5.asm):00930                   emod
     0EDF             (    krn_beta5.asm):00931         eom       equ   *
                      (    krn_beta5.asm):00932         
                      (    krn_beta5.asm):00933         * What follows after the kernel module is the register stack, starting
                      (    krn_beta5.asm):00934         * at $FEDD (6309) or $FEDF (6809).  This register stack area is used by
                      (    krn_beta5.asm):00935         * the kernel to save the caller's registers in the $FEXX area of memory
                      (    krn_beta5.asm):00936         * because it doesn't get "switched out" no matter the contents of the
                      (    krn_beta5.asm):00937         * MMU registers.
0EDF 5245474953544552 (    krn_beta5.asm):00938         SWIStack  fcc   /REGISTER STACK/  same # bytes as R$Size for 6809
     20535441434B
                      (    krn_beta5.asm):00939                 IFNE  H6309
                      (    krn_beta5.asm):00940                   fcc   /63/        if 6309, add two more spaces
                      (    krn_beta5.asm):00941                 ENDC
0EED 55               (    krn_beta5.asm):00942                   fcb   $55         D.ErrRst
                      (    krn_beta5.asm):00943         
                      (    krn_beta5.asm):00944         * This list of addresses ends up at $FEEE after the kernel track is loaded
                      (    krn_beta5.asm):00945         * into memory.  All interrupts come through the 6809 vectors at $FFF0-$FFFE
                      (    krn_beta5.asm):00946         * and get directed to here.  From here, the BRA takes CPU control to the
                      (    krn_beta5.asm):00947         * various handlers in the kernel.
0EEE 20AC             (    krn_beta5.asm):00948                   bra   SWI3VCT     SWI3 vector comes here
0EF0 12               (    krn_beta5.asm):00949                   nop
0EF1 20B0             (    krn_beta5.asm):00950                   bra   SWI2VCT     SWI2 vector comes here
0EF3 12               (    krn_beta5.asm):00951                   nop
0EF4 208B             (    krn_beta5.asm):00952                   bra   FIRQVCT     FIRQ vector comes here
0EF6 12               (    krn_beta5.asm):00953                   nop
0EF7 208D             (    krn_beta5.asm):00954                   bra   IRQVCT      IRQ vector comes here
0EF9 12               (    krn_beta5.asm):00955                   nop
0EFA 20D6             (    krn_beta5.asm):00956                   bra   SWIVCT      SWI vector comes here
0EFC 12               (    krn_beta5.asm):00957                   nop
0EFD 20D8             (    krn_beta5.asm):00958                   bra   NMIVCT      NMI vector comes here
0EFF 12               (    krn_beta5.asm):00959                   nop
                      (    krn_beta5.asm):00960         
                      (    krn_beta5.asm):00961                   end
